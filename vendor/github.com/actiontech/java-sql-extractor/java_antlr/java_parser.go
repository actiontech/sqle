// Code generated from JavaParser.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // JavaParser

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type JavaParser struct {
	*antlr.BaseParser
}

var JavaParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func javaparserParserInit() {
	staticData := &JavaParserParserStaticData
	staticData.LiteralNames = []string{
		"", "'abstract'", "'assert'", "'boolean'", "'break'", "'byte'", "'case'",
		"'catch'", "'char'", "'class'", "'const'", "'continue'", "'default'",
		"'do'", "'double'", "'else'", "'enum'", "'extends'", "'final'", "'finally'",
		"'float'", "'for'", "'if'", "'goto'", "'implements'", "'import'", "'instanceof'",
		"'int'", "'interface'", "'long'", "'native'", "'new'", "'package'",
		"'private'", "'protected'", "'public'", "'return'", "'short'", "'static'",
		"'strictfp'", "'super'", "'switch'", "'synchronized'", "'this'", "'throw'",
		"'throws'", "'transient'", "'try'", "'void'", "'volatile'", "'while'",
		"'module'", "'open'", "'requires'", "'exports'", "'opens'", "'to'",
		"'uses'", "'provides'", "'with'", "'transitive'", "'var'", "'yield'",
		"'record'", "'sealed'", "'permits'", "'non-sealed'", "", "", "", "",
		"", "", "", "", "", "", "'null'", "'('", "')'", "'{'", "'}'", "'['",
		"']'", "';'", "','", "'.'", "'='", "'>'", "'<'", "'!'", "'~'", "'?'",
		"':'", "'=='", "'<='", "'>='", "'!='", "'&&'", "'||'", "'++'", "'--'",
		"'+'", "'-'", "'*'", "'/'", "'&'", "'|'", "'^'", "'%'", "'+='", "'-='",
		"'*='", "'/='", "'&='", "'|='", "'^='", "'%='", "'<<='", "'>>='", "'>>>='",
		"'->'", "'::'", "'@'", "'...'",
	}
	staticData.SymbolicNames = []string{
		"", "ABSTRACT", "ASSERT", "BOOLEAN", "BREAK", "BYTE", "CASE", "CATCH",
		"CHAR", "CLASS", "CONST", "CONTINUE", "DEFAULT", "DO", "DOUBLE", "ELSE",
		"ENUM", "EXTENDS", "FINAL", "FINALLY", "FLOAT", "FOR", "IF", "GOTO",
		"IMPLEMENTS", "IMPORT", "INSTANCEOF", "INT", "INTERFACE", "LONG", "NATIVE",
		"NEW", "PACKAGE", "PRIVATE", "PROTECTED", "PUBLIC", "RETURN", "SHORT",
		"STATIC", "STRICTFP", "SUPER", "SWITCH", "SYNCHRONIZED", "THIS", "THROW",
		"THROWS", "TRANSIENT", "TRY", "VOID", "VOLATILE", "WHILE", "MODULE",
		"OPEN", "REQUIRES", "EXPORTS", "OPENS", "TO", "USES", "PROVIDES", "WITH",
		"TRANSITIVE", "VAR", "YIELD", "RECORD", "SEALED", "PERMITS", "NON_SEALED",
		"DECIMAL_LITERAL", "HEX_LITERAL", "OCT_LITERAL", "BINARY_LITERAL", "FLOAT_LITERAL",
		"HEX_FLOAT_LITERAL", "BOOL_LITERAL", "CHAR_LITERAL", "STRING_LITERAL",
		"TEXT_BLOCK", "NULL_LITERAL", "LPAREN", "RPAREN", "LBRACE", "RBRACE",
		"LBRACK", "RBRACK", "SEMI", "COMMA", "DOT", "ASSIGN", "GT", "LT", "BANG",
		"TILDE", "QUESTION", "COLON", "EQUAL", "LE", "GE", "NOTEQUAL", "AND",
		"OR", "INC", "DEC", "ADD", "SUB", "MUL", "DIV", "BITAND", "BITOR", "CARET",
		"MOD", "ADD_ASSIGN", "SUB_ASSIGN", "MUL_ASSIGN", "DIV_ASSIGN", "AND_ASSIGN",
		"OR_ASSIGN", "XOR_ASSIGN", "MOD_ASSIGN", "LSHIFT_ASSIGN", "RSHIFT_ASSIGN",
		"URSHIFT_ASSIGN", "ARROW", "COLONCOLON", "AT", "ELLIPSIS", "WS", "COMMENT",
		"LINE_COMMENT", "IDENTIFIER",
	}
	staticData.RuleNames = []string{
		"compilationUnit", "packageDeclaration", "importDeclaration", "typeDeclaration",
		"modifier", "classOrInterfaceModifier", "variableModifier", "classDeclaration",
		"typeParameters", "typeParameter", "typeBound", "enumDeclaration", "enumConstants",
		"enumConstant", "enumBodyDeclarations", "interfaceDeclaration", "classBody",
		"interfaceBody", "classBodyDeclaration", "memberDeclaration", "methodDeclaration",
		"methodBody", "typeTypeOrVoid", "genericMethodDeclaration", "genericConstructorDeclaration",
		"constructorDeclaration", "compactConstructorDeclaration", "fieldDeclaration",
		"interfaceBodyDeclaration", "interfaceMemberDeclaration", "constDeclaration",
		"constantDeclarator", "interfaceMethodDeclaration", "interfaceMethodModifier",
		"genericInterfaceMethodDeclaration", "interfaceCommonBodyDeclaration",
		"variableDeclarators", "variableDeclarator", "variableDeclaratorId",
		"variableInitializer", "arrayInitializer", "classOrInterfaceType", "typeArgument",
		"qualifiedNameList", "formalParameters", "receiverParameter", "formalParameterList",
		"formalParameter", "lastFormalParameter", "lambdaLVTIList", "lambdaLVTIParameter",
		"qualifiedName", "literal", "integerLiteral", "floatLiteral", "altAnnotationQualifiedName",
		"annotation", "elementValuePairs", "elementValuePair", "elementValue",
		"elementValueArrayInitializer", "annotationTypeDeclaration", "annotationTypeBody",
		"annotationTypeElementDeclaration", "annotationTypeElementRest", "annotationMethodOrConstantRest",
		"annotationMethodRest", "annotationConstantRest", "defaultValue", "moduleDeclaration",
		"moduleBody", "moduleDirective", "requiresModifier", "recordDeclaration",
		"recordHeader", "recordComponentList", "recordComponent", "recordBody",
		"block", "blockStatement", "localVariableDeclaration", "identifier",
		"typeIdentifier", "localTypeDeclaration", "statement", "catchClause",
		"catchType", "finallyBlock", "resourceSpecification", "resources", "resource",
		"switchBlockStatementGroup", "switchLabel", "forControl", "forInit",
		"enhancedForControl", "parExpression", "expressionList", "methodCall",
		"expression", "pattern", "lambdaExpression", "lambdaParameters", "lambdaBody",
		"primary", "switchExpression", "switchLabeledRule", "guardedPattern",
		"switchRuleOutcome", "classType", "creator", "createdName", "innerCreator",
		"arrayCreatorRest", "classCreatorRest", "explicitGenericInvocation",
		"typeArgumentsOrDiamond", "nonWildcardTypeArgumentsOrDiamond", "nonWildcardTypeArguments",
		"typeList", "typeType", "primitiveType", "typeArguments", "superSuffix",
		"explicitGenericInvocationSuffix", "arguments",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 128, 1755, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 1, 0, 3, 0,
		254, 8, 0, 1, 0, 1, 0, 5, 0, 258, 8, 0, 10, 0, 12, 0, 261, 9, 0, 1, 0,
		1, 0, 5, 0, 265, 8, 0, 10, 0, 12, 0, 268, 9, 0, 1, 0, 1, 0, 1, 0, 3, 0,
		273, 8, 0, 1, 1, 5, 1, 276, 8, 1, 10, 1, 12, 1, 279, 9, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 2, 1, 2, 3, 2, 287, 8, 2, 1, 2, 1, 2, 1, 2, 3, 2, 292, 8,
		2, 1, 2, 1, 2, 1, 3, 5, 3, 297, 8, 3, 10, 3, 12, 3, 300, 9, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 3, 3, 307, 8, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3,
		4, 314, 8, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 3, 5, 326, 8, 5, 1, 6, 1, 6, 3, 6, 330, 8, 6, 1, 7, 1, 7, 1, 7, 3, 7,
		335, 8, 7, 1, 7, 1, 7, 3, 7, 339, 8, 7, 1, 7, 1, 7, 3, 7, 343, 8, 7, 1,
		7, 1, 7, 3, 7, 347, 8, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 8, 5, 8, 355,
		8, 8, 10, 8, 12, 8, 358, 9, 8, 1, 8, 1, 8, 1, 9, 5, 9, 363, 8, 9, 10, 9,
		12, 9, 366, 9, 9, 1, 9, 1, 9, 1, 9, 5, 9, 371, 8, 9, 10, 9, 12, 9, 374,
		9, 9, 1, 9, 3, 9, 377, 8, 9, 1, 10, 1, 10, 1, 10, 5, 10, 382, 8, 10, 10,
		10, 12, 10, 385, 9, 10, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 391, 8, 11,
		1, 11, 1, 11, 3, 11, 395, 8, 11, 1, 11, 3, 11, 398, 8, 11, 1, 11, 3, 11,
		401, 8, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 5, 12, 408, 8, 12, 10, 12,
		12, 12, 411, 9, 12, 1, 13, 5, 13, 414, 8, 13, 10, 13, 12, 13, 417, 9, 13,
		1, 13, 1, 13, 3, 13, 421, 8, 13, 1, 13, 3, 13, 424, 8, 13, 1, 14, 1, 14,
		5, 14, 428, 8, 14, 10, 14, 12, 14, 431, 9, 14, 1, 15, 1, 15, 1, 15, 3,
		15, 436, 8, 15, 1, 15, 1, 15, 3, 15, 440, 8, 15, 1, 15, 1, 15, 3, 15, 444,
		8, 15, 1, 15, 1, 15, 1, 16, 1, 16, 5, 16, 450, 8, 16, 10, 16, 12, 16, 453,
		9, 16, 1, 16, 1, 16, 1, 17, 1, 17, 5, 17, 459, 8, 17, 10, 17, 12, 17, 462,
		9, 17, 1, 17, 1, 17, 1, 18, 1, 18, 3, 18, 468, 8, 18, 1, 18, 1, 18, 5,
		18, 472, 8, 18, 10, 18, 12, 18, 475, 9, 18, 1, 18, 3, 18, 478, 8, 18, 1,
		19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19,
		490, 8, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 5, 20, 497, 8, 20, 10, 20,
		12, 20, 500, 9, 20, 1, 20, 1, 20, 3, 20, 504, 8, 20, 1, 20, 1, 20, 1, 21,
		1, 21, 3, 21, 510, 8, 21, 1, 22, 1, 22, 3, 22, 514, 8, 22, 1, 23, 1, 23,
		1, 23, 1, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 526, 8,
		25, 1, 25, 1, 25, 1, 26, 5, 26, 531, 8, 26, 10, 26, 12, 26, 534, 9, 26,
		1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 28, 5, 28, 544, 8,
		28, 10, 28, 12, 28, 547, 9, 28, 1, 28, 1, 28, 3, 28, 551, 8, 28, 1, 29,
		1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 561, 8, 29, 1,
		30, 1, 30, 1, 30, 1, 30, 5, 30, 567, 8, 30, 10, 30, 12, 30, 570, 9, 30,
		1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 5, 31, 577, 8, 31, 10, 31, 12, 31, 580,
		9, 31, 1, 31, 1, 31, 1, 31, 1, 32, 5, 32, 586, 8, 32, 10, 32, 12, 32, 589,
		9, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 599,
		8, 33, 1, 34, 5, 34, 602, 8, 34, 10, 34, 12, 34, 605, 9, 34, 1, 34, 1,
		34, 1, 34, 1, 35, 5, 35, 611, 8, 35, 10, 35, 12, 35, 614, 9, 35, 1, 35,
		1, 35, 1, 35, 1, 35, 1, 35, 5, 35, 621, 8, 35, 10, 35, 12, 35, 624, 9,
		35, 1, 35, 1, 35, 3, 35, 628, 8, 35, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36,
		5, 36, 635, 8, 36, 10, 36, 12, 36, 638, 9, 36, 1, 37, 1, 37, 1, 37, 3,
		37, 643, 8, 37, 1, 38, 1, 38, 1, 38, 5, 38, 648, 8, 38, 10, 38, 12, 38,
		651, 9, 38, 1, 39, 1, 39, 3, 39, 655, 8, 39, 1, 40, 1, 40, 1, 40, 1, 40,
		5, 40, 661, 8, 40, 10, 40, 12, 40, 664, 9, 40, 1, 40, 3, 40, 667, 8, 40,
		3, 40, 669, 8, 40, 1, 40, 1, 40, 1, 41, 1, 41, 3, 41, 675, 8, 41, 1, 41,
		1, 41, 5, 41, 679, 8, 41, 10, 41, 12, 41, 682, 9, 41, 1, 41, 1, 41, 3,
		41, 686, 8, 41, 1, 42, 1, 42, 5, 42, 690, 8, 42, 10, 42, 12, 42, 693, 9,
		42, 1, 42, 1, 42, 1, 42, 3, 42, 698, 8, 42, 3, 42, 700, 8, 42, 1, 43, 1,
		43, 1, 43, 5, 43, 705, 8, 43, 10, 43, 12, 43, 708, 9, 43, 1, 44, 1, 44,
		3, 44, 712, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 717, 8, 44, 1, 44, 3, 44,
		720, 8, 44, 3, 44, 722, 8, 44, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 1, 45,
		5, 45, 730, 8, 45, 10, 45, 12, 45, 733, 9, 45, 1, 45, 1, 45, 1, 46, 1,
		46, 1, 46, 5, 46, 740, 8, 46, 10, 46, 12, 46, 743, 9, 46, 1, 46, 1, 46,
		3, 46, 747, 8, 46, 1, 46, 3, 46, 750, 8, 46, 1, 47, 5, 47, 753, 8, 47,
		10, 47, 12, 47, 756, 9, 47, 1, 47, 1, 47, 1, 47, 1, 48, 5, 48, 762, 8,
		48, 10, 48, 12, 48, 765, 9, 48, 1, 48, 1, 48, 5, 48, 769, 8, 48, 10, 48,
		12, 48, 772, 9, 48, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49, 5, 49, 780,
		8, 49, 10, 49, 12, 49, 783, 9, 49, 1, 50, 5, 50, 786, 8, 50, 10, 50, 12,
		50, 789, 9, 50, 1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 1, 51, 5, 51, 797, 8,
		51, 10, 51, 12, 51, 800, 9, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52,
		1, 52, 3, 52, 809, 8, 52, 1, 53, 1, 53, 1, 54, 1, 54, 1, 55, 1, 55, 1,
		55, 5, 55, 818, 8, 55, 10, 55, 12, 55, 821, 9, 55, 1, 55, 1, 55, 1, 55,
		1, 56, 1, 56, 1, 56, 3, 56, 829, 8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 834,
		8, 56, 1, 56, 3, 56, 837, 8, 56, 1, 57, 1, 57, 1, 57, 5, 57, 842, 8, 57,
		10, 57, 12, 57, 845, 9, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 59, 1, 59, 1,
		59, 3, 59, 854, 8, 59, 1, 60, 1, 60, 1, 60, 1, 60, 5, 60, 860, 8, 60, 10,
		60, 12, 60, 863, 9, 60, 3, 60, 865, 8, 60, 1, 60, 3, 60, 868, 8, 60, 1,
		60, 1, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 62, 1, 62, 5, 62, 879,
		8, 62, 10, 62, 12, 62, 882, 9, 62, 1, 62, 1, 62, 1, 63, 5, 63, 887, 8,
		63, 10, 63, 12, 63, 890, 9, 63, 1, 63, 1, 63, 3, 63, 894, 8, 63, 1, 64,
		1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 902, 8, 64, 1, 64, 1, 64, 3,
		64, 906, 8, 64, 1, 64, 1, 64, 3, 64, 910, 8, 64, 1, 64, 1, 64, 3, 64, 914,
		8, 64, 1, 64, 1, 64, 3, 64, 918, 8, 64, 3, 64, 920, 8, 64, 1, 65, 1, 65,
		3, 65, 924, 8, 65, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 930, 8, 66, 1, 67,
		1, 67, 1, 68, 1, 68, 1, 68, 1, 69, 3, 69, 938, 8, 69, 1, 69, 1, 69, 1,
		69, 1, 69, 1, 70, 1, 70, 5, 70, 946, 8, 70, 10, 70, 12, 70, 949, 9, 70,
		1, 70, 1, 70, 1, 71, 1, 71, 5, 71, 955, 8, 71, 10, 71, 12, 71, 958, 9,
		71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 967, 8, 71,
		1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 975, 8, 71, 1, 71, 1,
		71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71,
		3, 71, 989, 8, 71, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 3, 73, 996, 8, 73,
		1, 73, 1, 73, 1, 73, 3, 73, 1001, 8, 73, 1, 73, 1, 73, 1, 74, 1, 74, 3,
		74, 1007, 8, 74, 1, 74, 1, 74, 1, 75, 1, 75, 1, 75, 5, 75, 1014, 8, 75,
		10, 75, 12, 75, 1017, 9, 75, 1, 76, 1, 76, 1, 76, 1, 77, 1, 77, 1, 77,
		5, 77, 1025, 8, 77, 10, 77, 12, 77, 1028, 9, 77, 1, 77, 1, 77, 1, 78, 1,
		78, 5, 78, 1034, 8, 78, 10, 78, 12, 78, 1037, 9, 78, 1, 78, 1, 78, 1, 79,
		1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 1046, 8, 79, 1, 80, 5, 80, 1049, 8,
		80, 10, 80, 12, 80, 1052, 9, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1,
		80, 1, 80, 1, 80, 3, 80, 1062, 8, 80, 1, 81, 1, 81, 1, 82, 1, 82, 1, 83,
		5, 83, 1069, 8, 83, 10, 83, 12, 83, 1072, 9, 83, 1, 83, 1, 83, 1, 83, 3,
		83, 1077, 8, 83, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 1084, 8, 84,
		1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 1093, 8, 84, 1,
		84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84,
		1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 4, 84, 1114, 8,
		84, 11, 84, 12, 84, 1115, 1, 84, 3, 84, 1119, 8, 84, 1, 84, 3, 84, 1122,
		8, 84, 1, 84, 1, 84, 1, 84, 1, 84, 5, 84, 1128, 8, 84, 10, 84, 12, 84,
		1131, 9, 84, 1, 84, 3, 84, 1134, 8, 84, 1, 84, 1, 84, 1, 84, 1, 84, 5,
		84, 1140, 8, 84, 10, 84, 12, 84, 1143, 9, 84, 1, 84, 5, 84, 1146, 8, 84,
		10, 84, 12, 84, 1149, 9, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84,
		1, 84, 1, 84, 3, 84, 1159, 8, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1,
		84, 1, 84, 3, 84, 1168, 8, 84, 1, 84, 1, 84, 1, 84, 3, 84, 1173, 8, 84,
		1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1,
		84, 3, 84, 1186, 8, 84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 1192, 8, 84,
		1, 85, 1, 85, 1, 85, 5, 85, 1197, 8, 85, 10, 85, 12, 85, 1200, 9, 85, 1,
		85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 86, 1, 86, 1, 86, 5, 86, 1210, 8, 86,
		10, 86, 12, 86, 1213, 9, 86, 1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88,
		3, 88, 1221, 8, 88, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 5, 89, 1228, 8,
		89, 10, 89, 12, 89, 1231, 9, 89, 1, 90, 5, 90, 1234, 8, 90, 10, 90, 12,
		90, 1237, 9, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 3, 90, 1244, 8, 90,
		1, 90, 1, 90, 1, 90, 1, 90, 3, 90, 1250, 8, 90, 1, 91, 4, 91, 1253, 8,
		91, 11, 91, 12, 91, 1254, 1, 91, 4, 91, 1258, 8, 91, 11, 91, 12, 91, 1259,
		1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1268, 8, 92, 1, 92, 1,
		92, 1, 92, 3, 92, 1273, 8, 92, 1, 93, 1, 93, 3, 93, 1277, 8, 93, 1, 93,
		1, 93, 3, 93, 1281, 8, 93, 1, 93, 1, 93, 3, 93, 1285, 8, 93, 3, 93, 1287,
		8, 93, 1, 94, 1, 94, 3, 94, 1291, 8, 94, 1, 95, 5, 95, 1294, 8, 95, 10,
		95, 12, 95, 1297, 9, 95, 1, 95, 1, 95, 3, 95, 1301, 8, 95, 1, 95, 1, 95,
		1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 1, 96, 1, 97, 1, 97, 1, 97, 5, 97, 1314,
		8, 97, 10, 97, 12, 97, 1317, 9, 97, 1, 98, 1, 98, 1, 98, 3, 98, 1322, 8,
		98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 3, 99, 1332,
		8, 99, 1, 99, 1, 99, 3, 99, 1336, 8, 99, 1, 99, 1, 99, 1, 99, 3, 99, 1341,
		8, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 5, 99, 1350, 8,
		99, 10, 99, 12, 99, 1353, 9, 99, 1, 99, 1, 99, 1, 99, 5, 99, 1358, 8, 99,
		10, 99, 12, 99, 1361, 9, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99,
		3, 99, 1369, 8, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1,
		99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 3, 99, 1385, 8, 99, 1, 99,
		1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1,
		99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99,
		1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1,
		99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99,
		3, 99, 1430, 8, 99, 1, 99, 1, 99, 1, 99, 1, 99, 3, 99, 1436, 8, 99, 1,
		99, 1, 99, 1, 99, 3, 99, 1441, 8, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99,
		1, 99, 1, 99, 3, 99, 1450, 8, 99, 5, 99, 1452, 8, 99, 10, 99, 12, 99, 1455,
		9, 99, 1, 100, 5, 100, 1458, 8, 100, 10, 100, 12, 100, 1461, 9, 100, 1,
		100, 1, 100, 5, 100, 1465, 8, 100, 10, 100, 12, 100, 1468, 9, 100, 1, 100,
		1, 100, 1, 101, 1, 101, 1, 101, 1, 101, 1, 102, 1, 102, 1, 102, 3, 102,
		1479, 8, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 5, 102, 1486, 8,
		102, 10, 102, 12, 102, 1489, 9, 102, 1, 102, 1, 102, 1, 102, 1, 102, 3,
		102, 1495, 8, 102, 1, 102, 3, 102, 1498, 8, 102, 1, 103, 1, 103, 3, 103,
		1502, 8, 103, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1,
		104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 3,
		104, 1520, 8, 104, 3, 104, 1522, 8, 104, 1, 105, 1, 105, 1, 105, 1, 105,
		5, 105, 1528, 8, 105, 10, 105, 12, 105, 1531, 9, 105, 1, 105, 1, 105, 1,
		106, 1, 106, 1, 106, 1, 106, 3, 106, 1539, 8, 106, 1, 106, 1, 106, 1, 106,
		1, 106, 1, 106, 3, 106, 1546, 8, 106, 1, 107, 1, 107, 1, 107, 1, 107, 1,
		107, 1, 107, 5, 107, 1554, 8, 107, 10, 107, 12, 107, 1557, 9, 107, 1, 107,
		1, 107, 5, 107, 1561, 8, 107, 10, 107, 12, 107, 1564, 9, 107, 1, 107, 1,
		107, 1, 107, 5, 107, 1569, 8, 107, 10, 107, 12, 107, 1572, 9, 107, 3, 107,
		1574, 8, 107, 1, 107, 1, 107, 1, 107, 5, 107, 1579, 8, 107, 10, 107, 12,
		107, 1582, 9, 107, 1, 108, 1, 108, 5, 108, 1586, 8, 108, 10, 108, 12, 108,
		1589, 9, 108, 3, 108, 1591, 8, 108, 1, 109, 1, 109, 1, 109, 3, 109, 1596,
		8, 109, 1, 109, 5, 109, 1599, 8, 109, 10, 109, 12, 109, 1602, 9, 109, 1,
		109, 1, 109, 3, 109, 1606, 8, 109, 1, 110, 3, 110, 1609, 8, 110, 1, 110,
		1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 3, 110, 1617, 8, 110, 1, 111, 1,
		111, 3, 111, 1621, 8, 111, 1, 111, 1, 111, 1, 111, 3, 111, 1626, 8, 111,
		5, 111, 1628, 8, 111, 10, 111, 12, 111, 1631, 9, 111, 1, 111, 3, 111, 1634,
		8, 111, 1, 112, 1, 112, 3, 112, 1638, 8, 112, 1, 112, 1, 112, 1, 113, 1,
		113, 4, 113, 1644, 8, 113, 11, 113, 12, 113, 1645, 1, 113, 1, 113, 1, 113,
		1, 113, 1, 113, 4, 113, 1653, 8, 113, 11, 113, 12, 113, 1654, 1, 113, 1,
		113, 5, 113, 1659, 8, 113, 10, 113, 12, 113, 1662, 9, 113, 3, 113, 1664,
		8, 113, 1, 114, 1, 114, 3, 114, 1668, 8, 114, 1, 115, 1, 115, 1, 115, 1,
		116, 1, 116, 1, 116, 3, 116, 1676, 8, 116, 1, 117, 1, 117, 1, 117, 3, 117,
		1681, 8, 117, 1, 118, 1, 118, 1, 118, 1, 118, 1, 119, 1, 119, 1, 119, 5,
		119, 1690, 8, 119, 10, 119, 12, 119, 1693, 9, 119, 1, 120, 5, 120, 1696,
		8, 120, 10, 120, 12, 120, 1699, 9, 120, 1, 120, 1, 120, 3, 120, 1703, 8,
		120, 1, 120, 5, 120, 1706, 8, 120, 10, 120, 12, 120, 1709, 9, 120, 1, 120,
		1, 120, 5, 120, 1713, 8, 120, 10, 120, 12, 120, 1716, 9, 120, 1, 121, 1,
		121, 1, 122, 1, 122, 1, 122, 1, 122, 5, 122, 1724, 8, 122, 10, 122, 12,
		122, 1727, 9, 122, 1, 122, 1, 122, 1, 123, 1, 123, 1, 123, 3, 123, 1734,
		8, 123, 1, 123, 1, 123, 3, 123, 1738, 8, 123, 3, 123, 1740, 8, 123, 1,
		124, 1, 124, 1, 124, 1, 124, 1, 124, 3, 124, 1747, 8, 124, 1, 125, 1, 125,
		3, 125, 1751, 8, 125, 1, 125, 1, 125, 1, 125, 0, 2, 198, 214, 126, 0, 2,
		4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40,
		42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76,
		78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110,
		112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140,
		142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170,
		172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200,
		202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230,
		232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 0, 15, 2, 0, 17, 17,
		40, 40, 1, 0, 67, 70, 1, 0, 71, 72, 2, 0, 38, 38, 60, 60, 2, 0, 51, 65,
		128, 128, 3, 0, 51, 60, 63, 65, 128, 128, 2, 0, 90, 91, 100, 103, 2, 0,
		104, 105, 109, 109, 1, 0, 102, 103, 2, 0, 88, 89, 95, 96, 2, 0, 94, 94,
		97, 97, 2, 0, 87, 87, 110, 120, 1, 0, 100, 101, 2, 0, 93, 93, 121, 121,
		8, 0, 3, 3, 5, 5, 8, 8, 14, 14, 20, 20, 27, 27, 29, 29, 37, 37, 1951, 0,
		272, 1, 0, 0, 0, 2, 277, 1, 0, 0, 0, 4, 284, 1, 0, 0, 0, 6, 298, 1, 0,
		0, 0, 8, 313, 1, 0, 0, 0, 10, 325, 1, 0, 0, 0, 12, 329, 1, 0, 0, 0, 14,
		331, 1, 0, 0, 0, 16, 350, 1, 0, 0, 0, 18, 364, 1, 0, 0, 0, 20, 378, 1,
		0, 0, 0, 22, 386, 1, 0, 0, 0, 24, 404, 1, 0, 0, 0, 26, 415, 1, 0, 0, 0,
		28, 425, 1, 0, 0, 0, 30, 432, 1, 0, 0, 0, 32, 447, 1, 0, 0, 0, 34, 456,
		1, 0, 0, 0, 36, 477, 1, 0, 0, 0, 38, 489, 1, 0, 0, 0, 40, 491, 1, 0, 0,
		0, 42, 509, 1, 0, 0, 0, 44, 513, 1, 0, 0, 0, 46, 515, 1, 0, 0, 0, 48, 518,
		1, 0, 0, 0, 50, 521, 1, 0, 0, 0, 52, 532, 1, 0, 0, 0, 54, 538, 1, 0, 0,
		0, 56, 550, 1, 0, 0, 0, 58, 560, 1, 0, 0, 0, 60, 562, 1, 0, 0, 0, 62, 573,
		1, 0, 0, 0, 64, 587, 1, 0, 0, 0, 66, 598, 1, 0, 0, 0, 68, 603, 1, 0, 0,
		0, 70, 612, 1, 0, 0, 0, 72, 631, 1, 0, 0, 0, 74, 639, 1, 0, 0, 0, 76, 644,
		1, 0, 0, 0, 78, 654, 1, 0, 0, 0, 80, 656, 1, 0, 0, 0, 82, 680, 1, 0, 0,
		0, 84, 699, 1, 0, 0, 0, 86, 701, 1, 0, 0, 0, 88, 709, 1, 0, 0, 0, 90, 725,
		1, 0, 0, 0, 92, 749, 1, 0, 0, 0, 94, 754, 1, 0, 0, 0, 96, 763, 1, 0, 0,
		0, 98, 776, 1, 0, 0, 0, 100, 787, 1, 0, 0, 0, 102, 793, 1, 0, 0, 0, 104,
		808, 1, 0, 0, 0, 106, 810, 1, 0, 0, 0, 108, 812, 1, 0, 0, 0, 110, 819,
		1, 0, 0, 0, 112, 828, 1, 0, 0, 0, 114, 838, 1, 0, 0, 0, 116, 846, 1, 0,
		0, 0, 118, 853, 1, 0, 0, 0, 120, 855, 1, 0, 0, 0, 122, 871, 1, 0, 0, 0,
		124, 876, 1, 0, 0, 0, 126, 893, 1, 0, 0, 0, 128, 919, 1, 0, 0, 0, 130,
		923, 1, 0, 0, 0, 132, 925, 1, 0, 0, 0, 134, 931, 1, 0, 0, 0, 136, 933,
		1, 0, 0, 0, 138, 937, 1, 0, 0, 0, 140, 943, 1, 0, 0, 0, 142, 988, 1, 0,
		0, 0, 144, 990, 1, 0, 0, 0, 146, 992, 1, 0, 0, 0, 148, 1004, 1, 0, 0, 0,
		150, 1010, 1, 0, 0, 0, 152, 1018, 1, 0, 0, 0, 154, 1021, 1, 0, 0, 0, 156,
		1031, 1, 0, 0, 0, 158, 1045, 1, 0, 0, 0, 160, 1050, 1, 0, 0, 0, 162, 1063,
		1, 0, 0, 0, 164, 1065, 1, 0, 0, 0, 166, 1070, 1, 0, 0, 0, 168, 1191, 1,
		0, 0, 0, 170, 1193, 1, 0, 0, 0, 172, 1206, 1, 0, 0, 0, 174, 1214, 1, 0,
		0, 0, 176, 1217, 1, 0, 0, 0, 178, 1224, 1, 0, 0, 0, 180, 1249, 1, 0, 0,
		0, 182, 1252, 1, 0, 0, 0, 184, 1272, 1, 0, 0, 0, 186, 1286, 1, 0, 0, 0,
		188, 1290, 1, 0, 0, 0, 190, 1295, 1, 0, 0, 0, 192, 1306, 1, 0, 0, 0, 194,
		1310, 1, 0, 0, 0, 196, 1321, 1, 0, 0, 0, 198, 1368, 1, 0, 0, 0, 200, 1459,
		1, 0, 0, 0, 202, 1471, 1, 0, 0, 0, 204, 1497, 1, 0, 0, 0, 206, 1501, 1,
		0, 0, 0, 208, 1521, 1, 0, 0, 0, 210, 1523, 1, 0, 0, 0, 212, 1545, 1, 0,
		0, 0, 214, 1573, 1, 0, 0, 0, 216, 1590, 1, 0, 0, 0, 218, 1595, 1, 0, 0,
		0, 220, 1616, 1, 0, 0, 0, 222, 1633, 1, 0, 0, 0, 224, 1635, 1, 0, 0, 0,
		226, 1663, 1, 0, 0, 0, 228, 1665, 1, 0, 0, 0, 230, 1669, 1, 0, 0, 0, 232,
		1675, 1, 0, 0, 0, 234, 1680, 1, 0, 0, 0, 236, 1682, 1, 0, 0, 0, 238, 1686,
		1, 0, 0, 0, 240, 1697, 1, 0, 0, 0, 242, 1717, 1, 0, 0, 0, 244, 1719, 1,
		0, 0, 0, 246, 1739, 1, 0, 0, 0, 248, 1746, 1, 0, 0, 0, 250, 1748, 1, 0,
		0, 0, 252, 254, 3, 2, 1, 0, 253, 252, 1, 0, 0, 0, 253, 254, 1, 0, 0, 0,
		254, 259, 1, 0, 0, 0, 255, 258, 3, 4, 2, 0, 256, 258, 5, 84, 0, 0, 257,
		255, 1, 0, 0, 0, 257, 256, 1, 0, 0, 0, 258, 261, 1, 0, 0, 0, 259, 257,
		1, 0, 0, 0, 259, 260, 1, 0, 0, 0, 260, 266, 1, 0, 0, 0, 261, 259, 1, 0,
		0, 0, 262, 265, 3, 6, 3, 0, 263, 265, 5, 84, 0, 0, 264, 262, 1, 0, 0, 0,
		264, 263, 1, 0, 0, 0, 265, 268, 1, 0, 0, 0, 266, 264, 1, 0, 0, 0, 266,
		267, 1, 0, 0, 0, 267, 273, 1, 0, 0, 0, 268, 266, 1, 0, 0, 0, 269, 270,
		3, 138, 69, 0, 270, 271, 5, 0, 0, 1, 271, 273, 1, 0, 0, 0, 272, 253, 1,
		0, 0, 0, 272, 269, 1, 0, 0, 0, 273, 1, 1, 0, 0, 0, 274, 276, 3, 112, 56,
		0, 275, 274, 1, 0, 0, 0, 276, 279, 1, 0, 0, 0, 277, 275, 1, 0, 0, 0, 277,
		278, 1, 0, 0, 0, 278, 280, 1, 0, 0, 0, 279, 277, 1, 0, 0, 0, 280, 281,
		5, 32, 0, 0, 281, 282, 3, 102, 51, 0, 282, 283, 5, 84, 0, 0, 283, 3, 1,
		0, 0, 0, 284, 286, 5, 25, 0, 0, 285, 287, 5, 38, 0, 0, 286, 285, 1, 0,
		0, 0, 286, 287, 1, 0, 0, 0, 287, 288, 1, 0, 0, 0, 288, 291, 3, 102, 51,
		0, 289, 290, 5, 86, 0, 0, 290, 292, 5, 104, 0, 0, 291, 289, 1, 0, 0, 0,
		291, 292, 1, 0, 0, 0, 292, 293, 1, 0, 0, 0, 293, 294, 5, 84, 0, 0, 294,
		5, 1, 0, 0, 0, 295, 297, 3, 10, 5, 0, 296, 295, 1, 0, 0, 0, 297, 300, 1,
		0, 0, 0, 298, 296, 1, 0, 0, 0, 298, 299, 1, 0, 0, 0, 299, 306, 1, 0, 0,
		0, 300, 298, 1, 0, 0, 0, 301, 307, 3, 14, 7, 0, 302, 307, 3, 22, 11, 0,
		303, 307, 3, 30, 15, 0, 304, 307, 3, 122, 61, 0, 305, 307, 3, 146, 73,
		0, 306, 301, 1, 0, 0, 0, 306, 302, 1, 0, 0, 0, 306, 303, 1, 0, 0, 0, 306,
		304, 1, 0, 0, 0, 306, 305, 1, 0, 0, 0, 307, 7, 1, 0, 0, 0, 308, 314, 3,
		10, 5, 0, 309, 314, 5, 30, 0, 0, 310, 314, 5, 42, 0, 0, 311, 314, 5, 46,
		0, 0, 312, 314, 5, 49, 0, 0, 313, 308, 1, 0, 0, 0, 313, 309, 1, 0, 0, 0,
		313, 310, 1, 0, 0, 0, 313, 311, 1, 0, 0, 0, 313, 312, 1, 0, 0, 0, 314,
		9, 1, 0, 0, 0, 315, 326, 3, 112, 56, 0, 316, 326, 5, 35, 0, 0, 317, 326,
		5, 34, 0, 0, 318, 326, 5, 33, 0, 0, 319, 326, 5, 38, 0, 0, 320, 326, 5,
		1, 0, 0, 321, 326, 5, 18, 0, 0, 322, 326, 5, 39, 0, 0, 323, 326, 5, 64,
		0, 0, 324, 326, 5, 66, 0, 0, 325, 315, 1, 0, 0, 0, 325, 316, 1, 0, 0, 0,
		325, 317, 1, 0, 0, 0, 325, 318, 1, 0, 0, 0, 325, 319, 1, 0, 0, 0, 325,
		320, 1, 0, 0, 0, 325, 321, 1, 0, 0, 0, 325, 322, 1, 0, 0, 0, 325, 323,
		1, 0, 0, 0, 325, 324, 1, 0, 0, 0, 326, 11, 1, 0, 0, 0, 327, 330, 5, 18,
		0, 0, 328, 330, 3, 112, 56, 0, 329, 327, 1, 0, 0, 0, 329, 328, 1, 0, 0,
		0, 330, 13, 1, 0, 0, 0, 331, 332, 5, 9, 0, 0, 332, 334, 3, 162, 81, 0,
		333, 335, 3, 16, 8, 0, 334, 333, 1, 0, 0, 0, 334, 335, 1, 0, 0, 0, 335,
		338, 1, 0, 0, 0, 336, 337, 5, 17, 0, 0, 337, 339, 3, 240, 120, 0, 338,
		336, 1, 0, 0, 0, 338, 339, 1, 0, 0, 0, 339, 342, 1, 0, 0, 0, 340, 341,
		5, 24, 0, 0, 341, 343, 3, 238, 119, 0, 342, 340, 1, 0, 0, 0, 342, 343,
		1, 0, 0, 0, 343, 346, 1, 0, 0, 0, 344, 345, 5, 65, 0, 0, 345, 347, 3, 238,
		119, 0, 346, 344, 1, 0, 0, 0, 346, 347, 1, 0, 0, 0, 347, 348, 1, 0, 0,
		0, 348, 349, 3, 32, 16, 0, 349, 15, 1, 0, 0, 0, 350, 351, 5, 89, 0, 0,
		351, 356, 3, 18, 9, 0, 352, 353, 5, 85, 0, 0, 353, 355, 3, 18, 9, 0, 354,
		352, 1, 0, 0, 0, 355, 358, 1, 0, 0, 0, 356, 354, 1, 0, 0, 0, 356, 357,
		1, 0, 0, 0, 357, 359, 1, 0, 0, 0, 358, 356, 1, 0, 0, 0, 359, 360, 5, 88,
		0, 0, 360, 17, 1, 0, 0, 0, 361, 363, 3, 112, 56, 0, 362, 361, 1, 0, 0,
		0, 363, 366, 1, 0, 0, 0, 364, 362, 1, 0, 0, 0, 364, 365, 1, 0, 0, 0, 365,
		367, 1, 0, 0, 0, 366, 364, 1, 0, 0, 0, 367, 376, 3, 162, 81, 0, 368, 372,
		5, 17, 0, 0, 369, 371, 3, 112, 56, 0, 370, 369, 1, 0, 0, 0, 371, 374, 1,
		0, 0, 0, 372, 370, 1, 0, 0, 0, 372, 373, 1, 0, 0, 0, 373, 375, 1, 0, 0,
		0, 374, 372, 1, 0, 0, 0, 375, 377, 3, 20, 10, 0, 376, 368, 1, 0, 0, 0,
		376, 377, 1, 0, 0, 0, 377, 19, 1, 0, 0, 0, 378, 383, 3, 240, 120, 0, 379,
		380, 5, 106, 0, 0, 380, 382, 3, 240, 120, 0, 381, 379, 1, 0, 0, 0, 382,
		385, 1, 0, 0, 0, 383, 381, 1, 0, 0, 0, 383, 384, 1, 0, 0, 0, 384, 21, 1,
		0, 0, 0, 385, 383, 1, 0, 0, 0, 386, 387, 5, 16, 0, 0, 387, 390, 3, 162,
		81, 0, 388, 389, 5, 24, 0, 0, 389, 391, 3, 238, 119, 0, 390, 388, 1, 0,
		0, 0, 390, 391, 1, 0, 0, 0, 391, 392, 1, 0, 0, 0, 392, 394, 5, 80, 0, 0,
		393, 395, 3, 24, 12, 0, 394, 393, 1, 0, 0, 0, 394, 395, 1, 0, 0, 0, 395,
		397, 1, 0, 0, 0, 396, 398, 5, 85, 0, 0, 397, 396, 1, 0, 0, 0, 397, 398,
		1, 0, 0, 0, 398, 400, 1, 0, 0, 0, 399, 401, 3, 28, 14, 0, 400, 399, 1,
		0, 0, 0, 400, 401, 1, 0, 0, 0, 401, 402, 1, 0, 0, 0, 402, 403, 5, 81, 0,
		0, 403, 23, 1, 0, 0, 0, 404, 409, 3, 26, 13, 0, 405, 406, 5, 85, 0, 0,
		406, 408, 3, 26, 13, 0, 407, 405, 1, 0, 0, 0, 408, 411, 1, 0, 0, 0, 409,
		407, 1, 0, 0, 0, 409, 410, 1, 0, 0, 0, 410, 25, 1, 0, 0, 0, 411, 409, 1,
		0, 0, 0, 412, 414, 3, 112, 56, 0, 413, 412, 1, 0, 0, 0, 414, 417, 1, 0,
		0, 0, 415, 413, 1, 0, 0, 0, 415, 416, 1, 0, 0, 0, 416, 418, 1, 0, 0, 0,
		417, 415, 1, 0, 0, 0, 418, 420, 3, 162, 81, 0, 419, 421, 3, 250, 125, 0,
		420, 419, 1, 0, 0, 0, 420, 421, 1, 0, 0, 0, 421, 423, 1, 0, 0, 0, 422,
		424, 3, 32, 16, 0, 423, 422, 1, 0, 0, 0, 423, 424, 1, 0, 0, 0, 424, 27,
		1, 0, 0, 0, 425, 429, 5, 84, 0, 0, 426, 428, 3, 36, 18, 0, 427, 426, 1,
		0, 0, 0, 428, 431, 1, 0, 0, 0, 429, 427, 1, 0, 0, 0, 429, 430, 1, 0, 0,
		0, 430, 29, 1, 0, 0, 0, 431, 429, 1, 0, 0, 0, 432, 433, 5, 28, 0, 0, 433,
		435, 3, 162, 81, 0, 434, 436, 3, 16, 8, 0, 435, 434, 1, 0, 0, 0, 435, 436,
		1, 0, 0, 0, 436, 439, 1, 0, 0, 0, 437, 438, 5, 17, 0, 0, 438, 440, 3, 238,
		119, 0, 439, 437, 1, 0, 0, 0, 439, 440, 1, 0, 0, 0, 440, 443, 1, 0, 0,
		0, 441, 442, 5, 65, 0, 0, 442, 444, 3, 238, 119, 0, 443, 441, 1, 0, 0,
		0, 443, 444, 1, 0, 0, 0, 444, 445, 1, 0, 0, 0, 445, 446, 3, 34, 17, 0,
		446, 31, 1, 0, 0, 0, 447, 451, 5, 80, 0, 0, 448, 450, 3, 36, 18, 0, 449,
		448, 1, 0, 0, 0, 450, 453, 1, 0, 0, 0, 451, 449, 1, 0, 0, 0, 451, 452,
		1, 0, 0, 0, 452, 454, 1, 0, 0, 0, 453, 451, 1, 0, 0, 0, 454, 455, 5, 81,
		0, 0, 455, 33, 1, 0, 0, 0, 456, 460, 5, 80, 0, 0, 457, 459, 3, 56, 28,
		0, 458, 457, 1, 0, 0, 0, 459, 462, 1, 0, 0, 0, 460, 458, 1, 0, 0, 0, 460,
		461, 1, 0, 0, 0, 461, 463, 1, 0, 0, 0, 462, 460, 1, 0, 0, 0, 463, 464,
		5, 81, 0, 0, 464, 35, 1, 0, 0, 0, 465, 478, 5, 84, 0, 0, 466, 468, 5, 38,
		0, 0, 467, 466, 1, 0, 0, 0, 467, 468, 1, 0, 0, 0, 468, 469, 1, 0, 0, 0,
		469, 478, 3, 156, 78, 0, 470, 472, 3, 8, 4, 0, 471, 470, 1, 0, 0, 0, 472,
		475, 1, 0, 0, 0, 473, 471, 1, 0, 0, 0, 473, 474, 1, 0, 0, 0, 474, 476,
		1, 0, 0, 0, 475, 473, 1, 0, 0, 0, 476, 478, 3, 38, 19, 0, 477, 465, 1,
		0, 0, 0, 477, 467, 1, 0, 0, 0, 477, 473, 1, 0, 0, 0, 478, 37, 1, 0, 0,
		0, 479, 490, 3, 146, 73, 0, 480, 490, 3, 40, 20, 0, 481, 490, 3, 46, 23,
		0, 482, 490, 3, 54, 27, 0, 483, 490, 3, 50, 25, 0, 484, 490, 3, 48, 24,
		0, 485, 490, 3, 30, 15, 0, 486, 490, 3, 122, 61, 0, 487, 490, 3, 14, 7,
		0, 488, 490, 3, 22, 11, 0, 489, 479, 1, 0, 0, 0, 489, 480, 1, 0, 0, 0,
		489, 481, 1, 0, 0, 0, 489, 482, 1, 0, 0, 0, 489, 483, 1, 0, 0, 0, 489,
		484, 1, 0, 0, 0, 489, 485, 1, 0, 0, 0, 489, 486, 1, 0, 0, 0, 489, 487,
		1, 0, 0, 0, 489, 488, 1, 0, 0, 0, 490, 39, 1, 0, 0, 0, 491, 492, 3, 44,
		22, 0, 492, 493, 3, 162, 81, 0, 493, 498, 3, 88, 44, 0, 494, 495, 5, 82,
		0, 0, 495, 497, 5, 83, 0, 0, 496, 494, 1, 0, 0, 0, 497, 500, 1, 0, 0, 0,
		498, 496, 1, 0, 0, 0, 498, 499, 1, 0, 0, 0, 499, 503, 1, 0, 0, 0, 500,
		498, 1, 0, 0, 0, 501, 502, 5, 45, 0, 0, 502, 504, 3, 86, 43, 0, 503, 501,
		1, 0, 0, 0, 503, 504, 1, 0, 0, 0, 504, 505, 1, 0, 0, 0, 505, 506, 3, 42,
		21, 0, 506, 41, 1, 0, 0, 0, 507, 510, 3, 156, 78, 0, 508, 510, 5, 84, 0,
		0, 509, 507, 1, 0, 0, 0, 509, 508, 1, 0, 0, 0, 510, 43, 1, 0, 0, 0, 511,
		514, 3, 240, 120, 0, 512, 514, 5, 48, 0, 0, 513, 511, 1, 0, 0, 0, 513,
		512, 1, 0, 0, 0, 514, 45, 1, 0, 0, 0, 515, 516, 3, 16, 8, 0, 516, 517,
		3, 40, 20, 0, 517, 47, 1, 0, 0, 0, 518, 519, 3, 16, 8, 0, 519, 520, 3,
		50, 25, 0, 520, 49, 1, 0, 0, 0, 521, 522, 3, 162, 81, 0, 522, 525, 3, 88,
		44, 0, 523, 524, 5, 45, 0, 0, 524, 526, 3, 86, 43, 0, 525, 523, 1, 0, 0,
		0, 525, 526, 1, 0, 0, 0, 526, 527, 1, 0, 0, 0, 527, 528, 3, 156, 78, 0,
		528, 51, 1, 0, 0, 0, 529, 531, 3, 8, 4, 0, 530, 529, 1, 0, 0, 0, 531, 534,
		1, 0, 0, 0, 532, 530, 1, 0, 0, 0, 532, 533, 1, 0, 0, 0, 533, 535, 1, 0,
		0, 0, 534, 532, 1, 0, 0, 0, 535, 536, 3, 162, 81, 0, 536, 537, 3, 156,
		78, 0, 537, 53, 1, 0, 0, 0, 538, 539, 3, 240, 120, 0, 539, 540, 3, 72,
		36, 0, 540, 541, 5, 84, 0, 0, 541, 55, 1, 0, 0, 0, 542, 544, 3, 8, 4, 0,
		543, 542, 1, 0, 0, 0, 544, 547, 1, 0, 0, 0, 545, 543, 1, 0, 0, 0, 545,
		546, 1, 0, 0, 0, 546, 548, 1, 0, 0, 0, 547, 545, 1, 0, 0, 0, 548, 551,
		3, 58, 29, 0, 549, 551, 5, 84, 0, 0, 550, 545, 1, 0, 0, 0, 550, 549, 1,
		0, 0, 0, 551, 57, 1, 0, 0, 0, 552, 561, 3, 146, 73, 0, 553, 561, 3, 60,
		30, 0, 554, 561, 3, 64, 32, 0, 555, 561, 3, 68, 34, 0, 556, 561, 3, 30,
		15, 0, 557, 561, 3, 122, 61, 0, 558, 561, 3, 14, 7, 0, 559, 561, 3, 22,
		11, 0, 560, 552, 1, 0, 0, 0, 560, 553, 1, 0, 0, 0, 560, 554, 1, 0, 0, 0,
		560, 555, 1, 0, 0, 0, 560, 556, 1, 0, 0, 0, 560, 557, 1, 0, 0, 0, 560,
		558, 1, 0, 0, 0, 560, 559, 1, 0, 0, 0, 561, 59, 1, 0, 0, 0, 562, 563, 3,
		240, 120, 0, 563, 568, 3, 62, 31, 0, 564, 565, 5, 85, 0, 0, 565, 567, 3,
		62, 31, 0, 566, 564, 1, 0, 0, 0, 567, 570, 1, 0, 0, 0, 568, 566, 1, 0,
		0, 0, 568, 569, 1, 0, 0, 0, 569, 571, 1, 0, 0, 0, 570, 568, 1, 0, 0, 0,
		571, 572, 5, 84, 0, 0, 572, 61, 1, 0, 0, 0, 573, 578, 3, 162, 81, 0, 574,
		575, 5, 82, 0, 0, 575, 577, 5, 83, 0, 0, 576, 574, 1, 0, 0, 0, 577, 580,
		1, 0, 0, 0, 578, 576, 1, 0, 0, 0, 578, 579, 1, 0, 0, 0, 579, 581, 1, 0,
		0, 0, 580, 578, 1, 0, 0, 0, 581, 582, 5, 87, 0, 0, 582, 583, 3, 78, 39,
		0, 583, 63, 1, 0, 0, 0, 584, 586, 3, 66, 33, 0, 585, 584, 1, 0, 0, 0, 586,
		589, 1, 0, 0, 0, 587, 585, 1, 0, 0, 0, 587, 588, 1, 0, 0, 0, 588, 590,
		1, 0, 0, 0, 589, 587, 1, 0, 0, 0, 590, 591, 3, 70, 35, 0, 591, 65, 1, 0,
		0, 0, 592, 599, 3, 112, 56, 0, 593, 599, 5, 35, 0, 0, 594, 599, 5, 1, 0,
		0, 595, 599, 5, 12, 0, 0, 596, 599, 5, 38, 0, 0, 597, 599, 5, 39, 0, 0,
		598, 592, 1, 0, 0, 0, 598, 593, 1, 0, 0, 0, 598, 594, 1, 0, 0, 0, 598,
		595, 1, 0, 0, 0, 598, 596, 1, 0, 0, 0, 598, 597, 1, 0, 0, 0, 599, 67, 1,
		0, 0, 0, 600, 602, 3, 66, 33, 0, 601, 600, 1, 0, 0, 0, 602, 605, 1, 0,
		0, 0, 603, 601, 1, 0, 0, 0, 603, 604, 1, 0, 0, 0, 604, 606, 1, 0, 0, 0,
		605, 603, 1, 0, 0, 0, 606, 607, 3, 16, 8, 0, 607, 608, 3, 70, 35, 0, 608,
		69, 1, 0, 0, 0, 609, 611, 3, 112, 56, 0, 610, 609, 1, 0, 0, 0, 611, 614,
		1, 0, 0, 0, 612, 610, 1, 0, 0, 0, 612, 613, 1, 0, 0, 0, 613, 615, 1, 0,
		0, 0, 614, 612, 1, 0, 0, 0, 615, 616, 3, 44, 22, 0, 616, 617, 3, 162, 81,
		0, 617, 622, 3, 88, 44, 0, 618, 619, 5, 82, 0, 0, 619, 621, 5, 83, 0, 0,
		620, 618, 1, 0, 0, 0, 621, 624, 1, 0, 0, 0, 622, 620, 1, 0, 0, 0, 622,
		623, 1, 0, 0, 0, 623, 627, 1, 0, 0, 0, 624, 622, 1, 0, 0, 0, 625, 626,
		5, 45, 0, 0, 626, 628, 3, 86, 43, 0, 627, 625, 1, 0, 0, 0, 627, 628, 1,
		0, 0, 0, 628, 629, 1, 0, 0, 0, 629, 630, 3, 42, 21, 0, 630, 71, 1, 0, 0,
		0, 631, 636, 3, 74, 37, 0, 632, 633, 5, 85, 0, 0, 633, 635, 3, 74, 37,
		0, 634, 632, 1, 0, 0, 0, 635, 638, 1, 0, 0, 0, 636, 634, 1, 0, 0, 0, 636,
		637, 1, 0, 0, 0, 637, 73, 1, 0, 0, 0, 638, 636, 1, 0, 0, 0, 639, 642, 3,
		76, 38, 0, 640, 641, 5, 87, 0, 0, 641, 643, 3, 78, 39, 0, 642, 640, 1,
		0, 0, 0, 642, 643, 1, 0, 0, 0, 643, 75, 1, 0, 0, 0, 644, 649, 3, 162, 81,
		0, 645, 646, 5, 82, 0, 0, 646, 648, 5, 83, 0, 0, 647, 645, 1, 0, 0, 0,
		648, 651, 1, 0, 0, 0, 649, 647, 1, 0, 0, 0, 649, 650, 1, 0, 0, 0, 650,
		77, 1, 0, 0, 0, 651, 649, 1, 0, 0, 0, 652, 655, 3, 80, 40, 0, 653, 655,
		3, 198, 99, 0, 654, 652, 1, 0, 0, 0, 654, 653, 1, 0, 0, 0, 655, 79, 1,
		0, 0, 0, 656, 668, 5, 80, 0, 0, 657, 662, 3, 78, 39, 0, 658, 659, 5, 85,
		0, 0, 659, 661, 3, 78, 39, 0, 660, 658, 1, 0, 0, 0, 661, 664, 1, 0, 0,
		0, 662, 660, 1, 0, 0, 0, 662, 663, 1, 0, 0, 0, 663, 666, 1, 0, 0, 0, 664,
		662, 1, 0, 0, 0, 665, 667, 5, 85, 0, 0, 666, 665, 1, 0, 0, 0, 666, 667,
		1, 0, 0, 0, 667, 669, 1, 0, 0, 0, 668, 657, 1, 0, 0, 0, 668, 669, 1, 0,
		0, 0, 669, 670, 1, 0, 0, 0, 670, 671, 5, 81, 0, 0, 671, 81, 1, 0, 0, 0,
		672, 674, 3, 162, 81, 0, 673, 675, 3, 244, 122, 0, 674, 673, 1, 0, 0, 0,
		674, 675, 1, 0, 0, 0, 675, 676, 1, 0, 0, 0, 676, 677, 5, 86, 0, 0, 677,
		679, 1, 0, 0, 0, 678, 672, 1, 0, 0, 0, 679, 682, 1, 0, 0, 0, 680, 678,
		1, 0, 0, 0, 680, 681, 1, 0, 0, 0, 681, 683, 1, 0, 0, 0, 682, 680, 1, 0,
		0, 0, 683, 685, 3, 164, 82, 0, 684, 686, 3, 244, 122, 0, 685, 684, 1, 0,
		0, 0, 685, 686, 1, 0, 0, 0, 686, 83, 1, 0, 0, 0, 687, 700, 3, 240, 120,
		0, 688, 690, 3, 112, 56, 0, 689, 688, 1, 0, 0, 0, 690, 693, 1, 0, 0, 0,
		691, 689, 1, 0, 0, 0, 691, 692, 1, 0, 0, 0, 692, 694, 1, 0, 0, 0, 693,
		691, 1, 0, 0, 0, 694, 697, 5, 92, 0, 0, 695, 696, 7, 0, 0, 0, 696, 698,
		3, 240, 120, 0, 697, 695, 1, 0, 0, 0, 697, 698, 1, 0, 0, 0, 698, 700, 1,
		0, 0, 0, 699, 687, 1, 0, 0, 0, 699, 691, 1, 0, 0, 0, 700, 85, 1, 0, 0,
		0, 701, 706, 3, 102, 51, 0, 702, 703, 5, 85, 0, 0, 703, 705, 3, 102, 51,
		0, 704, 702, 1, 0, 0, 0, 705, 708, 1, 0, 0, 0, 706, 704, 1, 0, 0, 0, 706,
		707, 1, 0, 0, 0, 707, 87, 1, 0, 0, 0, 708, 706, 1, 0, 0, 0, 709, 721, 5,
		78, 0, 0, 710, 712, 3, 90, 45, 0, 711, 710, 1, 0, 0, 0, 711, 712, 1, 0,
		0, 0, 712, 722, 1, 0, 0, 0, 713, 716, 3, 90, 45, 0, 714, 715, 5, 85, 0,
		0, 715, 717, 3, 92, 46, 0, 716, 714, 1, 0, 0, 0, 716, 717, 1, 0, 0, 0,
		717, 722, 1, 0, 0, 0, 718, 720, 3, 92, 46, 0, 719, 718, 1, 0, 0, 0, 719,
		720, 1, 0, 0, 0, 720, 722, 1, 0, 0, 0, 721, 711, 1, 0, 0, 0, 721, 713,
		1, 0, 0, 0, 721, 719, 1, 0, 0, 0, 722, 723, 1, 0, 0, 0, 723, 724, 5, 79,
		0, 0, 724, 89, 1, 0, 0, 0, 725, 731, 3, 240, 120, 0, 726, 727, 3, 162,
		81, 0, 727, 728, 5, 86, 0, 0, 728, 730, 1, 0, 0, 0, 729, 726, 1, 0, 0,
		0, 730, 733, 1, 0, 0, 0, 731, 729, 1, 0, 0, 0, 731, 732, 1, 0, 0, 0, 732,
		734, 1, 0, 0, 0, 733, 731, 1, 0, 0, 0, 734, 735, 5, 43, 0, 0, 735, 91,
		1, 0, 0, 0, 736, 741, 3, 94, 47, 0, 737, 738, 5, 85, 0, 0, 738, 740, 3,
		94, 47, 0, 739, 737, 1, 0, 0, 0, 740, 743, 1, 0, 0, 0, 741, 739, 1, 0,
		0, 0, 741, 742, 1, 0, 0, 0, 742, 746, 1, 0, 0, 0, 743, 741, 1, 0, 0, 0,
		744, 745, 5, 85, 0, 0, 745, 747, 3, 96, 48, 0, 746, 744, 1, 0, 0, 0, 746,
		747, 1, 0, 0, 0, 747, 750, 1, 0, 0, 0, 748, 750, 3, 96, 48, 0, 749, 736,
		1, 0, 0, 0, 749, 748, 1, 0, 0, 0, 750, 93, 1, 0, 0, 0, 751, 753, 3, 12,
		6, 0, 752, 751, 1, 0, 0, 0, 753, 756, 1, 0, 0, 0, 754, 752, 1, 0, 0, 0,
		754, 755, 1, 0, 0, 0, 755, 757, 1, 0, 0, 0, 756, 754, 1, 0, 0, 0, 757,
		758, 3, 240, 120, 0, 758, 759, 3, 76, 38, 0, 759, 95, 1, 0, 0, 0, 760,
		762, 3, 12, 6, 0, 761, 760, 1, 0, 0, 0, 762, 765, 1, 0, 0, 0, 763, 761,
		1, 0, 0, 0, 763, 764, 1, 0, 0, 0, 764, 766, 1, 0, 0, 0, 765, 763, 1, 0,
		0, 0, 766, 770, 3, 240, 120, 0, 767, 769, 3, 112, 56, 0, 768, 767, 1, 0,
		0, 0, 769, 772, 1, 0, 0, 0, 770, 768, 1, 0, 0, 0, 770, 771, 1, 0, 0, 0,
		771, 773, 1, 0, 0, 0, 772, 770, 1, 0, 0, 0, 773, 774, 5, 124, 0, 0, 774,
		775, 3, 76, 38, 0, 775, 97, 1, 0, 0, 0, 776, 781, 3, 100, 50, 0, 777, 778,
		5, 85, 0, 0, 778, 780, 3, 100, 50, 0, 779, 777, 1, 0, 0, 0, 780, 783, 1,
		0, 0, 0, 781, 779, 1, 0, 0, 0, 781, 782, 1, 0, 0, 0, 782, 99, 1, 0, 0,
		0, 783, 781, 1, 0, 0, 0, 784, 786, 3, 12, 6, 0, 785, 784, 1, 0, 0, 0, 786,
		789, 1, 0, 0, 0, 787, 785, 1, 0, 0, 0, 787, 788, 1, 0, 0, 0, 788, 790,
		1, 0, 0, 0, 789, 787, 1, 0, 0, 0, 790, 791, 5, 61, 0, 0, 791, 792, 3, 162,
		81, 0, 792, 101, 1, 0, 0, 0, 793, 798, 3, 162, 81, 0, 794, 795, 5, 86,
		0, 0, 795, 797, 3, 162, 81, 0, 796, 794, 1, 0, 0, 0, 797, 800, 1, 0, 0,
		0, 798, 796, 1, 0, 0, 0, 798, 799, 1, 0, 0, 0, 799, 103, 1, 0, 0, 0, 800,
		798, 1, 0, 0, 0, 801, 809, 3, 106, 53, 0, 802, 809, 3, 108, 54, 0, 803,
		809, 5, 74, 0, 0, 804, 809, 5, 75, 0, 0, 805, 809, 5, 73, 0, 0, 806, 809,
		5, 77, 0, 0, 807, 809, 5, 76, 0, 0, 808, 801, 1, 0, 0, 0, 808, 802, 1,
		0, 0, 0, 808, 803, 1, 0, 0, 0, 808, 804, 1, 0, 0, 0, 808, 805, 1, 0, 0,
		0, 808, 806, 1, 0, 0, 0, 808, 807, 1, 0, 0, 0, 809, 105, 1, 0, 0, 0, 810,
		811, 7, 1, 0, 0, 811, 107, 1, 0, 0, 0, 812, 813, 7, 2, 0, 0, 813, 109,
		1, 0, 0, 0, 814, 815, 3, 162, 81, 0, 815, 816, 5, 86, 0, 0, 816, 818, 1,
		0, 0, 0, 817, 814, 1, 0, 0, 0, 818, 821, 1, 0, 0, 0, 819, 817, 1, 0, 0,
		0, 819, 820, 1, 0, 0, 0, 820, 822, 1, 0, 0, 0, 821, 819, 1, 0, 0, 0, 822,
		823, 5, 123, 0, 0, 823, 824, 3, 162, 81, 0, 824, 111, 1, 0, 0, 0, 825,
		826, 5, 123, 0, 0, 826, 829, 3, 102, 51, 0, 827, 829, 3, 110, 55, 0, 828,
		825, 1, 0, 0, 0, 828, 827, 1, 0, 0, 0, 829, 836, 1, 0, 0, 0, 830, 833,
		5, 78, 0, 0, 831, 834, 3, 114, 57, 0, 832, 834, 3, 118, 59, 0, 833, 831,
		1, 0, 0, 0, 833, 832, 1, 0, 0, 0, 833, 834, 1, 0, 0, 0, 834, 835, 1, 0,
		0, 0, 835, 837, 5, 79, 0, 0, 836, 830, 1, 0, 0, 0, 836, 837, 1, 0, 0, 0,
		837, 113, 1, 0, 0, 0, 838, 843, 3, 116, 58, 0, 839, 840, 5, 85, 0, 0, 840,
		842, 3, 116, 58, 0, 841, 839, 1, 0, 0, 0, 842, 845, 1, 0, 0, 0, 843, 841,
		1, 0, 0, 0, 843, 844, 1, 0, 0, 0, 844, 115, 1, 0, 0, 0, 845, 843, 1, 0,
		0, 0, 846, 847, 3, 162, 81, 0, 847, 848, 5, 87, 0, 0, 848, 849, 3, 118,
		59, 0, 849, 117, 1, 0, 0, 0, 850, 854, 3, 198, 99, 0, 851, 854, 3, 112,
		56, 0, 852, 854, 3, 120, 60, 0, 853, 850, 1, 0, 0, 0, 853, 851, 1, 0, 0,
		0, 853, 852, 1, 0, 0, 0, 854, 119, 1, 0, 0, 0, 855, 864, 5, 80, 0, 0, 856,
		861, 3, 118, 59, 0, 857, 858, 5, 85, 0, 0, 858, 860, 3, 118, 59, 0, 859,
		857, 1, 0, 0, 0, 860, 863, 1, 0, 0, 0, 861, 859, 1, 0, 0, 0, 861, 862,
		1, 0, 0, 0, 862, 865, 1, 0, 0, 0, 863, 861, 1, 0, 0, 0, 864, 856, 1, 0,
		0, 0, 864, 865, 1, 0, 0, 0, 865, 867, 1, 0, 0, 0, 866, 868, 5, 85, 0, 0,
		867, 866, 1, 0, 0, 0, 867, 868, 1, 0, 0, 0, 868, 869, 1, 0, 0, 0, 869,
		870, 5, 81, 0, 0, 870, 121, 1, 0, 0, 0, 871, 872, 5, 123, 0, 0, 872, 873,
		5, 28, 0, 0, 873, 874, 3, 162, 81, 0, 874, 875, 3, 124, 62, 0, 875, 123,
		1, 0, 0, 0, 876, 880, 5, 80, 0, 0, 877, 879, 3, 126, 63, 0, 878, 877, 1,
		0, 0, 0, 879, 882, 1, 0, 0, 0, 880, 878, 1, 0, 0, 0, 880, 881, 1, 0, 0,
		0, 881, 883, 1, 0, 0, 0, 882, 880, 1, 0, 0, 0, 883, 884, 5, 81, 0, 0, 884,
		125, 1, 0, 0, 0, 885, 887, 3, 8, 4, 0, 886, 885, 1, 0, 0, 0, 887, 890,
		1, 0, 0, 0, 888, 886, 1, 0, 0, 0, 888, 889, 1, 0, 0, 0, 889, 891, 1, 0,
		0, 0, 890, 888, 1, 0, 0, 0, 891, 894, 3, 128, 64, 0, 892, 894, 5, 84, 0,
		0, 893, 888, 1, 0, 0, 0, 893, 892, 1, 0, 0, 0, 894, 127, 1, 0, 0, 0, 895,
		896, 3, 240, 120, 0, 896, 897, 3, 130, 65, 0, 897, 898, 5, 84, 0, 0, 898,
		920, 1, 0, 0, 0, 899, 901, 3, 14, 7, 0, 900, 902, 5, 84, 0, 0, 901, 900,
		1, 0, 0, 0, 901, 902, 1, 0, 0, 0, 902, 920, 1, 0, 0, 0, 903, 905, 3, 30,
		15, 0, 904, 906, 5, 84, 0, 0, 905, 904, 1, 0, 0, 0, 905, 906, 1, 0, 0,
		0, 906, 920, 1, 0, 0, 0, 907, 909, 3, 22, 11, 0, 908, 910, 5, 84, 0, 0,
		909, 908, 1, 0, 0, 0, 909, 910, 1, 0, 0, 0, 910, 920, 1, 0, 0, 0, 911,
		913, 3, 122, 61, 0, 912, 914, 5, 84, 0, 0, 913, 912, 1, 0, 0, 0, 913, 914,
		1, 0, 0, 0, 914, 920, 1, 0, 0, 0, 915, 917, 3, 146, 73, 0, 916, 918, 5,
		84, 0, 0, 917, 916, 1, 0, 0, 0, 917, 918, 1, 0, 0, 0, 918, 920, 1, 0, 0,
		0, 919, 895, 1, 0, 0, 0, 919, 899, 1, 0, 0, 0, 919, 903, 1, 0, 0, 0, 919,
		907, 1, 0, 0, 0, 919, 911, 1, 0, 0, 0, 919, 915, 1, 0, 0, 0, 920, 129,
		1, 0, 0, 0, 921, 924, 3, 132, 66, 0, 922, 924, 3, 134, 67, 0, 923, 921,
		1, 0, 0, 0, 923, 922, 1, 0, 0, 0, 924, 131, 1, 0, 0, 0, 925, 926, 3, 162,
		81, 0, 926, 927, 5, 78, 0, 0, 927, 929, 5, 79, 0, 0, 928, 930, 3, 136,
		68, 0, 929, 928, 1, 0, 0, 0, 929, 930, 1, 0, 0, 0, 930, 133, 1, 0, 0, 0,
		931, 932, 3, 72, 36, 0, 932, 135, 1, 0, 0, 0, 933, 934, 5, 12, 0, 0, 934,
		935, 3, 118, 59, 0, 935, 137, 1, 0, 0, 0, 936, 938, 5, 52, 0, 0, 937, 936,
		1, 0, 0, 0, 937, 938, 1, 0, 0, 0, 938, 939, 1, 0, 0, 0, 939, 940, 5, 51,
		0, 0, 940, 941, 3, 102, 51, 0, 941, 942, 3, 140, 70, 0, 942, 139, 1, 0,
		0, 0, 943, 947, 5, 80, 0, 0, 944, 946, 3, 142, 71, 0, 945, 944, 1, 0, 0,
		0, 946, 949, 1, 0, 0, 0, 947, 945, 1, 0, 0, 0, 947, 948, 1, 0, 0, 0, 948,
		950, 1, 0, 0, 0, 949, 947, 1, 0, 0, 0, 950, 951, 5, 81, 0, 0, 951, 141,
		1, 0, 0, 0, 952, 956, 5, 53, 0, 0, 953, 955, 3, 144, 72, 0, 954, 953, 1,
		0, 0, 0, 955, 958, 1, 0, 0, 0, 956, 954, 1, 0, 0, 0, 956, 957, 1, 0, 0,
		0, 957, 959, 1, 0, 0, 0, 958, 956, 1, 0, 0, 0, 959, 960, 3, 102, 51, 0,
		960, 961, 5, 84, 0, 0, 961, 989, 1, 0, 0, 0, 962, 963, 5, 54, 0, 0, 963,
		966, 3, 102, 51, 0, 964, 965, 5, 56, 0, 0, 965, 967, 3, 102, 51, 0, 966,
		964, 1, 0, 0, 0, 966, 967, 1, 0, 0, 0, 967, 968, 1, 0, 0, 0, 968, 969,
		5, 84, 0, 0, 969, 989, 1, 0, 0, 0, 970, 971, 5, 55, 0, 0, 971, 974, 3,
		102, 51, 0, 972, 973, 5, 56, 0, 0, 973, 975, 3, 102, 51, 0, 974, 972, 1,
		0, 0, 0, 974, 975, 1, 0, 0, 0, 975, 976, 1, 0, 0, 0, 976, 977, 5, 84, 0,
		0, 977, 989, 1, 0, 0, 0, 978, 979, 5, 57, 0, 0, 979, 980, 3, 102, 51, 0,
		980, 981, 5, 84, 0, 0, 981, 989, 1, 0, 0, 0, 982, 983, 5, 58, 0, 0, 983,
		984, 3, 102, 51, 0, 984, 985, 5, 59, 0, 0, 985, 986, 3, 102, 51, 0, 986,
		987, 5, 84, 0, 0, 987, 989, 1, 0, 0, 0, 988, 952, 1, 0, 0, 0, 988, 962,
		1, 0, 0, 0, 988, 970, 1, 0, 0, 0, 988, 978, 1, 0, 0, 0, 988, 982, 1, 0,
		0, 0, 989, 143, 1, 0, 0, 0, 990, 991, 7, 3, 0, 0, 991, 145, 1, 0, 0, 0,
		992, 993, 5, 63, 0, 0, 993, 995, 3, 162, 81, 0, 994, 996, 3, 16, 8, 0,
		995, 994, 1, 0, 0, 0, 995, 996, 1, 0, 0, 0, 996, 997, 1, 0, 0, 0, 997,
		1000, 3, 148, 74, 0, 998, 999, 5, 24, 0, 0, 999, 1001, 3, 238, 119, 0,
		1000, 998, 1, 0, 0, 0, 1000, 1001, 1, 0, 0, 0, 1001, 1002, 1, 0, 0, 0,
		1002, 1003, 3, 154, 77, 0, 1003, 147, 1, 0, 0, 0, 1004, 1006, 5, 78, 0,
		0, 1005, 1007, 3, 150, 75, 0, 1006, 1005, 1, 0, 0, 0, 1006, 1007, 1, 0,
		0, 0, 1007, 1008, 1, 0, 0, 0, 1008, 1009, 5, 79, 0, 0, 1009, 149, 1, 0,
		0, 0, 1010, 1015, 3, 152, 76, 0, 1011, 1012, 5, 85, 0, 0, 1012, 1014, 3,
		152, 76, 0, 1013, 1011, 1, 0, 0, 0, 1014, 1017, 1, 0, 0, 0, 1015, 1013,
		1, 0, 0, 0, 1015, 1016, 1, 0, 0, 0, 1016, 151, 1, 0, 0, 0, 1017, 1015,
		1, 0, 0, 0, 1018, 1019, 3, 240, 120, 0, 1019, 1020, 3, 162, 81, 0, 1020,
		153, 1, 0, 0, 0, 1021, 1026, 5, 80, 0, 0, 1022, 1025, 3, 36, 18, 0, 1023,
		1025, 3, 52, 26, 0, 1024, 1022, 1, 0, 0, 0, 1024, 1023, 1, 0, 0, 0, 1025,
		1028, 1, 0, 0, 0, 1026, 1024, 1, 0, 0, 0, 1026, 1027, 1, 0, 0, 0, 1027,
		1029, 1, 0, 0, 0, 1028, 1026, 1, 0, 0, 0, 1029, 1030, 5, 81, 0, 0, 1030,
		155, 1, 0, 0, 0, 1031, 1035, 5, 80, 0, 0, 1032, 1034, 3, 158, 79, 0, 1033,
		1032, 1, 0, 0, 0, 1034, 1037, 1, 0, 0, 0, 1035, 1033, 1, 0, 0, 0, 1035,
		1036, 1, 0, 0, 0, 1036, 1038, 1, 0, 0, 0, 1037, 1035, 1, 0, 0, 0, 1038,
		1039, 5, 81, 0, 0, 1039, 157, 1, 0, 0, 0, 1040, 1041, 3, 160, 80, 0, 1041,
		1042, 5, 84, 0, 0, 1042, 1046, 1, 0, 0, 0, 1043, 1046, 3, 166, 83, 0, 1044,
		1046, 3, 168, 84, 0, 1045, 1040, 1, 0, 0, 0, 1045, 1043, 1, 0, 0, 0, 1045,
		1044, 1, 0, 0, 0, 1046, 159, 1, 0, 0, 0, 1047, 1049, 3, 12, 6, 0, 1048,
		1047, 1, 0, 0, 0, 1049, 1052, 1, 0, 0, 0, 1050, 1048, 1, 0, 0, 0, 1050,
		1051, 1, 0, 0, 0, 1051, 1061, 1, 0, 0, 0, 1052, 1050, 1, 0, 0, 0, 1053,
		1054, 5, 61, 0, 0, 1054, 1055, 3, 162, 81, 0, 1055, 1056, 5, 87, 0, 0,
		1056, 1057, 3, 198, 99, 0, 1057, 1062, 1, 0, 0, 0, 1058, 1059, 3, 240,
		120, 0, 1059, 1060, 3, 72, 36, 0, 1060, 1062, 1, 0, 0, 0, 1061, 1053, 1,
		0, 0, 0, 1061, 1058, 1, 0, 0, 0, 1062, 161, 1, 0, 0, 0, 1063, 1064, 7,
		4, 0, 0, 1064, 163, 1, 0, 0, 0, 1065, 1066, 7, 5, 0, 0, 1066, 165, 1, 0,
		0, 0, 1067, 1069, 3, 10, 5, 0, 1068, 1067, 1, 0, 0, 0, 1069, 1072, 1, 0,
		0, 0, 1070, 1068, 1, 0, 0, 0, 1070, 1071, 1, 0, 0, 0, 1071, 1076, 1, 0,
		0, 0, 1072, 1070, 1, 0, 0, 0, 1073, 1077, 3, 14, 7, 0, 1074, 1077, 3, 30,
		15, 0, 1075, 1077, 3, 146, 73, 0, 1076, 1073, 1, 0, 0, 0, 1076, 1074, 1,
		0, 0, 0, 1076, 1075, 1, 0, 0, 0, 1077, 167, 1, 0, 0, 0, 1078, 1192, 3,
		156, 78, 0, 1079, 1080, 5, 2, 0, 0, 1080, 1083, 3, 198, 99, 0, 1081, 1082,
		5, 93, 0, 0, 1082, 1084, 3, 198, 99, 0, 1083, 1081, 1, 0, 0, 0, 1083, 1084,
		1, 0, 0, 0, 1084, 1085, 1, 0, 0, 0, 1085, 1086, 5, 84, 0, 0, 1086, 1192,
		1, 0, 0, 0, 1087, 1088, 5, 22, 0, 0, 1088, 1089, 3, 192, 96, 0, 1089, 1092,
		3, 168, 84, 0, 1090, 1091, 5, 15, 0, 0, 1091, 1093, 3, 168, 84, 0, 1092,
		1090, 1, 0, 0, 0, 1092, 1093, 1, 0, 0, 0, 1093, 1192, 1, 0, 0, 0, 1094,
		1095, 5, 21, 0, 0, 1095, 1096, 5, 78, 0, 0, 1096, 1097, 3, 186, 93, 0,
		1097, 1098, 5, 79, 0, 0, 1098, 1099, 3, 168, 84, 0, 1099, 1192, 1, 0, 0,
		0, 1100, 1101, 5, 50, 0, 0, 1101, 1102, 3, 192, 96, 0, 1102, 1103, 3, 168,
		84, 0, 1103, 1192, 1, 0, 0, 0, 1104, 1105, 5, 13, 0, 0, 1105, 1106, 3,
		168, 84, 0, 1106, 1107, 5, 50, 0, 0, 1107, 1108, 3, 192, 96, 0, 1108, 1109,
		5, 84, 0, 0, 1109, 1192, 1, 0, 0, 0, 1110, 1111, 5, 47, 0, 0, 1111, 1121,
		3, 156, 78, 0, 1112, 1114, 3, 170, 85, 0, 1113, 1112, 1, 0, 0, 0, 1114,
		1115, 1, 0, 0, 0, 1115, 1113, 1, 0, 0, 0, 1115, 1116, 1, 0, 0, 0, 1116,
		1118, 1, 0, 0, 0, 1117, 1119, 3, 174, 87, 0, 1118, 1117, 1, 0, 0, 0, 1118,
		1119, 1, 0, 0, 0, 1119, 1122, 1, 0, 0, 0, 1120, 1122, 3, 174, 87, 0, 1121,
		1113, 1, 0, 0, 0, 1121, 1120, 1, 0, 0, 0, 1122, 1192, 1, 0, 0, 0, 1123,
		1124, 5, 47, 0, 0, 1124, 1125, 3, 176, 88, 0, 1125, 1129, 3, 156, 78, 0,
		1126, 1128, 3, 170, 85, 0, 1127, 1126, 1, 0, 0, 0, 1128, 1131, 1, 0, 0,
		0, 1129, 1127, 1, 0, 0, 0, 1129, 1130, 1, 0, 0, 0, 1130, 1133, 1, 0, 0,
		0, 1131, 1129, 1, 0, 0, 0, 1132, 1134, 3, 174, 87, 0, 1133, 1132, 1, 0,
		0, 0, 1133, 1134, 1, 0, 0, 0, 1134, 1192, 1, 0, 0, 0, 1135, 1136, 5, 41,
		0, 0, 1136, 1137, 3, 192, 96, 0, 1137, 1141, 5, 80, 0, 0, 1138, 1140, 3,
		182, 91, 0, 1139, 1138, 1, 0, 0, 0, 1140, 1143, 1, 0, 0, 0, 1141, 1139,
		1, 0, 0, 0, 1141, 1142, 1, 0, 0, 0, 1142, 1147, 1, 0, 0, 0, 1143, 1141,
		1, 0, 0, 0, 1144, 1146, 3, 184, 92, 0, 1145, 1144, 1, 0, 0, 0, 1146, 1149,
		1, 0, 0, 0, 1147, 1145, 1, 0, 0, 0, 1147, 1148, 1, 0, 0, 0, 1148, 1150,
		1, 0, 0, 0, 1149, 1147, 1, 0, 0, 0, 1150, 1151, 5, 81, 0, 0, 1151, 1192,
		1, 0, 0, 0, 1152, 1153, 5, 42, 0, 0, 1153, 1154, 3, 192, 96, 0, 1154, 1155,
		3, 156, 78, 0, 1155, 1192, 1, 0, 0, 0, 1156, 1158, 5, 36, 0, 0, 1157, 1159,
		3, 198, 99, 0, 1158, 1157, 1, 0, 0, 0, 1158, 1159, 1, 0, 0, 0, 1159, 1160,
		1, 0, 0, 0, 1160, 1192, 5, 84, 0, 0, 1161, 1162, 5, 44, 0, 0, 1162, 1163,
		3, 198, 99, 0, 1163, 1164, 5, 84, 0, 0, 1164, 1192, 1, 0, 0, 0, 1165, 1167,
		5, 4, 0, 0, 1166, 1168, 3, 162, 81, 0, 1167, 1166, 1, 0, 0, 0, 1167, 1168,
		1, 0, 0, 0, 1168, 1169, 1, 0, 0, 0, 1169, 1192, 5, 84, 0, 0, 1170, 1172,
		5, 11, 0, 0, 1171, 1173, 3, 162, 81, 0, 1172, 1171, 1, 0, 0, 0, 1172, 1173,
		1, 0, 0, 0, 1173, 1174, 1, 0, 0, 0, 1174, 1192, 5, 84, 0, 0, 1175, 1176,
		5, 62, 0, 0, 1176, 1177, 3, 198, 99, 0, 1177, 1178, 5, 84, 0, 0, 1178,
		1192, 1, 0, 0, 0, 1179, 1192, 5, 84, 0, 0, 1180, 1181, 3, 198, 99, 0, 1181,
		1182, 5, 84, 0, 0, 1182, 1192, 1, 0, 0, 0, 1183, 1185, 3, 210, 105, 0,
		1184, 1186, 5, 84, 0, 0, 1185, 1184, 1, 0, 0, 0, 1185, 1186, 1, 0, 0, 0,
		1186, 1192, 1, 0, 0, 0, 1187, 1188, 3, 162, 81, 0, 1188, 1189, 5, 93, 0,
		0, 1189, 1190, 3, 168, 84, 0, 1190, 1192, 1, 0, 0, 0, 1191, 1078, 1, 0,
		0, 0, 1191, 1079, 1, 0, 0, 0, 1191, 1087, 1, 0, 0, 0, 1191, 1094, 1, 0,
		0, 0, 1191, 1100, 1, 0, 0, 0, 1191, 1104, 1, 0, 0, 0, 1191, 1110, 1, 0,
		0, 0, 1191, 1123, 1, 0, 0, 0, 1191, 1135, 1, 0, 0, 0, 1191, 1152, 1, 0,
		0, 0, 1191, 1156, 1, 0, 0, 0, 1191, 1161, 1, 0, 0, 0, 1191, 1165, 1, 0,
		0, 0, 1191, 1170, 1, 0, 0, 0, 1191, 1175, 1, 0, 0, 0, 1191, 1179, 1, 0,
		0, 0, 1191, 1180, 1, 0, 0, 0, 1191, 1183, 1, 0, 0, 0, 1191, 1187, 1, 0,
		0, 0, 1192, 169, 1, 0, 0, 0, 1193, 1194, 5, 7, 0, 0, 1194, 1198, 5, 78,
		0, 0, 1195, 1197, 3, 12, 6, 0, 1196, 1195, 1, 0, 0, 0, 1197, 1200, 1, 0,
		0, 0, 1198, 1196, 1, 0, 0, 0, 1198, 1199, 1, 0, 0, 0, 1199, 1201, 1, 0,
		0, 0, 1200, 1198, 1, 0, 0, 0, 1201, 1202, 3, 172, 86, 0, 1202, 1203, 3,
		162, 81, 0, 1203, 1204, 5, 79, 0, 0, 1204, 1205, 3, 156, 78, 0, 1205, 171,
		1, 0, 0, 0, 1206, 1211, 3, 102, 51, 0, 1207, 1208, 5, 107, 0, 0, 1208,
		1210, 3, 102, 51, 0, 1209, 1207, 1, 0, 0, 0, 1210, 1213, 1, 0, 0, 0, 1211,
		1209, 1, 0, 0, 0, 1211, 1212, 1, 0, 0, 0, 1212, 173, 1, 0, 0, 0, 1213,
		1211, 1, 0, 0, 0, 1214, 1215, 5, 19, 0, 0, 1215, 1216, 3, 156, 78, 0, 1216,
		175, 1, 0, 0, 0, 1217, 1218, 5, 78, 0, 0, 1218, 1220, 3, 178, 89, 0, 1219,
		1221, 5, 84, 0, 0, 1220, 1219, 1, 0, 0, 0, 1220, 1221, 1, 0, 0, 0, 1221,
		1222, 1, 0, 0, 0, 1222, 1223, 5, 79, 0, 0, 1223, 177, 1, 0, 0, 0, 1224,
		1229, 3, 180, 90, 0, 1225, 1226, 5, 84, 0, 0, 1226, 1228, 3, 180, 90, 0,
		1227, 1225, 1, 0, 0, 0, 1228, 1231, 1, 0, 0, 0, 1229, 1227, 1, 0, 0, 0,
		1229, 1230, 1, 0, 0, 0, 1230, 179, 1, 0, 0, 0, 1231, 1229, 1, 0, 0, 0,
		1232, 1234, 3, 12, 6, 0, 1233, 1232, 1, 0, 0, 0, 1234, 1237, 1, 0, 0, 0,
		1235, 1233, 1, 0, 0, 0, 1235, 1236, 1, 0, 0, 0, 1236, 1243, 1, 0, 0, 0,
		1237, 1235, 1, 0, 0, 0, 1238, 1239, 3, 82, 41, 0, 1239, 1240, 3, 76, 38,
		0, 1240, 1244, 1, 0, 0, 0, 1241, 1242, 5, 61, 0, 0, 1242, 1244, 3, 162,
		81, 0, 1243, 1238, 1, 0, 0, 0, 1243, 1241, 1, 0, 0, 0, 1244, 1245, 1, 0,
		0, 0, 1245, 1246, 5, 87, 0, 0, 1246, 1247, 3, 198, 99, 0, 1247, 1250, 1,
		0, 0, 0, 1248, 1250, 3, 102, 51, 0, 1249, 1235, 1, 0, 0, 0, 1249, 1248,
		1, 0, 0, 0, 1250, 181, 1, 0, 0, 0, 1251, 1253, 3, 184, 92, 0, 1252, 1251,
		1, 0, 0, 0, 1253, 1254, 1, 0, 0, 0, 1254, 1252, 1, 0, 0, 0, 1254, 1255,
		1, 0, 0, 0, 1255, 1257, 1, 0, 0, 0, 1256, 1258, 3, 158, 79, 0, 1257, 1256,
		1, 0, 0, 0, 1258, 1259, 1, 0, 0, 0, 1259, 1257, 1, 0, 0, 0, 1259, 1260,
		1, 0, 0, 0, 1260, 183, 1, 0, 0, 0, 1261, 1267, 5, 6, 0, 0, 1262, 1268,
		3, 198, 99, 0, 1263, 1268, 5, 128, 0, 0, 1264, 1265, 3, 240, 120, 0, 1265,
		1266, 3, 162, 81, 0, 1266, 1268, 1, 0, 0, 0, 1267, 1262, 1, 0, 0, 0, 1267,
		1263, 1, 0, 0, 0, 1267, 1264, 1, 0, 0, 0, 1268, 1269, 1, 0, 0, 0, 1269,
		1273, 5, 93, 0, 0, 1270, 1271, 5, 12, 0, 0, 1271, 1273, 5, 93, 0, 0, 1272,
		1261, 1, 0, 0, 0, 1272, 1270, 1, 0, 0, 0, 1273, 185, 1, 0, 0, 0, 1274,
		1287, 3, 190, 95, 0, 1275, 1277, 3, 188, 94, 0, 1276, 1275, 1, 0, 0, 0,
		1276, 1277, 1, 0, 0, 0, 1277, 1278, 1, 0, 0, 0, 1278, 1280, 5, 84, 0, 0,
		1279, 1281, 3, 198, 99, 0, 1280, 1279, 1, 0, 0, 0, 1280, 1281, 1, 0, 0,
		0, 1281, 1282, 1, 0, 0, 0, 1282, 1284, 5, 84, 0, 0, 1283, 1285, 3, 194,
		97, 0, 1284, 1283, 1, 0, 0, 0, 1284, 1285, 1, 0, 0, 0, 1285, 1287, 1, 0,
		0, 0, 1286, 1274, 1, 0, 0, 0, 1286, 1276, 1, 0, 0, 0, 1287, 187, 1, 0,
		0, 0, 1288, 1291, 3, 160, 80, 0, 1289, 1291, 3, 194, 97, 0, 1290, 1288,
		1, 0, 0, 0, 1290, 1289, 1, 0, 0, 0, 1291, 189, 1, 0, 0, 0, 1292, 1294,
		3, 12, 6, 0, 1293, 1292, 1, 0, 0, 0, 1294, 1297, 1, 0, 0, 0, 1295, 1293,
		1, 0, 0, 0, 1295, 1296, 1, 0, 0, 0, 1296, 1300, 1, 0, 0, 0, 1297, 1295,
		1, 0, 0, 0, 1298, 1301, 3, 240, 120, 0, 1299, 1301, 5, 61, 0, 0, 1300,
		1298, 1, 0, 0, 0, 1300, 1299, 1, 0, 0, 0, 1301, 1302, 1, 0, 0, 0, 1302,
		1303, 3, 76, 38, 0, 1303, 1304, 5, 93, 0, 0, 1304, 1305, 3, 198, 99, 0,
		1305, 191, 1, 0, 0, 0, 1306, 1307, 5, 78, 0, 0, 1307, 1308, 3, 198, 99,
		0, 1308, 1309, 5, 79, 0, 0, 1309, 193, 1, 0, 0, 0, 1310, 1315, 3, 198,
		99, 0, 1311, 1312, 5, 85, 0, 0, 1312, 1314, 3, 198, 99, 0, 1313, 1311,
		1, 0, 0, 0, 1314, 1317, 1, 0, 0, 0, 1315, 1313, 1, 0, 0, 0, 1315, 1316,
		1, 0, 0, 0, 1316, 195, 1, 0, 0, 0, 1317, 1315, 1, 0, 0, 0, 1318, 1322,
		3, 162, 81, 0, 1319, 1322, 5, 43, 0, 0, 1320, 1322, 5, 40, 0, 0, 1321,
		1318, 1, 0, 0, 0, 1321, 1319, 1, 0, 0, 0, 1321, 1320, 1, 0, 0, 0, 1322,
		1323, 1, 0, 0, 0, 1323, 1324, 3, 250, 125, 0, 1324, 197, 1, 0, 0, 0, 1325,
		1326, 6, 99, -1, 0, 1326, 1369, 3, 208, 104, 0, 1327, 1369, 3, 196, 98,
		0, 1328, 1329, 3, 240, 120, 0, 1329, 1335, 5, 122, 0, 0, 1330, 1332, 3,
		244, 122, 0, 1331, 1330, 1, 0, 0, 0, 1331, 1332, 1, 0, 0, 0, 1332, 1333,
		1, 0, 0, 0, 1333, 1336, 3, 162, 81, 0, 1334, 1336, 5, 31, 0, 0, 1335, 1331,
		1, 0, 0, 0, 1335, 1334, 1, 0, 0, 0, 1336, 1369, 1, 0, 0, 0, 1337, 1338,
		3, 218, 109, 0, 1338, 1340, 5, 122, 0, 0, 1339, 1341, 3, 244, 122, 0, 1340,
		1339, 1, 0, 0, 0, 1340, 1341, 1, 0, 0, 0, 1341, 1342, 1, 0, 0, 0, 1342,
		1343, 5, 31, 0, 0, 1343, 1369, 1, 0, 0, 0, 1344, 1369, 3, 210, 105, 0,
		1345, 1346, 7, 6, 0, 0, 1346, 1369, 3, 198, 99, 17, 1347, 1351, 5, 78,
		0, 0, 1348, 1350, 3, 112, 56, 0, 1349, 1348, 1, 0, 0, 0, 1350, 1353, 1,
		0, 0, 0, 1351, 1349, 1, 0, 0, 0, 1351, 1352, 1, 0, 0, 0, 1352, 1354, 1,
		0, 0, 0, 1353, 1351, 1, 0, 0, 0, 1354, 1359, 3, 240, 120, 0, 1355, 1356,
		5, 106, 0, 0, 1356, 1358, 3, 240, 120, 0, 1357, 1355, 1, 0, 0, 0, 1358,
		1361, 1, 0, 0, 0, 1359, 1357, 1, 0, 0, 0, 1359, 1360, 1, 0, 0, 0, 1360,
		1362, 1, 0, 0, 0, 1361, 1359, 1, 0, 0, 0, 1362, 1363, 5, 79, 0, 0, 1363,
		1364, 3, 198, 99, 16, 1364, 1369, 1, 0, 0, 0, 1365, 1366, 5, 31, 0, 0,
		1366, 1369, 3, 220, 110, 0, 1367, 1369, 3, 202, 101, 0, 1368, 1325, 1,
		0, 0, 0, 1368, 1327, 1, 0, 0, 0, 1368, 1328, 1, 0, 0, 0, 1368, 1337, 1,
		0, 0, 0, 1368, 1344, 1, 0, 0, 0, 1368, 1345, 1, 0, 0, 0, 1368, 1347, 1,
		0, 0, 0, 1368, 1365, 1, 0, 0, 0, 1368, 1367, 1, 0, 0, 0, 1369, 1453, 1,
		0, 0, 0, 1370, 1371, 10, 14, 0, 0, 1371, 1372, 7, 7, 0, 0, 1372, 1452,
		3, 198, 99, 15, 1373, 1374, 10, 13, 0, 0, 1374, 1375, 7, 8, 0, 0, 1375,
		1452, 3, 198, 99, 14, 1376, 1384, 10, 12, 0, 0, 1377, 1378, 5, 89, 0, 0,
		1378, 1385, 5, 89, 0, 0, 1379, 1380, 5, 88, 0, 0, 1380, 1381, 5, 88, 0,
		0, 1381, 1385, 5, 88, 0, 0, 1382, 1383, 5, 88, 0, 0, 1383, 1385, 5, 88,
		0, 0, 1384, 1377, 1, 0, 0, 0, 1384, 1379, 1, 0, 0, 0, 1384, 1382, 1, 0,
		0, 0, 1385, 1386, 1, 0, 0, 0, 1386, 1452, 3, 198, 99, 13, 1387, 1388, 10,
		11, 0, 0, 1388, 1389, 7, 9, 0, 0, 1389, 1452, 3, 198, 99, 12, 1390, 1391,
		10, 9, 0, 0, 1391, 1392, 7, 10, 0, 0, 1392, 1452, 3, 198, 99, 10, 1393,
		1394, 10, 8, 0, 0, 1394, 1395, 5, 106, 0, 0, 1395, 1452, 3, 198, 99, 9,
		1396, 1397, 10, 7, 0, 0, 1397, 1398, 5, 108, 0, 0, 1398, 1452, 3, 198,
		99, 8, 1399, 1400, 10, 6, 0, 0, 1400, 1401, 5, 107, 0, 0, 1401, 1452, 3,
		198, 99, 7, 1402, 1403, 10, 5, 0, 0, 1403, 1404, 5, 98, 0, 0, 1404, 1452,
		3, 198, 99, 6, 1405, 1406, 10, 4, 0, 0, 1406, 1407, 5, 99, 0, 0, 1407,
		1452, 3, 198, 99, 5, 1408, 1409, 10, 3, 0, 0, 1409, 1410, 5, 92, 0, 0,
		1410, 1411, 3, 198, 99, 0, 1411, 1412, 5, 93, 0, 0, 1412, 1413, 3, 198,
		99, 3, 1413, 1452, 1, 0, 0, 0, 1414, 1415, 10, 2, 0, 0, 1415, 1416, 7,
		11, 0, 0, 1416, 1452, 3, 198, 99, 2, 1417, 1418, 10, 25, 0, 0, 1418, 1419,
		5, 82, 0, 0, 1419, 1420, 3, 198, 99, 0, 1420, 1421, 5, 83, 0, 0, 1421,
		1452, 1, 0, 0, 0, 1422, 1423, 10, 24, 0, 0, 1423, 1435, 5, 86, 0, 0, 1424,
		1436, 3, 162, 81, 0, 1425, 1436, 3, 196, 98, 0, 1426, 1436, 5, 43, 0, 0,
		1427, 1429, 5, 31, 0, 0, 1428, 1430, 3, 236, 118, 0, 1429, 1428, 1, 0,
		0, 0, 1429, 1430, 1, 0, 0, 0, 1430, 1431, 1, 0, 0, 0, 1431, 1436, 3, 224,
		112, 0, 1432, 1433, 5, 40, 0, 0, 1433, 1436, 3, 246, 123, 0, 1434, 1436,
		3, 230, 115, 0, 1435, 1424, 1, 0, 0, 0, 1435, 1425, 1, 0, 0, 0, 1435, 1426,
		1, 0, 0, 0, 1435, 1427, 1, 0, 0, 0, 1435, 1432, 1, 0, 0, 0, 1435, 1434,
		1, 0, 0, 0, 1436, 1452, 1, 0, 0, 0, 1437, 1438, 10, 22, 0, 0, 1438, 1440,
		5, 122, 0, 0, 1439, 1441, 3, 244, 122, 0, 1440, 1439, 1, 0, 0, 0, 1440,
		1441, 1, 0, 0, 0, 1441, 1442, 1, 0, 0, 0, 1442, 1452, 3, 162, 81, 0, 1443,
		1444, 10, 18, 0, 0, 1444, 1452, 7, 12, 0, 0, 1445, 1446, 10, 10, 0, 0,
		1446, 1449, 5, 26, 0, 0, 1447, 1450, 3, 240, 120, 0, 1448, 1450, 3, 200,
		100, 0, 1449, 1447, 1, 0, 0, 0, 1449, 1448, 1, 0, 0, 0, 1450, 1452, 1,
		0, 0, 0, 1451, 1370, 1, 0, 0, 0, 1451, 1373, 1, 0, 0, 0, 1451, 1376, 1,
		0, 0, 0, 1451, 1387, 1, 0, 0, 0, 1451, 1390, 1, 0, 0, 0, 1451, 1393, 1,
		0, 0, 0, 1451, 1396, 1, 0, 0, 0, 1451, 1399, 1, 0, 0, 0, 1451, 1402, 1,
		0, 0, 0, 1451, 1405, 1, 0, 0, 0, 1451, 1408, 1, 0, 0, 0, 1451, 1414, 1,
		0, 0, 0, 1451, 1417, 1, 0, 0, 0, 1451, 1422, 1, 0, 0, 0, 1451, 1437, 1,
		0, 0, 0, 1451, 1443, 1, 0, 0, 0, 1451, 1445, 1, 0, 0, 0, 1452, 1455, 1,
		0, 0, 0, 1453, 1451, 1, 0, 0, 0, 1453, 1454, 1, 0, 0, 0, 1454, 199, 1,
		0, 0, 0, 1455, 1453, 1, 0, 0, 0, 1456, 1458, 3, 12, 6, 0, 1457, 1456, 1,
		0, 0, 0, 1458, 1461, 1, 0, 0, 0, 1459, 1457, 1, 0, 0, 0, 1459, 1460, 1,
		0, 0, 0, 1460, 1462, 1, 0, 0, 0, 1461, 1459, 1, 0, 0, 0, 1462, 1466, 3,
		240, 120, 0, 1463, 1465, 3, 112, 56, 0, 1464, 1463, 1, 0, 0, 0, 1465, 1468,
		1, 0, 0, 0, 1466, 1464, 1, 0, 0, 0, 1466, 1467, 1, 0, 0, 0, 1467, 1469,
		1, 0, 0, 0, 1468, 1466, 1, 0, 0, 0, 1469, 1470, 3, 162, 81, 0, 1470, 201,
		1, 0, 0, 0, 1471, 1472, 3, 204, 102, 0, 1472, 1473, 5, 121, 0, 0, 1473,
		1474, 3, 206, 103, 0, 1474, 203, 1, 0, 0, 0, 1475, 1498, 3, 162, 81, 0,
		1476, 1478, 5, 78, 0, 0, 1477, 1479, 3, 92, 46, 0, 1478, 1477, 1, 0, 0,
		0, 1478, 1479, 1, 0, 0, 0, 1479, 1480, 1, 0, 0, 0, 1480, 1498, 5, 79, 0,
		0, 1481, 1482, 5, 78, 0, 0, 1482, 1487, 3, 162, 81, 0, 1483, 1484, 5, 85,
		0, 0, 1484, 1486, 3, 162, 81, 0, 1485, 1483, 1, 0, 0, 0, 1486, 1489, 1,
		0, 0, 0, 1487, 1485, 1, 0, 0, 0, 1487, 1488, 1, 0, 0, 0, 1488, 1490, 1,
		0, 0, 0, 1489, 1487, 1, 0, 0, 0, 1490, 1491, 5, 79, 0, 0, 1491, 1498, 1,
		0, 0, 0, 1492, 1494, 5, 78, 0, 0, 1493, 1495, 3, 98, 49, 0, 1494, 1493,
		1, 0, 0, 0, 1494, 1495, 1, 0, 0, 0, 1495, 1496, 1, 0, 0, 0, 1496, 1498,
		5, 79, 0, 0, 1497, 1475, 1, 0, 0, 0, 1497, 1476, 1, 0, 0, 0, 1497, 1481,
		1, 0, 0, 0, 1497, 1492, 1, 0, 0, 0, 1498, 205, 1, 0, 0, 0, 1499, 1502,
		3, 198, 99, 0, 1500, 1502, 3, 156, 78, 0, 1501, 1499, 1, 0, 0, 0, 1501,
		1500, 1, 0, 0, 0, 1502, 207, 1, 0, 0, 0, 1503, 1504, 5, 78, 0, 0, 1504,
		1505, 3, 198, 99, 0, 1505, 1506, 5, 79, 0, 0, 1506, 1522, 1, 0, 0, 0, 1507,
		1522, 5, 43, 0, 0, 1508, 1522, 5, 40, 0, 0, 1509, 1522, 3, 104, 52, 0,
		1510, 1522, 3, 162, 81, 0, 1511, 1512, 3, 44, 22, 0, 1512, 1513, 5, 86,
		0, 0, 1513, 1514, 5, 9, 0, 0, 1514, 1522, 1, 0, 0, 0, 1515, 1519, 3, 236,
		118, 0, 1516, 1520, 3, 248, 124, 0, 1517, 1518, 5, 43, 0, 0, 1518, 1520,
		3, 250, 125, 0, 1519, 1516, 1, 0, 0, 0, 1519, 1517, 1, 0, 0, 0, 1520, 1522,
		1, 0, 0, 0, 1521, 1503, 1, 0, 0, 0, 1521, 1507, 1, 0, 0, 0, 1521, 1508,
		1, 0, 0, 0, 1521, 1509, 1, 0, 0, 0, 1521, 1510, 1, 0, 0, 0, 1521, 1511,
		1, 0, 0, 0, 1521, 1515, 1, 0, 0, 0, 1522, 209, 1, 0, 0, 0, 1523, 1524,
		5, 41, 0, 0, 1524, 1525, 3, 192, 96, 0, 1525, 1529, 5, 80, 0, 0, 1526,
		1528, 3, 212, 106, 0, 1527, 1526, 1, 0, 0, 0, 1528, 1531, 1, 0, 0, 0, 1529,
		1527, 1, 0, 0, 0, 1529, 1530, 1, 0, 0, 0, 1530, 1532, 1, 0, 0, 0, 1531,
		1529, 1, 0, 0, 0, 1532, 1533, 5, 81, 0, 0, 1533, 211, 1, 0, 0, 0, 1534,
		1538, 5, 6, 0, 0, 1535, 1539, 3, 194, 97, 0, 1536, 1539, 5, 77, 0, 0, 1537,
		1539, 3, 214, 107, 0, 1538, 1535, 1, 0, 0, 0, 1538, 1536, 1, 0, 0, 0, 1538,
		1537, 1, 0, 0, 0, 1539, 1540, 1, 0, 0, 0, 1540, 1541, 7, 13, 0, 0, 1541,
		1546, 3, 216, 108, 0, 1542, 1543, 5, 12, 0, 0, 1543, 1544, 7, 13, 0, 0,
		1544, 1546, 3, 216, 108, 0, 1545, 1534, 1, 0, 0, 0, 1545, 1542, 1, 0, 0,
		0, 1546, 213, 1, 0, 0, 0, 1547, 1548, 6, 107, -1, 0, 1548, 1549, 5, 78,
		0, 0, 1549, 1550, 3, 214, 107, 0, 1550, 1551, 5, 79, 0, 0, 1551, 1574,
		1, 0, 0, 0, 1552, 1554, 3, 12, 6, 0, 1553, 1552, 1, 0, 0, 0, 1554, 1557,
		1, 0, 0, 0, 1555, 1553, 1, 0, 0, 0, 1555, 1556, 1, 0, 0, 0, 1556, 1558,
		1, 0, 0, 0, 1557, 1555, 1, 0, 0, 0, 1558, 1562, 3, 240, 120, 0, 1559, 1561,
		3, 112, 56, 0, 1560, 1559, 1, 0, 0, 0, 1561, 1564, 1, 0, 0, 0, 1562, 1560,
		1, 0, 0, 0, 1562, 1563, 1, 0, 0, 0, 1563, 1565, 1, 0, 0, 0, 1564, 1562,
		1, 0, 0, 0, 1565, 1570, 3, 162, 81, 0, 1566, 1567, 5, 98, 0, 0, 1567, 1569,
		3, 198, 99, 0, 1568, 1566, 1, 0, 0, 0, 1569, 1572, 1, 0, 0, 0, 1570, 1568,
		1, 0, 0, 0, 1570, 1571, 1, 0, 0, 0, 1571, 1574, 1, 0, 0, 0, 1572, 1570,
		1, 0, 0, 0, 1573, 1547, 1, 0, 0, 0, 1573, 1555, 1, 0, 0, 0, 1574, 1580,
		1, 0, 0, 0, 1575, 1576, 10, 1, 0, 0, 1576, 1577, 5, 98, 0, 0, 1577, 1579,
		3, 198, 99, 0, 1578, 1575, 1, 0, 0, 0, 1579, 1582, 1, 0, 0, 0, 1580, 1578,
		1, 0, 0, 0, 1580, 1581, 1, 0, 0, 0, 1581, 215, 1, 0, 0, 0, 1582, 1580,
		1, 0, 0, 0, 1583, 1591, 3, 156, 78, 0, 1584, 1586, 3, 158, 79, 0, 1585,
		1584, 1, 0, 0, 0, 1586, 1589, 1, 0, 0, 0, 1587, 1585, 1, 0, 0, 0, 1587,
		1588, 1, 0, 0, 0, 1588, 1591, 1, 0, 0, 0, 1589, 1587, 1, 0, 0, 0, 1590,
		1583, 1, 0, 0, 0, 1590, 1587, 1, 0, 0, 0, 1591, 217, 1, 0, 0, 0, 1592,
		1593, 3, 82, 41, 0, 1593, 1594, 5, 86, 0, 0, 1594, 1596, 1, 0, 0, 0, 1595,
		1592, 1, 0, 0, 0, 1595, 1596, 1, 0, 0, 0, 1596, 1600, 1, 0, 0, 0, 1597,
		1599, 3, 112, 56, 0, 1598, 1597, 1, 0, 0, 0, 1599, 1602, 1, 0, 0, 0, 1600,
		1598, 1, 0, 0, 0, 1600, 1601, 1, 0, 0, 0, 1601, 1603, 1, 0, 0, 0, 1602,
		1600, 1, 0, 0, 0, 1603, 1605, 3, 162, 81, 0, 1604, 1606, 3, 244, 122, 0,
		1605, 1604, 1, 0, 0, 0, 1605, 1606, 1, 0, 0, 0, 1606, 219, 1, 0, 0, 0,
		1607, 1609, 3, 236, 118, 0, 1608, 1607, 1, 0, 0, 0, 1608, 1609, 1, 0, 0,
		0, 1609, 1610, 1, 0, 0, 0, 1610, 1611, 3, 222, 111, 0, 1611, 1612, 3, 228,
		114, 0, 1612, 1617, 1, 0, 0, 0, 1613, 1614, 3, 222, 111, 0, 1614, 1615,
		3, 226, 113, 0, 1615, 1617, 1, 0, 0, 0, 1616, 1608, 1, 0, 0, 0, 1616, 1613,
		1, 0, 0, 0, 1617, 221, 1, 0, 0, 0, 1618, 1620, 3, 162, 81, 0, 1619, 1621,
		3, 232, 116, 0, 1620, 1619, 1, 0, 0, 0, 1620, 1621, 1, 0, 0, 0, 1621, 1629,
		1, 0, 0, 0, 1622, 1623, 5, 86, 0, 0, 1623, 1625, 3, 162, 81, 0, 1624, 1626,
		3, 232, 116, 0, 1625, 1624, 1, 0, 0, 0, 1625, 1626, 1, 0, 0, 0, 1626, 1628,
		1, 0, 0, 0, 1627, 1622, 1, 0, 0, 0, 1628, 1631, 1, 0, 0, 0, 1629, 1627,
		1, 0, 0, 0, 1629, 1630, 1, 0, 0, 0, 1630, 1634, 1, 0, 0, 0, 1631, 1629,
		1, 0, 0, 0, 1632, 1634, 3, 242, 121, 0, 1633, 1618, 1, 0, 0, 0, 1633, 1632,
		1, 0, 0, 0, 1634, 223, 1, 0, 0, 0, 1635, 1637, 3, 162, 81, 0, 1636, 1638,
		3, 234, 117, 0, 1637, 1636, 1, 0, 0, 0, 1637, 1638, 1, 0, 0, 0, 1638, 1639,
		1, 0, 0, 0, 1639, 1640, 3, 228, 114, 0, 1640, 225, 1, 0, 0, 0, 1641, 1642,
		5, 82, 0, 0, 1642, 1644, 5, 83, 0, 0, 1643, 1641, 1, 0, 0, 0, 1644, 1645,
		1, 0, 0, 0, 1645, 1643, 1, 0, 0, 0, 1645, 1646, 1, 0, 0, 0, 1646, 1647,
		1, 0, 0, 0, 1647, 1664, 3, 80, 40, 0, 1648, 1649, 5, 82, 0, 0, 1649, 1650,
		3, 198, 99, 0, 1650, 1651, 5, 83, 0, 0, 1651, 1653, 1, 0, 0, 0, 1652, 1648,
		1, 0, 0, 0, 1653, 1654, 1, 0, 0, 0, 1654, 1652, 1, 0, 0, 0, 1654, 1655,
		1, 0, 0, 0, 1655, 1660, 1, 0, 0, 0, 1656, 1657, 5, 82, 0, 0, 1657, 1659,
		5, 83, 0, 0, 1658, 1656, 1, 0, 0, 0, 1659, 1662, 1, 0, 0, 0, 1660, 1658,
		1, 0, 0, 0, 1660, 1661, 1, 0, 0, 0, 1661, 1664, 1, 0, 0, 0, 1662, 1660,
		1, 0, 0, 0, 1663, 1643, 1, 0, 0, 0, 1663, 1652, 1, 0, 0, 0, 1664, 227,
		1, 0, 0, 0, 1665, 1667, 3, 250, 125, 0, 1666, 1668, 3, 32, 16, 0, 1667,
		1666, 1, 0, 0, 0, 1667, 1668, 1, 0, 0, 0, 1668, 229, 1, 0, 0, 0, 1669,
		1670, 3, 236, 118, 0, 1670, 1671, 3, 248, 124, 0, 1671, 231, 1, 0, 0, 0,
		1672, 1673, 5, 89, 0, 0, 1673, 1676, 5, 88, 0, 0, 1674, 1676, 3, 244, 122,
		0, 1675, 1672, 1, 0, 0, 0, 1675, 1674, 1, 0, 0, 0, 1676, 233, 1, 0, 0,
		0, 1677, 1678, 5, 89, 0, 0, 1678, 1681, 5, 88, 0, 0, 1679, 1681, 3, 236,
		118, 0, 1680, 1677, 1, 0, 0, 0, 1680, 1679, 1, 0, 0, 0, 1681, 235, 1, 0,
		0, 0, 1682, 1683, 5, 89, 0, 0, 1683, 1684, 3, 238, 119, 0, 1684, 1685,
		5, 88, 0, 0, 1685, 237, 1, 0, 0, 0, 1686, 1691, 3, 240, 120, 0, 1687, 1688,
		5, 85, 0, 0, 1688, 1690, 3, 240, 120, 0, 1689, 1687, 1, 0, 0, 0, 1690,
		1693, 1, 0, 0, 0, 1691, 1689, 1, 0, 0, 0, 1691, 1692, 1, 0, 0, 0, 1692,
		239, 1, 0, 0, 0, 1693, 1691, 1, 0, 0, 0, 1694, 1696, 3, 112, 56, 0, 1695,
		1694, 1, 0, 0, 0, 1696, 1699, 1, 0, 0, 0, 1697, 1695, 1, 0, 0, 0, 1697,
		1698, 1, 0, 0, 0, 1698, 1702, 1, 0, 0, 0, 1699, 1697, 1, 0, 0, 0, 1700,
		1703, 3, 82, 41, 0, 1701, 1703, 3, 242, 121, 0, 1702, 1700, 1, 0, 0, 0,
		1702, 1701, 1, 0, 0, 0, 1703, 1714, 1, 0, 0, 0, 1704, 1706, 3, 112, 56,
		0, 1705, 1704, 1, 0, 0, 0, 1706, 1709, 1, 0, 0, 0, 1707, 1705, 1, 0, 0,
		0, 1707, 1708, 1, 0, 0, 0, 1708, 1710, 1, 0, 0, 0, 1709, 1707, 1, 0, 0,
		0, 1710, 1711, 5, 82, 0, 0, 1711, 1713, 5, 83, 0, 0, 1712, 1707, 1, 0,
		0, 0, 1713, 1716, 1, 0, 0, 0, 1714, 1712, 1, 0, 0, 0, 1714, 1715, 1, 0,
		0, 0, 1715, 241, 1, 0, 0, 0, 1716, 1714, 1, 0, 0, 0, 1717, 1718, 7, 14,
		0, 0, 1718, 243, 1, 0, 0, 0, 1719, 1720, 5, 89, 0, 0, 1720, 1725, 3, 84,
		42, 0, 1721, 1722, 5, 85, 0, 0, 1722, 1724, 3, 84, 42, 0, 1723, 1721, 1,
		0, 0, 0, 1724, 1727, 1, 0, 0, 0, 1725, 1723, 1, 0, 0, 0, 1725, 1726, 1,
		0, 0, 0, 1726, 1728, 1, 0, 0, 0, 1727, 1725, 1, 0, 0, 0, 1728, 1729, 5,
		88, 0, 0, 1729, 245, 1, 0, 0, 0, 1730, 1740, 3, 250, 125, 0, 1731, 1733,
		5, 86, 0, 0, 1732, 1734, 3, 244, 122, 0, 1733, 1732, 1, 0, 0, 0, 1733,
		1734, 1, 0, 0, 0, 1734, 1735, 1, 0, 0, 0, 1735, 1737, 3, 162, 81, 0, 1736,
		1738, 3, 250, 125, 0, 1737, 1736, 1, 0, 0, 0, 1737, 1738, 1, 0, 0, 0, 1738,
		1740, 1, 0, 0, 0, 1739, 1730, 1, 0, 0, 0, 1739, 1731, 1, 0, 0, 0, 1740,
		247, 1, 0, 0, 0, 1741, 1742, 5, 40, 0, 0, 1742, 1747, 3, 246, 123, 0, 1743,
		1744, 3, 162, 81, 0, 1744, 1745, 3, 250, 125, 0, 1745, 1747, 1, 0, 0, 0,
		1746, 1741, 1, 0, 0, 0, 1746, 1743, 1, 0, 0, 0, 1747, 249, 1, 0, 0, 0,
		1748, 1750, 5, 78, 0, 0, 1749, 1751, 3, 194, 97, 0, 1750, 1749, 1, 0, 0,
		0, 1750, 1751, 1, 0, 0, 0, 1751, 1752, 1, 0, 0, 0, 1752, 1753, 5, 79, 0,
		0, 1753, 251, 1, 0, 0, 0, 219, 253, 257, 259, 264, 266, 272, 277, 286,
		291, 298, 306, 313, 325, 329, 334, 338, 342, 346, 356, 364, 372, 376, 383,
		390, 394, 397, 400, 409, 415, 420, 423, 429, 435, 439, 443, 451, 460, 467,
		473, 477, 489, 498, 503, 509, 513, 525, 532, 545, 550, 560, 568, 578, 587,
		598, 603, 612, 622, 627, 636, 642, 649, 654, 662, 666, 668, 674, 680, 685,
		691, 697, 699, 706, 711, 716, 719, 721, 731, 741, 746, 749, 754, 763, 770,
		781, 787, 798, 808, 819, 828, 833, 836, 843, 853, 861, 864, 867, 880, 888,
		893, 901, 905, 909, 913, 917, 919, 923, 929, 937, 947, 956, 966, 974, 988,
		995, 1000, 1006, 1015, 1024, 1026, 1035, 1045, 1050, 1061, 1070, 1076,
		1083, 1092, 1115, 1118, 1121, 1129, 1133, 1141, 1147, 1158, 1167, 1172,
		1185, 1191, 1198, 1211, 1220, 1229, 1235, 1243, 1249, 1254, 1259, 1267,
		1272, 1276, 1280, 1284, 1286, 1290, 1295, 1300, 1315, 1321, 1331, 1335,
		1340, 1351, 1359, 1368, 1384, 1429, 1435, 1440, 1449, 1451, 1453, 1459,
		1466, 1478, 1487, 1494, 1497, 1501, 1519, 1521, 1529, 1538, 1545, 1555,
		1562, 1570, 1573, 1580, 1587, 1590, 1595, 1600, 1605, 1608, 1616, 1620,
		1625, 1629, 1633, 1637, 1645, 1654, 1660, 1663, 1667, 1675, 1680, 1691,
		1697, 1702, 1707, 1714, 1725, 1733, 1737, 1739, 1746, 1750,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// JavaParserInit initializes any static state used to implement JavaParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewJavaParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func JavaParserInit() {
	staticData := &JavaParserParserStaticData
	staticData.once.Do(javaparserParserInit)
}

// NewJavaParser produces a new parser instance for the optional input antlr.TokenStream.
func NewJavaParser(input antlr.TokenStream) *JavaParser {
	JavaParserInit()
	this := new(JavaParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &JavaParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "JavaParser.g4"

	return this
}

// JavaParser tokens.
const (
	JavaParserEOF               = antlr.TokenEOF
	JavaParserABSTRACT          = 1
	JavaParserASSERT            = 2
	JavaParserBOOLEAN           = 3
	JavaParserBREAK             = 4
	JavaParserBYTE              = 5
	JavaParserCASE              = 6
	JavaParserCATCH             = 7
	JavaParserCHAR              = 8
	JavaParserCLASS             = 9
	JavaParserCONST             = 10
	JavaParserCONTINUE          = 11
	JavaParserDEFAULT           = 12
	JavaParserDO                = 13
	JavaParserDOUBLE            = 14
	JavaParserELSE              = 15
	JavaParserENUM              = 16
	JavaParserEXTENDS           = 17
	JavaParserFINAL             = 18
	JavaParserFINALLY           = 19
	JavaParserFLOAT             = 20
	JavaParserFOR               = 21
	JavaParserIF                = 22
	JavaParserGOTO              = 23
	JavaParserIMPLEMENTS        = 24
	JavaParserIMPORT            = 25
	JavaParserINSTANCEOF        = 26
	JavaParserINT               = 27
	JavaParserINTERFACE         = 28
	JavaParserLONG              = 29
	JavaParserNATIVE            = 30
	JavaParserNEW               = 31
	JavaParserPACKAGE           = 32
	JavaParserPRIVATE           = 33
	JavaParserPROTECTED         = 34
	JavaParserPUBLIC            = 35
	JavaParserRETURN            = 36
	JavaParserSHORT             = 37
	JavaParserSTATIC            = 38
	JavaParserSTRICTFP          = 39
	JavaParserSUPER             = 40
	JavaParserSWITCH            = 41
	JavaParserSYNCHRONIZED      = 42
	JavaParserTHIS              = 43
	JavaParserTHROW             = 44
	JavaParserTHROWS            = 45
	JavaParserTRANSIENT         = 46
	JavaParserTRY               = 47
	JavaParserVOID              = 48
	JavaParserVOLATILE          = 49
	JavaParserWHILE             = 50
	JavaParserMODULE            = 51
	JavaParserOPEN              = 52
	JavaParserREQUIRES          = 53
	JavaParserEXPORTS           = 54
	JavaParserOPENS             = 55
	JavaParserTO                = 56
	JavaParserUSES              = 57
	JavaParserPROVIDES          = 58
	JavaParserWITH              = 59
	JavaParserTRANSITIVE        = 60
	JavaParserVAR               = 61
	JavaParserYIELD             = 62
	JavaParserRECORD            = 63
	JavaParserSEALED            = 64
	JavaParserPERMITS           = 65
	JavaParserNON_SEALED        = 66
	JavaParserDECIMAL_LITERAL   = 67
	JavaParserHEX_LITERAL       = 68
	JavaParserOCT_LITERAL       = 69
	JavaParserBINARY_LITERAL    = 70
	JavaParserFLOAT_LITERAL     = 71
	JavaParserHEX_FLOAT_LITERAL = 72
	JavaParserBOOL_LITERAL      = 73
	JavaParserCHAR_LITERAL      = 74
	JavaParserSTRING_LITERAL    = 75
	JavaParserTEXT_BLOCK        = 76
	JavaParserNULL_LITERAL      = 77
	JavaParserLPAREN            = 78
	JavaParserRPAREN            = 79
	JavaParserLBRACE            = 80
	JavaParserRBRACE            = 81
	JavaParserLBRACK            = 82
	JavaParserRBRACK            = 83
	JavaParserSEMI              = 84
	JavaParserCOMMA             = 85
	JavaParserDOT               = 86
	JavaParserASSIGN            = 87
	JavaParserGT                = 88
	JavaParserLT                = 89
	JavaParserBANG              = 90
	JavaParserTILDE             = 91
	JavaParserQUESTION          = 92
	JavaParserCOLON             = 93
	JavaParserEQUAL             = 94
	JavaParserLE                = 95
	JavaParserGE                = 96
	JavaParserNOTEQUAL          = 97
	JavaParserAND               = 98
	JavaParserOR                = 99
	JavaParserINC               = 100
	JavaParserDEC               = 101
	JavaParserADD               = 102
	JavaParserSUB               = 103
	JavaParserMUL               = 104
	JavaParserDIV               = 105
	JavaParserBITAND            = 106
	JavaParserBITOR             = 107
	JavaParserCARET             = 108
	JavaParserMOD               = 109
	JavaParserADD_ASSIGN        = 110
	JavaParserSUB_ASSIGN        = 111
	JavaParserMUL_ASSIGN        = 112
	JavaParserDIV_ASSIGN        = 113
	JavaParserAND_ASSIGN        = 114
	JavaParserOR_ASSIGN         = 115
	JavaParserXOR_ASSIGN        = 116
	JavaParserMOD_ASSIGN        = 117
	JavaParserLSHIFT_ASSIGN     = 118
	JavaParserRSHIFT_ASSIGN     = 119
	JavaParserURSHIFT_ASSIGN    = 120
	JavaParserARROW             = 121
	JavaParserCOLONCOLON        = 122
	JavaParserAT                = 123
	JavaParserELLIPSIS          = 124
	JavaParserWS                = 125
	JavaParserCOMMENT           = 126
	JavaParserLINE_COMMENT      = 127
	JavaParserIDENTIFIER        = 128
)

// JavaParser rules.
const (
	JavaParserRULE_compilationUnit                   = 0
	JavaParserRULE_packageDeclaration                = 1
	JavaParserRULE_importDeclaration                 = 2
	JavaParserRULE_typeDeclaration                   = 3
	JavaParserRULE_modifier                          = 4
	JavaParserRULE_classOrInterfaceModifier          = 5
	JavaParserRULE_variableModifier                  = 6
	JavaParserRULE_classDeclaration                  = 7
	JavaParserRULE_typeParameters                    = 8
	JavaParserRULE_typeParameter                     = 9
	JavaParserRULE_typeBound                         = 10
	JavaParserRULE_enumDeclaration                   = 11
	JavaParserRULE_enumConstants                     = 12
	JavaParserRULE_enumConstant                      = 13
	JavaParserRULE_enumBodyDeclarations              = 14
	JavaParserRULE_interfaceDeclaration              = 15
	JavaParserRULE_classBody                         = 16
	JavaParserRULE_interfaceBody                     = 17
	JavaParserRULE_classBodyDeclaration              = 18
	JavaParserRULE_memberDeclaration                 = 19
	JavaParserRULE_methodDeclaration                 = 20
	JavaParserRULE_methodBody                        = 21
	JavaParserRULE_typeTypeOrVoid                    = 22
	JavaParserRULE_genericMethodDeclaration          = 23
	JavaParserRULE_genericConstructorDeclaration     = 24
	JavaParserRULE_constructorDeclaration            = 25
	JavaParserRULE_compactConstructorDeclaration     = 26
	JavaParserRULE_fieldDeclaration                  = 27
	JavaParserRULE_interfaceBodyDeclaration          = 28
	JavaParserRULE_interfaceMemberDeclaration        = 29
	JavaParserRULE_constDeclaration                  = 30
	JavaParserRULE_constantDeclarator                = 31
	JavaParserRULE_interfaceMethodDeclaration        = 32
	JavaParserRULE_interfaceMethodModifier           = 33
	JavaParserRULE_genericInterfaceMethodDeclaration = 34
	JavaParserRULE_interfaceCommonBodyDeclaration    = 35
	JavaParserRULE_variableDeclarators               = 36
	JavaParserRULE_variableDeclarator                = 37
	JavaParserRULE_variableDeclaratorId              = 38
	JavaParserRULE_variableInitializer               = 39
	JavaParserRULE_arrayInitializer                  = 40
	JavaParserRULE_classOrInterfaceType              = 41
	JavaParserRULE_typeArgument                      = 42
	JavaParserRULE_qualifiedNameList                 = 43
	JavaParserRULE_formalParameters                  = 44
	JavaParserRULE_receiverParameter                 = 45
	JavaParserRULE_formalParameterList               = 46
	JavaParserRULE_formalParameter                   = 47
	JavaParserRULE_lastFormalParameter               = 48
	JavaParserRULE_lambdaLVTIList                    = 49
	JavaParserRULE_lambdaLVTIParameter               = 50
	JavaParserRULE_qualifiedName                     = 51
	JavaParserRULE_literal                           = 52
	JavaParserRULE_integerLiteral                    = 53
	JavaParserRULE_floatLiteral                      = 54
	JavaParserRULE_altAnnotationQualifiedName        = 55
	JavaParserRULE_annotation                        = 56
	JavaParserRULE_elementValuePairs                 = 57
	JavaParserRULE_elementValuePair                  = 58
	JavaParserRULE_elementValue                      = 59
	JavaParserRULE_elementValueArrayInitializer      = 60
	JavaParserRULE_annotationTypeDeclaration         = 61
	JavaParserRULE_annotationTypeBody                = 62
	JavaParserRULE_annotationTypeElementDeclaration  = 63
	JavaParserRULE_annotationTypeElementRest         = 64
	JavaParserRULE_annotationMethodOrConstantRest    = 65
	JavaParserRULE_annotationMethodRest              = 66
	JavaParserRULE_annotationConstantRest            = 67
	JavaParserRULE_defaultValue                      = 68
	JavaParserRULE_moduleDeclaration                 = 69
	JavaParserRULE_moduleBody                        = 70
	JavaParserRULE_moduleDirective                   = 71
	JavaParserRULE_requiresModifier                  = 72
	JavaParserRULE_recordDeclaration                 = 73
	JavaParserRULE_recordHeader                      = 74
	JavaParserRULE_recordComponentList               = 75
	JavaParserRULE_recordComponent                   = 76
	JavaParserRULE_recordBody                        = 77
	JavaParserRULE_block                             = 78
	JavaParserRULE_blockStatement                    = 79
	JavaParserRULE_localVariableDeclaration          = 80
	JavaParserRULE_identifier                        = 81
	JavaParserRULE_typeIdentifier                    = 82
	JavaParserRULE_localTypeDeclaration              = 83
	JavaParserRULE_statement                         = 84
	JavaParserRULE_catchClause                       = 85
	JavaParserRULE_catchType                         = 86
	JavaParserRULE_finallyBlock                      = 87
	JavaParserRULE_resourceSpecification             = 88
	JavaParserRULE_resources                         = 89
	JavaParserRULE_resource                          = 90
	JavaParserRULE_switchBlockStatementGroup         = 91
	JavaParserRULE_switchLabel                       = 92
	JavaParserRULE_forControl                        = 93
	JavaParserRULE_forInit                           = 94
	JavaParserRULE_enhancedForControl                = 95
	JavaParserRULE_parExpression                     = 96
	JavaParserRULE_expressionList                    = 97
	JavaParserRULE_methodCall                        = 98
	JavaParserRULE_expression                        = 99
	JavaParserRULE_pattern                           = 100
	JavaParserRULE_lambdaExpression                  = 101
	JavaParserRULE_lambdaParameters                  = 102
	JavaParserRULE_lambdaBody                        = 103
	JavaParserRULE_primary                           = 104
	JavaParserRULE_switchExpression                  = 105
	JavaParserRULE_switchLabeledRule                 = 106
	JavaParserRULE_guardedPattern                    = 107
	JavaParserRULE_switchRuleOutcome                 = 108
	JavaParserRULE_classType                         = 109
	JavaParserRULE_creator                           = 110
	JavaParserRULE_createdName                       = 111
	JavaParserRULE_innerCreator                      = 112
	JavaParserRULE_arrayCreatorRest                  = 113
	JavaParserRULE_classCreatorRest                  = 114
	JavaParserRULE_explicitGenericInvocation         = 115
	JavaParserRULE_typeArgumentsOrDiamond            = 116
	JavaParserRULE_nonWildcardTypeArgumentsOrDiamond = 117
	JavaParserRULE_nonWildcardTypeArguments          = 118
	JavaParserRULE_typeList                          = 119
	JavaParserRULE_typeType                          = 120
	JavaParserRULE_primitiveType                     = 121
	JavaParserRULE_typeArguments                     = 122
	JavaParserRULE_superSuffix                       = 123
	JavaParserRULE_explicitGenericInvocationSuffix   = 124
	JavaParserRULE_arguments                         = 125
)

// ICompilationUnitContext is an interface to support dynamic dispatch.
type ICompilationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PackageDeclaration() IPackageDeclarationContext
	AllImportDeclaration() []IImportDeclarationContext
	ImportDeclaration(i int) IImportDeclarationContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllTypeDeclaration() []ITypeDeclarationContext
	TypeDeclaration(i int) ITypeDeclarationContext
	ModuleDeclaration() IModuleDeclarationContext
	EOF() antlr.TerminalNode

	// IsCompilationUnitContext differentiates from other interfaces.
	IsCompilationUnitContext()
}

type CompilationUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilationUnitContext() *CompilationUnitContext {
	var p = new(CompilationUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_compilationUnit
	return p
}

func InitEmptyCompilationUnitContext(p *CompilationUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_compilationUnit
}

func (*CompilationUnitContext) IsCompilationUnitContext() {}

func NewCompilationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilationUnitContext {
	var p = new(CompilationUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_compilationUnit

	return p
}

func (s *CompilationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilationUnitContext) PackageDeclaration() IPackageDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageDeclarationContext)
}

func (s *CompilationUnitContext) AllImportDeclaration() []IImportDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IImportDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportDeclarationContext); ok {
			tst[i] = t.(IImportDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *CompilationUnitContext) ImportDeclaration(i int) IImportDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeclarationContext)
}

func (s *CompilationUnitContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(JavaParserSEMI)
}

func (s *CompilationUnitContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, i)
}

func (s *CompilationUnitContext) AllTypeDeclaration() []ITypeDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeDeclarationContext); ok {
			len++
		}
	}

	tst := make([]ITypeDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeDeclarationContext); ok {
			tst[i] = t.(ITypeDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *CompilationUnitContext) TypeDeclaration(i int) ITypeDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *CompilationUnitContext) ModuleDeclaration() IModuleDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleDeclarationContext)
}

func (s *CompilationUnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(JavaParserEOF, 0)
}

func (s *CompilationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilationUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterCompilationUnit(s)
	}
}

func (s *CompilationUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitCompilationUnit(s)
	}
}

func (s *CompilationUnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitCompilationUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) CompilationUnit() (localctx ICompilationUnitContext) {
	localctx = NewCompilationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, JavaParserRULE_compilationUnit)
	var _la int

	var _alt int

	p.SetState(272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(253)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(252)
				p.PackageDeclaration()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(259)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(257)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case JavaParserIMPORT:
					{
						p.SetState(255)
						p.ImportDeclaration()
					}

				case JavaParserSEMI:
					{
						p.SetState(256)
						p.Match(JavaParserSEMI)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}
			p.SetState(261)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(266)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-1125457390829311) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-8935141660702539773) != 0) {
			p.SetState(264)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case JavaParserABSTRACT, JavaParserCLASS, JavaParserENUM, JavaParserFINAL, JavaParserINTERFACE, JavaParserPRIVATE, JavaParserPROTECTED, JavaParserPUBLIC, JavaParserSTATIC, JavaParserSTRICTFP, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserNON_SEALED, JavaParserAT, JavaParserIDENTIFIER:
				{
					p.SetState(262)
					p.TypeDeclaration()
				}

			case JavaParserSEMI:
				{
					p.SetState(263)
					p.Match(JavaParserSEMI)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(268)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(269)
			p.ModuleDeclaration()
		}
		{
			p.SetState(270)
			p.Match(JavaParserEOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackageDeclarationContext is an interface to support dynamic dispatch.
type IPackageDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PACKAGE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	SEMI() antlr.TerminalNode
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext

	// IsPackageDeclarationContext differentiates from other interfaces.
	IsPackageDeclarationContext()
}

type PackageDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageDeclarationContext() *PackageDeclarationContext {
	var p = new(PackageDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_packageDeclaration
	return p
}

func InitEmptyPackageDeclarationContext(p *PackageDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_packageDeclaration
}

func (*PackageDeclarationContext) IsPackageDeclarationContext() {}

func NewPackageDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageDeclarationContext {
	var p = new(PackageDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_packageDeclaration

	return p
}

func (s *PackageDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageDeclarationContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(JavaParserPACKAGE, 0)
}

func (s *PackageDeclarationContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *PackageDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *PackageDeclarationContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *PackageDeclarationContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *PackageDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterPackageDeclaration(s)
	}
}

func (s *PackageDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitPackageDeclaration(s)
	}
}

func (s *PackageDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitPackageDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) PackageDeclaration() (localctx IPackageDeclarationContext) {
	localctx = NewPackageDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, JavaParserRULE_packageDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(277)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-51)) & ^0x3f) == 0 && ((int64(1)<<(_la-51))&32767) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
		{
			p.SetState(274)
			p.Annotation()
		}

		p.SetState(279)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(280)
		p.Match(JavaParserPACKAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(281)
		p.QualifiedName()
	}
	{
		p.SetState(282)
		p.Match(JavaParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportDeclarationContext is an interface to support dynamic dispatch.
type IImportDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	SEMI() antlr.TerminalNode
	STATIC() antlr.TerminalNode
	DOT() antlr.TerminalNode
	MUL() antlr.TerminalNode

	// IsImportDeclarationContext differentiates from other interfaces.
	IsImportDeclarationContext()
}

type ImportDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDeclarationContext() *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_importDeclaration
	return p
}

func InitEmptyImportDeclarationContext(p *ImportDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_importDeclaration
}

func (*ImportDeclarationContext) IsImportDeclarationContext() {}

func NewImportDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_importDeclaration

	return p
}

func (s *ImportDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeclarationContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(JavaParserIMPORT, 0)
}

func (s *ImportDeclarationContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ImportDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *ImportDeclarationContext) STATIC() antlr.TerminalNode {
	return s.GetToken(JavaParserSTATIC, 0)
}

func (s *ImportDeclarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(JavaParserDOT, 0)
}

func (s *ImportDeclarationContext) MUL() antlr.TerminalNode {
	return s.GetToken(JavaParserMUL, 0)
}

func (s *ImportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterImportDeclaration(s)
	}
}

func (s *ImportDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitImportDeclaration(s)
	}
}

func (s *ImportDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitImportDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ImportDeclaration() (localctx IImportDeclarationContext) {
	localctx = NewImportDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, JavaParserRULE_importDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(284)
		p.Match(JavaParserIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserSTATIC {
		{
			p.SetState(285)
			p.Match(JavaParserSTATIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(288)
		p.QualifiedName()
	}
	p.SetState(291)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserDOT {
		{
			p.SetState(289)
			p.Match(JavaParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(290)
			p.Match(JavaParserMUL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(293)
		p.Match(JavaParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDeclarationContext is an interface to support dynamic dispatch.
type ITypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassDeclaration() IClassDeclarationContext
	EnumDeclaration() IEnumDeclarationContext
	InterfaceDeclaration() IInterfaceDeclarationContext
	AnnotationTypeDeclaration() IAnnotationTypeDeclarationContext
	RecordDeclaration() IRecordDeclarationContext
	AllClassOrInterfaceModifier() []IClassOrInterfaceModifierContext
	ClassOrInterfaceModifier(i int) IClassOrInterfaceModifierContext

	// IsTypeDeclarationContext differentiates from other interfaces.
	IsTypeDeclarationContext()
}

type TypeDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclarationContext() *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeDeclaration
	return p
}

func InitEmptyTypeDeclarationContext(p *TypeDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeDeclaration
}

func (*TypeDeclarationContext) IsTypeDeclarationContext() {}

func NewTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeDeclaration

	return p
}

func (s *TypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *TypeDeclarationContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *TypeDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *TypeDeclarationContext) AnnotationTypeDeclaration() IAnnotationTypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationTypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationTypeDeclarationContext)
}

func (s *TypeDeclarationContext) RecordDeclaration() IRecordDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationContext)
}

func (s *TypeDeclarationContext) AllClassOrInterfaceModifier() []IClassOrInterfaceModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			len++
		}
	}

	tst := make([]IClassOrInterfaceModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			tst[i] = t.(IClassOrInterfaceModifierContext)
			i++
		}
	}

	return tst
}

func (s *TypeDeclarationContext) ClassOrInterfaceModifier(i int) IClassOrInterfaceModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceModifierContext)
}

func (s *TypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeDeclaration(s)
	}
}

func (s *TypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeDeclaration(s)
	}
}

func (s *TypeDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitTypeDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) TypeDeclaration() (localctx ITypeDeclarationContext) {
	localctx = NewTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, JavaParserRULE_typeDeclaration)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(298)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(295)
				p.ClassOrInterfaceModifier()
			}

		}
		p.SetState(300)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(306)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserCLASS:
		{
			p.SetState(301)
			p.ClassDeclaration()
		}

	case JavaParserENUM:
		{
			p.SetState(302)
			p.EnumDeclaration()
		}

	case JavaParserINTERFACE:
		{
			p.SetState(303)
			p.InterfaceDeclaration()
		}

	case JavaParserAT:
		{
			p.SetState(304)
			p.AnnotationTypeDeclaration()
		}

	case JavaParserRECORD:
		{
			p.SetState(305)
			p.RecordDeclaration()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassOrInterfaceModifier() IClassOrInterfaceModifierContext
	NATIVE() antlr.TerminalNode
	SYNCHRONIZED() antlr.TerminalNode
	TRANSIENT() antlr.TerminalNode
	VOLATILE() antlr.TerminalNode

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_modifier
	return p
}

func InitEmptyModifierContext(p *ModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_modifier
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) ClassOrInterfaceModifier() IClassOrInterfaceModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceModifierContext)
}

func (s *ModifierContext) NATIVE() antlr.TerminalNode {
	return s.GetToken(JavaParserNATIVE, 0)
}

func (s *ModifierContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(JavaParserSYNCHRONIZED, 0)
}

func (s *ModifierContext) TRANSIENT() antlr.TerminalNode {
	return s.GetToken(JavaParserTRANSIENT, 0)
}

func (s *ModifierContext) VOLATILE() antlr.TerminalNode {
	return s.GetToken(JavaParserVOLATILE, 0)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterModifier(s)
	}
}

func (s *ModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitModifier(s)
	}
}

func (s *ModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) Modifier() (localctx IModifierContext) {
	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, JavaParserRULE_modifier)
	p.SetState(313)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserABSTRACT, JavaParserFINAL, JavaParserPRIVATE, JavaParserPROTECTED, JavaParserPUBLIC, JavaParserSTATIC, JavaParserSTRICTFP, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserNON_SEALED, JavaParserAT, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(308)
			p.ClassOrInterfaceModifier()
		}

	case JavaParserNATIVE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(309)
			p.Match(JavaParserNATIVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaParserSYNCHRONIZED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(310)
			p.Match(JavaParserSYNCHRONIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaParserTRANSIENT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(311)
			p.Match(JavaParserTRANSIENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaParserVOLATILE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(312)
			p.Match(JavaParserVOLATILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassOrInterfaceModifierContext is an interface to support dynamic dispatch.
type IClassOrInterfaceModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext
	PUBLIC() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode
	STATIC() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	STRICTFP() antlr.TerminalNode
	SEALED() antlr.TerminalNode
	NON_SEALED() antlr.TerminalNode

	// IsClassOrInterfaceModifierContext differentiates from other interfaces.
	IsClassOrInterfaceModifierContext()
}

type ClassOrInterfaceModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOrInterfaceModifierContext() *ClassOrInterfaceModifierContext {
	var p = new(ClassOrInterfaceModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_classOrInterfaceModifier
	return p
}

func InitEmptyClassOrInterfaceModifierContext(p *ClassOrInterfaceModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_classOrInterfaceModifier
}

func (*ClassOrInterfaceModifierContext) IsClassOrInterfaceModifierContext() {}

func NewClassOrInterfaceModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceModifierContext {
	var p = new(ClassOrInterfaceModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_classOrInterfaceModifier

	return p
}

func (s *ClassOrInterfaceModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ClassOrInterfaceModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(JavaParserPUBLIC, 0)
}

func (s *ClassOrInterfaceModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(JavaParserPROTECTED, 0)
}

func (s *ClassOrInterfaceModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(JavaParserPRIVATE, 0)
}

func (s *ClassOrInterfaceModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(JavaParserSTATIC, 0)
}

func (s *ClassOrInterfaceModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(JavaParserABSTRACT, 0)
}

func (s *ClassOrInterfaceModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(JavaParserFINAL, 0)
}

func (s *ClassOrInterfaceModifierContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(JavaParserSTRICTFP, 0)
}

func (s *ClassOrInterfaceModifierContext) SEALED() antlr.TerminalNode {
	return s.GetToken(JavaParserSEALED, 0)
}

func (s *ClassOrInterfaceModifierContext) NON_SEALED() antlr.TerminalNode {
	return s.GetToken(JavaParserNON_SEALED, 0)
}

func (s *ClassOrInterfaceModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterClassOrInterfaceModifier(s)
	}
}

func (s *ClassOrInterfaceModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitClassOrInterfaceModifier(s)
	}
}

func (s *ClassOrInterfaceModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitClassOrInterfaceModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ClassOrInterfaceModifier() (localctx IClassOrInterfaceModifierContext) {
	localctx = NewClassOrInterfaceModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, JavaParserRULE_classOrInterfaceModifier)
	p.SetState(325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(315)
			p.Annotation()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(316)
			p.Match(JavaParserPUBLIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(317)
			p.Match(JavaParserPROTECTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(318)
			p.Match(JavaParserPRIVATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(319)
			p.Match(JavaParserSTATIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(320)
			p.Match(JavaParserABSTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(321)
			p.Match(JavaParserFINAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(322)
			p.Match(JavaParserSTRICTFP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(323)
			p.Match(JavaParserSEALED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(324)
			p.Match(JavaParserNON_SEALED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableModifierContext is an interface to support dynamic dispatch.
type IVariableModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FINAL() antlr.TerminalNode
	Annotation() IAnnotationContext

	// IsVariableModifierContext differentiates from other interfaces.
	IsVariableModifierContext()
}

type VariableModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableModifierContext() *VariableModifierContext {
	var p = new(VariableModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_variableModifier
	return p
}

func InitEmptyVariableModifierContext(p *VariableModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_variableModifier
}

func (*VariableModifierContext) IsVariableModifierContext() {}

func NewVariableModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableModifierContext {
	var p = new(VariableModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_variableModifier

	return p
}

func (s *VariableModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(JavaParserFINAL, 0)
}

func (s *VariableModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *VariableModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterVariableModifier(s)
	}
}

func (s *VariableModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitVariableModifier(s)
	}
}

func (s *VariableModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitVariableModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) VariableModifier() (localctx IVariableModifierContext) {
	localctx = NewVariableModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, JavaParserRULE_variableModifier)
	p.SetState(329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserFINAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(327)
			p.Match(JavaParserFINAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserAT, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(328)
			p.Annotation()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	Identifier() IIdentifierContext
	ClassBody() IClassBodyContext
	TypeParameters() ITypeParametersContext
	EXTENDS() antlr.TerminalNode
	TypeType() ITypeTypeContext
	IMPLEMENTS() antlr.TerminalNode
	AllTypeList() []ITypeListContext
	TypeList(i int) ITypeListContext
	PERMITS() antlr.TerminalNode

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_classDeclaration
	return p
}

func InitEmptyClassDeclarationContext(p *ClassDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_classDeclaration
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) CLASS() antlr.TerminalNode {
	return s.GetToken(JavaParserCLASS, 0)
}

func (s *ClassDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassDeclarationContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ClassDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *ClassDeclarationContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(JavaParserEXTENDS, 0)
}

func (s *ClassDeclarationContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *ClassDeclarationContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(JavaParserIMPLEMENTS, 0)
}

func (s *ClassDeclarationContext) AllTypeList() []ITypeListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeListContext); ok {
			len++
		}
	}

	tst := make([]ITypeListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeListContext); ok {
			tst[i] = t.(ITypeListContext)
			i++
		}
	}

	return tst
}

func (s *ClassDeclarationContext) TypeList(i int) ITypeListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *ClassDeclarationContext) PERMITS() antlr.TerminalNode {
	return s.GetToken(JavaParserPERMITS, 0)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, JavaParserRULE_classDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(331)
		p.Match(JavaParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(332)
		p.Identifier()
	}
	p.SetState(334)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserLT {
		{
			p.SetState(333)
			p.TypeParameters()
		}

	}
	p.SetState(338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserEXTENDS {
		{
			p.SetState(336)
			p.Match(JavaParserEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(337)
			p.TypeType()
		}

	}
	p.SetState(342)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserIMPLEMENTS {
		{
			p.SetState(340)
			p.Match(JavaParserIMPLEMENTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(341)
			p.TypeList()
		}

	}
	p.SetState(346)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserPERMITS {
		{
			p.SetState(344)
			p.Match(JavaParserPERMITS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(345)
			p.TypeList()
		}

	}
	{
		p.SetState(348)
		p.ClassBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParametersContext is an interface to support dynamic dispatch.
type ITypeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	AllTypeParameter() []ITypeParameterContext
	TypeParameter(i int) ITypeParameterContext
	GT() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeParametersContext differentiates from other interfaces.
	IsTypeParametersContext()
}

type TypeParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParametersContext() *TypeParametersContext {
	var p = new(TypeParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeParameters
	return p
}

func InitEmptyTypeParametersContext(p *TypeParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeParameters
}

func (*TypeParametersContext) IsTypeParametersContext() {}

func NewTypeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParametersContext {
	var p = new(TypeParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeParameters

	return p
}

func (s *TypeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParametersContext) LT() antlr.TerminalNode {
	return s.GetToken(JavaParserLT, 0)
}

func (s *TypeParametersContext) AllTypeParameter() []ITypeParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterContext); ok {
			tst[i] = t.(ITypeParameterContext)
			i++
		}
	}

	return tst
}

func (s *TypeParametersContext) TypeParameter(i int) ITypeParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *TypeParametersContext) GT() antlr.TerminalNode {
	return s.GetToken(JavaParserGT, 0)
}

func (s *TypeParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *TypeParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *TypeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeParameters(s)
	}
}

func (s *TypeParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeParameters(s)
	}
}

func (s *TypeParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitTypeParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) TypeParameters() (localctx ITypeParametersContext) {
	localctx = NewTypeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, JavaParserRULE_typeParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(350)
		p.Match(JavaParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(351)
		p.TypeParameter()
	}
	p.SetState(356)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCOMMA {
		{
			p.SetState(352)
			p.Match(JavaParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(353)
			p.TypeParameter()
		}

		p.SetState(358)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(359)
		p.Match(JavaParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	EXTENDS() antlr.TerminalNode
	TypeBound() ITypeBoundContext

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeParameter
	return p
}

func InitEmptyTypeParameterContext(p *TypeParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeParameter
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeParameterContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *TypeParameterContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeParameterContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(JavaParserEXTENDS, 0)
}

func (s *TypeParameterContext) TypeBound() ITypeBoundContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeBoundContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeBoundContext)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (s *TypeParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitTypeParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, JavaParserRULE_typeParameter)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(361)
				p.Annotation()
			}

		}
		p.SetState(366)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(367)
		p.Identifier()
	}
	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserEXTENDS {
		{
			p.SetState(368)
			p.Match(JavaParserEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(372)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(369)
					p.Annotation()
				}

			}
			p.SetState(374)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(375)
			p.TypeBound()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeBoundContext is an interface to support dynamic dispatch.
type ITypeBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeType() []ITypeTypeContext
	TypeType(i int) ITypeTypeContext
	AllBITAND() []antlr.TerminalNode
	BITAND(i int) antlr.TerminalNode

	// IsTypeBoundContext differentiates from other interfaces.
	IsTypeBoundContext()
}

type TypeBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeBoundContext() *TypeBoundContext {
	var p = new(TypeBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeBound
	return p
}

func InitEmptyTypeBoundContext(p *TypeBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeBound
}

func (*TypeBoundContext) IsTypeBoundContext() {}

func NewTypeBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeBoundContext {
	var p = new(TypeBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeBound

	return p
}

func (s *TypeBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeBoundContext) AllTypeType() []ITypeTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeTypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeTypeContext); ok {
			tst[i] = t.(ITypeTypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeBoundContext) TypeType(i int) ITypeTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeBoundContext) AllBITAND() []antlr.TerminalNode {
	return s.GetTokens(JavaParserBITAND)
}

func (s *TypeBoundContext) BITAND(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserBITAND, i)
}

func (s *TypeBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeBound(s)
	}
}

func (s *TypeBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeBound(s)
	}
}

func (s *TypeBoundContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitTypeBound(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) TypeBound() (localctx ITypeBoundContext) {
	localctx = NewTypeBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, JavaParserRULE_typeBound)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(378)
		p.TypeType()
	}
	p.SetState(383)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserBITAND {
		{
			p.SetState(379)
			p.Match(JavaParserBITAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(380)
			p.TypeType()
		}

		p.SetState(385)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumDeclarationContext is an interface to support dynamic dispatch.
type IEnumDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENUM() antlr.TerminalNode
	Identifier() IIdentifierContext
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	IMPLEMENTS() antlr.TerminalNode
	TypeList() ITypeListContext
	EnumConstants() IEnumConstantsContext
	COMMA() antlr.TerminalNode
	EnumBodyDeclarations() IEnumBodyDeclarationsContext

	// IsEnumDeclarationContext differentiates from other interfaces.
	IsEnumDeclarationContext()
}

type EnumDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumDeclarationContext() *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_enumDeclaration
	return p
}

func InitEmptyEnumDeclarationContext(p *EnumDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_enumDeclaration
}

func (*EnumDeclarationContext) IsEnumDeclarationContext() {}

func NewEnumDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_enumDeclaration

	return p
}

func (s *EnumDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDeclarationContext) ENUM() antlr.TerminalNode {
	return s.GetToken(JavaParserENUM, 0)
}

func (s *EnumDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumDeclarationContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *EnumDeclarationContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *EnumDeclarationContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(JavaParserIMPLEMENTS, 0)
}

func (s *EnumDeclarationContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *EnumDeclarationContext) EnumConstants() IEnumConstantsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumConstantsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumConstantsContext)
}

func (s *EnumDeclarationContext) COMMA() antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, 0)
}

func (s *EnumDeclarationContext) EnumBodyDeclarations() IEnumBodyDeclarationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumBodyDeclarationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumBodyDeclarationsContext)
}

func (s *EnumDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterEnumDeclaration(s)
	}
}

func (s *EnumDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitEnumDeclaration(s)
	}
}

func (s *EnumDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitEnumDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) EnumDeclaration() (localctx IEnumDeclarationContext) {
	localctx = NewEnumDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, JavaParserRULE_enumDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(386)
		p.Match(JavaParserENUM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(387)
		p.Identifier()
	}
	p.SetState(390)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserIMPLEMENTS {
		{
			p.SetState(388)
			p.Match(JavaParserIMPLEMENTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(389)
			p.TypeList()
		}

	}
	{
		p.SetState(392)
		p.Match(JavaParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(394)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-51)) & ^0x3f) == 0 && ((int64(1)<<(_la-51))&32767) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
		{
			p.SetState(393)
			p.EnumConstants()
		}

	}
	p.SetState(397)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserCOMMA {
		{
			p.SetState(396)
			p.Match(JavaParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(400)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserSEMI {
		{
			p.SetState(399)
			p.EnumBodyDeclarations()
		}

	}
	{
		p.SetState(402)
		p.Match(JavaParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumConstantsContext is an interface to support dynamic dispatch.
type IEnumConstantsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEnumConstant() []IEnumConstantContext
	EnumConstant(i int) IEnumConstantContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsEnumConstantsContext differentiates from other interfaces.
	IsEnumConstantsContext()
}

type EnumConstantsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantsContext() *EnumConstantsContext {
	var p = new(EnumConstantsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_enumConstants
	return p
}

func InitEmptyEnumConstantsContext(p *EnumConstantsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_enumConstants
}

func (*EnumConstantsContext) IsEnumConstantsContext() {}

func NewEnumConstantsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantsContext {
	var p = new(EnumConstantsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_enumConstants

	return p
}

func (s *EnumConstantsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantsContext) AllEnumConstant() []IEnumConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumConstantContext); ok {
			len++
		}
	}

	tst := make([]IEnumConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumConstantContext); ok {
			tst[i] = t.(IEnumConstantContext)
			i++
		}
	}

	return tst
}

func (s *EnumConstantsContext) EnumConstant(i int) IEnumConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumConstantContext)
}

func (s *EnumConstantsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *EnumConstantsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *EnumConstantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterEnumConstants(s)
	}
}

func (s *EnumConstantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitEnumConstants(s)
	}
}

func (s *EnumConstantsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitEnumConstants(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) EnumConstants() (localctx IEnumConstantsContext) {
	localctx = NewEnumConstantsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, JavaParserRULE_enumConstants)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(404)
		p.EnumConstant()
	}
	p.SetState(409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(405)
				p.Match(JavaParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(406)
				p.EnumConstant()
			}

		}
		p.SetState(411)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumConstantContext is an interface to support dynamic dispatch.
type IEnumConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	Arguments() IArgumentsContext
	ClassBody() IClassBodyContext

	// IsEnumConstantContext differentiates from other interfaces.
	IsEnumConstantContext()
}

type EnumConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantContext() *EnumConstantContext {
	var p = new(EnumConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_enumConstant
	return p
}

func InitEmptyEnumConstantContext(p *EnumConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_enumConstant
}

func (*EnumConstantContext) IsEnumConstantContext() {}

func NewEnumConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantContext {
	var p = new(EnumConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_enumConstant

	return p
}

func (s *EnumConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumConstantContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *EnumConstantContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *EnumConstantContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *EnumConstantContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *EnumConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterEnumConstant(s)
	}
}

func (s *EnumConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitEnumConstant(s)
	}
}

func (s *EnumConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitEnumConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) EnumConstant() (localctx IEnumConstantContext) {
	localctx = NewEnumConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, JavaParserRULE_enumConstant)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(415)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(412)
				p.Annotation()
			}

		}
		p.SetState(417)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(418)
		p.Identifier()
	}
	p.SetState(420)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserLPAREN {
		{
			p.SetState(419)
			p.Arguments()
		}

	}
	p.SetState(423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserLBRACE {
		{
			p.SetState(422)
			p.ClassBody()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumBodyDeclarationsContext is an interface to support dynamic dispatch.
type IEnumBodyDeclarationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode
	AllClassBodyDeclaration() []IClassBodyDeclarationContext
	ClassBodyDeclaration(i int) IClassBodyDeclarationContext

	// IsEnumBodyDeclarationsContext differentiates from other interfaces.
	IsEnumBodyDeclarationsContext()
}

type EnumBodyDeclarationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumBodyDeclarationsContext() *EnumBodyDeclarationsContext {
	var p = new(EnumBodyDeclarationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_enumBodyDeclarations
	return p
}

func InitEmptyEnumBodyDeclarationsContext(p *EnumBodyDeclarationsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_enumBodyDeclarations
}

func (*EnumBodyDeclarationsContext) IsEnumBodyDeclarationsContext() {}

func NewEnumBodyDeclarationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumBodyDeclarationsContext {
	var p = new(EnumBodyDeclarationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_enumBodyDeclarations

	return p
}

func (s *EnumBodyDeclarationsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumBodyDeclarationsContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *EnumBodyDeclarationsContext) AllClassBodyDeclaration() []IClassBodyDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassBodyDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassBodyDeclarationContext); ok {
			tst[i] = t.(IClassBodyDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *EnumBodyDeclarationsContext) ClassBodyDeclaration(i int) IClassBodyDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyDeclarationContext)
}

func (s *EnumBodyDeclarationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumBodyDeclarationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumBodyDeclarationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterEnumBodyDeclarations(s)
	}
}

func (s *EnumBodyDeclarationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitEnumBodyDeclarations(s)
	}
}

func (s *EnumBodyDeclarationsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitEnumBodyDeclarations(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) EnumBodyDeclarations() (localctx IEnumBodyDeclarationsContext) {
	localctx = NewEnumBodyDeclarationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, JavaParserRULE_enumBodyDeclarations)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(425)
		p.Match(JavaParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(429)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-665791937994347) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-8935141660685729789) != 0) {
		{
			p.SetState(426)
			p.ClassBodyDeclaration()
		}

		p.SetState(431)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	Identifier() IIdentifierContext
	InterfaceBody() IInterfaceBodyContext
	TypeParameters() ITypeParametersContext
	EXTENDS() antlr.TerminalNode
	AllTypeList() []ITypeListContext
	TypeList(i int) ITypeListContext
	PERMITS() antlr.TerminalNode

	// IsInterfaceDeclarationContext differentiates from other interfaces.
	IsInterfaceDeclarationContext()
}

type InterfaceDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationContext() *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceDeclaration
	return p
}

func InitEmptyInterfaceDeclarationContext(p *InterfaceDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceDeclaration
}

func (*InterfaceDeclarationContext) IsInterfaceDeclarationContext() {}

func NewInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_interfaceDeclaration

	return p
}

func (s *InterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(JavaParserINTERFACE, 0)
}

func (s *InterfaceDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InterfaceDeclarationContext) InterfaceBody() IInterfaceBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceBodyContext)
}

func (s *InterfaceDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *InterfaceDeclarationContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(JavaParserEXTENDS, 0)
}

func (s *InterfaceDeclarationContext) AllTypeList() []ITypeListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeListContext); ok {
			len++
		}
	}

	tst := make([]ITypeListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeListContext); ok {
			tst[i] = t.(ITypeListContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceDeclarationContext) TypeList(i int) ITypeListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *InterfaceDeclarationContext) PERMITS() antlr.TerminalNode {
	return s.GetToken(JavaParserPERMITS, 0)
}

func (s *InterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitInterfaceDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) InterfaceDeclaration() (localctx IInterfaceDeclarationContext) {
	localctx = NewInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, JavaParserRULE_interfaceDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(432)
		p.Match(JavaParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(433)
		p.Identifier()
	}
	p.SetState(435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserLT {
		{
			p.SetState(434)
			p.TypeParameters()
		}

	}
	p.SetState(439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserEXTENDS {
		{
			p.SetState(437)
			p.Match(JavaParserEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(438)
			p.TypeList()
		}

	}
	p.SetState(443)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserPERMITS {
		{
			p.SetState(441)
			p.Match(JavaParserPERMITS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(442)
			p.TypeList()
		}

	}
	{
		p.SetState(445)
		p.InterfaceBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassBodyContext is an interface to support dynamic dispatch.
type IClassBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllClassBodyDeclaration() []IClassBodyDeclarationContext
	ClassBodyDeclaration(i int) IClassBodyDeclarationContext

	// IsClassBodyContext differentiates from other interfaces.
	IsClassBodyContext()
}

type ClassBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyContext() *ClassBodyContext {
	var p = new(ClassBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_classBody
	return p
}

func InitEmptyClassBodyContext(p *ClassBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_classBody
}

func (*ClassBodyContext) IsClassBodyContext() {}

func NewClassBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyContext {
	var p = new(ClassBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_classBody

	return p
}

func (s *ClassBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *ClassBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *ClassBodyContext) AllClassBodyDeclaration() []IClassBodyDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassBodyDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassBodyDeclarationContext); ok {
			tst[i] = t.(IClassBodyDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ClassBodyContext) ClassBodyDeclaration(i int) IClassBodyDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyDeclarationContext)
}

func (s *ClassBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterClassBody(s)
	}
}

func (s *ClassBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitClassBody(s)
	}
}

func (s *ClassBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitClassBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ClassBody() (localctx IClassBodyContext) {
	localctx = NewClassBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, JavaParserRULE_classBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(447)
		p.Match(JavaParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(451)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-665791937994347) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-8935141660685729789) != 0) {
		{
			p.SetState(448)
			p.ClassBodyDeclaration()
		}

		p.SetState(453)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(454)
		p.Match(JavaParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceBodyContext is an interface to support dynamic dispatch.
type IInterfaceBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllInterfaceBodyDeclaration() []IInterfaceBodyDeclarationContext
	InterfaceBodyDeclaration(i int) IInterfaceBodyDeclarationContext

	// IsInterfaceBodyContext differentiates from other interfaces.
	IsInterfaceBodyContext()
}

type InterfaceBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceBodyContext() *InterfaceBodyContext {
	var p = new(InterfaceBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceBody
	return p
}

func InitEmptyInterfaceBodyContext(p *InterfaceBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceBody
}

func (*InterfaceBodyContext) IsInterfaceBodyContext() {}

func NewInterfaceBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceBodyContext {
	var p = new(InterfaceBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_interfaceBody

	return p
}

func (s *InterfaceBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *InterfaceBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *InterfaceBodyContext) AllInterfaceBodyDeclaration() []IInterfaceBodyDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceBodyDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceBodyDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceBodyDeclarationContext); ok {
			tst[i] = t.(IInterfaceBodyDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBodyContext) InterfaceBodyDeclaration(i int) IInterfaceBodyDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceBodyDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceBodyDeclarationContext)
}

func (s *InterfaceBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterInterfaceBody(s)
	}
}

func (s *InterfaceBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitInterfaceBody(s)
	}
}

func (s *InterfaceBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitInterfaceBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) InterfaceBody() (localctx IInterfaceBodyContext) {
	localctx = NewInterfaceBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, JavaParserRULE_interfaceBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(456)
		p.Match(JavaParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(460)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-665791937992299) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-8935141660685762557) != 0) {
		{
			p.SetState(457)
			p.InterfaceBodyDeclaration()
		}

		p.SetState(462)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(463)
		p.Match(JavaParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassBodyDeclarationContext is an interface to support dynamic dispatch.
type IClassBodyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode
	Block() IBlockContext
	STATIC() antlr.TerminalNode
	MemberDeclaration() IMemberDeclarationContext
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext

	// IsClassBodyDeclarationContext differentiates from other interfaces.
	IsClassBodyDeclarationContext()
}

type ClassBodyDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyDeclarationContext() *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_classBodyDeclaration
	return p
}

func InitEmptyClassBodyDeclarationContext(p *ClassBodyDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_classBodyDeclaration
}

func (*ClassBodyDeclarationContext) IsClassBodyDeclarationContext() {}

func NewClassBodyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_classBodyDeclaration

	return p
}

func (s *ClassBodyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *ClassBodyDeclarationContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ClassBodyDeclarationContext) STATIC() antlr.TerminalNode {
	return s.GetToken(JavaParserSTATIC, 0)
}

func (s *ClassBodyDeclarationContext) MemberDeclaration() IMemberDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberDeclarationContext)
}

func (s *ClassBodyDeclarationContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *ClassBodyDeclarationContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *ClassBodyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterClassBodyDeclaration(s)
	}
}

func (s *ClassBodyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitClassBodyDeclaration(s)
	}
}

func (s *ClassBodyDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitClassBodyDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ClassBodyDeclaration() (localctx IClassBodyDeclarationContext) {
	localctx = NewClassBodyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, JavaParserRULE_classBodyDeclaration)
	var _la int

	var _alt int

	p.SetState(477)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(465)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(467)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserSTATIC {
			{
				p.SetState(466)
				p.Match(JavaParserSTATIC)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(469)
			p.Block()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(473)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(470)
					p.Modifier()
				}

			}
			p.SetState(475)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(476)
			p.MemberDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMemberDeclarationContext is an interface to support dynamic dispatch.
type IMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RecordDeclaration() IRecordDeclarationContext
	MethodDeclaration() IMethodDeclarationContext
	GenericMethodDeclaration() IGenericMethodDeclarationContext
	FieldDeclaration() IFieldDeclarationContext
	ConstructorDeclaration() IConstructorDeclarationContext
	GenericConstructorDeclaration() IGenericConstructorDeclarationContext
	InterfaceDeclaration() IInterfaceDeclarationContext
	AnnotationTypeDeclaration() IAnnotationTypeDeclarationContext
	ClassDeclaration() IClassDeclarationContext
	EnumDeclaration() IEnumDeclarationContext

	// IsMemberDeclarationContext differentiates from other interfaces.
	IsMemberDeclarationContext()
}

type MemberDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberDeclarationContext() *MemberDeclarationContext {
	var p = new(MemberDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_memberDeclaration
	return p
}

func InitEmptyMemberDeclarationContext(p *MemberDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_memberDeclaration
}

func (*MemberDeclarationContext) IsMemberDeclarationContext() {}

func NewMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberDeclarationContext {
	var p = new(MemberDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_memberDeclaration

	return p
}

func (s *MemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberDeclarationContext) RecordDeclaration() IRecordDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationContext)
}

func (s *MemberDeclarationContext) MethodDeclaration() IMethodDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDeclarationContext)
}

func (s *MemberDeclarationContext) GenericMethodDeclaration() IGenericMethodDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericMethodDeclarationContext)
}

func (s *MemberDeclarationContext) FieldDeclaration() IFieldDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclarationContext)
}

func (s *MemberDeclarationContext) ConstructorDeclaration() IConstructorDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorDeclarationContext)
}

func (s *MemberDeclarationContext) GenericConstructorDeclaration() IGenericConstructorDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericConstructorDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericConstructorDeclarationContext)
}

func (s *MemberDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *MemberDeclarationContext) AnnotationTypeDeclaration() IAnnotationTypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationTypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationTypeDeclarationContext)
}

func (s *MemberDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *MemberDeclarationContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *MemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterMemberDeclaration(s)
	}
}

func (s *MemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitMemberDeclaration(s)
	}
}

func (s *MemberDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitMemberDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) MemberDeclaration() (localctx IMemberDeclarationContext) {
	localctx = NewMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, JavaParserRULE_memberDeclaration)
	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(479)
			p.RecordDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(480)
			p.MethodDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(481)
			p.GenericMethodDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(482)
			p.FieldDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(483)
			p.ConstructorDeclaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(484)
			p.GenericConstructorDeclaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(485)
			p.InterfaceDeclaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(486)
			p.AnnotationTypeDeclaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(487)
			p.ClassDeclaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(488)
			p.EnumDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodDeclarationContext is an interface to support dynamic dispatch.
type IMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeTypeOrVoid() ITypeTypeOrVoidContext
	Identifier() IIdentifierContext
	FormalParameters() IFormalParametersContext
	MethodBody() IMethodBodyContext
	AllLBRACK() []antlr.TerminalNode
	LBRACK(i int) antlr.TerminalNode
	AllRBRACK() []antlr.TerminalNode
	RBRACK(i int) antlr.TerminalNode
	THROWS() antlr.TerminalNode
	QualifiedNameList() IQualifiedNameListContext

	// IsMethodDeclarationContext differentiates from other interfaces.
	IsMethodDeclarationContext()
}

type MethodDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDeclarationContext() *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_methodDeclaration
	return p
}

func InitEmptyMethodDeclarationContext(p *MethodDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_methodDeclaration
}

func (*MethodDeclarationContext) IsMethodDeclarationContext() {}

func NewMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_methodDeclaration

	return p
}

func (s *MethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDeclarationContext) TypeTypeOrVoid() ITypeTypeOrVoidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeOrVoidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeOrVoidContext)
}

func (s *MethodDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodDeclarationContext) FormalParameters() IFormalParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *MethodDeclarationContext) MethodBody() IMethodBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *MethodDeclarationContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserLBRACK)
}

func (s *MethodDeclarationContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACK, i)
}

func (s *MethodDeclarationContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserRBRACK)
}

func (s *MethodDeclarationContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACK, i)
}

func (s *MethodDeclarationContext) THROWS() antlr.TerminalNode {
	return s.GetToken(JavaParserTHROWS, 0)
}

func (s *MethodDeclarationContext) QualifiedNameList() IQualifiedNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameListContext)
}

func (s *MethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterMethodDeclaration(s)
	}
}

func (s *MethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitMethodDeclaration(s)
	}
}

func (s *MethodDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitMethodDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) MethodDeclaration() (localctx IMethodDeclarationContext) {
	localctx = NewMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, JavaParserRULE_methodDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(491)
		p.TypeTypeOrVoid()
	}
	{
		p.SetState(492)
		p.Identifier()
	}
	{
		p.SetState(493)
		p.FormalParameters()
	}
	p.SetState(498)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserLBRACK {
		{
			p.SetState(494)
			p.Match(JavaParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(495)
			p.Match(JavaParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(500)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserTHROWS {
		{
			p.SetState(501)
			p.Match(JavaParserTHROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(502)
			p.QualifiedNameList()
		}

	}
	{
		p.SetState(505)
		p.MethodBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodBodyContext is an interface to support dynamic dispatch.
type IMethodBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	SEMI() antlr.TerminalNode

	// IsMethodBodyContext differentiates from other interfaces.
	IsMethodBodyContext()
}

type MethodBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodBodyContext() *MethodBodyContext {
	var p = new(MethodBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_methodBody
	return p
}

func InitEmptyMethodBodyContext(p *MethodBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_methodBody
}

func (*MethodBodyContext) IsMethodBodyContext() {}

func NewMethodBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodBodyContext {
	var p = new(MethodBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_methodBody

	return p
}

func (s *MethodBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *MethodBodyContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *MethodBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterMethodBody(s)
	}
}

func (s *MethodBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitMethodBody(s)
	}
}

func (s *MethodBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitMethodBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) MethodBody() (localctx IMethodBodyContext) {
	localctx = NewMethodBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, JavaParserRULE_methodBody)
	p.SetState(509)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserLBRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(507)
			p.Block()
		}

	case JavaParserSEMI:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(508)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeTypeOrVoidContext is an interface to support dynamic dispatch.
type ITypeTypeOrVoidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeType() ITypeTypeContext
	VOID() antlr.TerminalNode

	// IsTypeTypeOrVoidContext differentiates from other interfaces.
	IsTypeTypeOrVoidContext()
}

type TypeTypeOrVoidContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeTypeOrVoidContext() *TypeTypeOrVoidContext {
	var p = new(TypeTypeOrVoidContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeTypeOrVoid
	return p
}

func InitEmptyTypeTypeOrVoidContext(p *TypeTypeOrVoidContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeTypeOrVoid
}

func (*TypeTypeOrVoidContext) IsTypeTypeOrVoidContext() {}

func NewTypeTypeOrVoidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeTypeOrVoidContext {
	var p = new(TypeTypeOrVoidContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeTypeOrVoid

	return p
}

func (s *TypeTypeOrVoidContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeTypeOrVoidContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeTypeOrVoidContext) VOID() antlr.TerminalNode {
	return s.GetToken(JavaParserVOID, 0)
}

func (s *TypeTypeOrVoidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeTypeOrVoidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeTypeOrVoidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeTypeOrVoid(s)
	}
}

func (s *TypeTypeOrVoidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeTypeOrVoid(s)
	}
}

func (s *TypeTypeOrVoidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitTypeTypeOrVoid(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) TypeTypeOrVoid() (localctx ITypeTypeOrVoidContext) {
	localctx = NewTypeTypeOrVoidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, JavaParserRULE_typeTypeOrVoid)
	p.SetState(513)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserBOOLEAN, JavaParserBYTE, JavaParserCHAR, JavaParserDOUBLE, JavaParserFLOAT, JavaParserINT, JavaParserLONG, JavaParserSHORT, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserAT, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(511)
			p.TypeType()
		}

	case JavaParserVOID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(512)
			p.Match(JavaParserVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericMethodDeclarationContext is an interface to support dynamic dispatch.
type IGenericMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeParameters() ITypeParametersContext
	MethodDeclaration() IMethodDeclarationContext

	// IsGenericMethodDeclarationContext differentiates from other interfaces.
	IsGenericMethodDeclarationContext()
}

type GenericMethodDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericMethodDeclarationContext() *GenericMethodDeclarationContext {
	var p = new(GenericMethodDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_genericMethodDeclaration
	return p
}

func InitEmptyGenericMethodDeclarationContext(p *GenericMethodDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_genericMethodDeclaration
}

func (*GenericMethodDeclarationContext) IsGenericMethodDeclarationContext() {}

func NewGenericMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericMethodDeclarationContext {
	var p = new(GenericMethodDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_genericMethodDeclaration

	return p
}

func (s *GenericMethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericMethodDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *GenericMethodDeclarationContext) MethodDeclaration() IMethodDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDeclarationContext)
}

func (s *GenericMethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericMethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericMethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterGenericMethodDeclaration(s)
	}
}

func (s *GenericMethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitGenericMethodDeclaration(s)
	}
}

func (s *GenericMethodDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitGenericMethodDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) GenericMethodDeclaration() (localctx IGenericMethodDeclarationContext) {
	localctx = NewGenericMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, JavaParserRULE_genericMethodDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(515)
		p.TypeParameters()
	}
	{
		p.SetState(516)
		p.MethodDeclaration()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericConstructorDeclarationContext is an interface to support dynamic dispatch.
type IGenericConstructorDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeParameters() ITypeParametersContext
	ConstructorDeclaration() IConstructorDeclarationContext

	// IsGenericConstructorDeclarationContext differentiates from other interfaces.
	IsGenericConstructorDeclarationContext()
}

type GenericConstructorDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericConstructorDeclarationContext() *GenericConstructorDeclarationContext {
	var p = new(GenericConstructorDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_genericConstructorDeclaration
	return p
}

func InitEmptyGenericConstructorDeclarationContext(p *GenericConstructorDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_genericConstructorDeclaration
}

func (*GenericConstructorDeclarationContext) IsGenericConstructorDeclarationContext() {}

func NewGenericConstructorDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericConstructorDeclarationContext {
	var p = new(GenericConstructorDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_genericConstructorDeclaration

	return p
}

func (s *GenericConstructorDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericConstructorDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *GenericConstructorDeclarationContext) ConstructorDeclaration() IConstructorDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorDeclarationContext)
}

func (s *GenericConstructorDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericConstructorDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericConstructorDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterGenericConstructorDeclaration(s)
	}
}

func (s *GenericConstructorDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitGenericConstructorDeclaration(s)
	}
}

func (s *GenericConstructorDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitGenericConstructorDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) GenericConstructorDeclaration() (localctx IGenericConstructorDeclarationContext) {
	localctx = NewGenericConstructorDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, JavaParserRULE_genericConstructorDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(518)
		p.TypeParameters()
	}
	{
		p.SetState(519)
		p.ConstructorDeclaration()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstructorDeclarationContext is an interface to support dynamic dispatch.
type IConstructorDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConstructorBody returns the constructorBody rule contexts.
	GetConstructorBody() IBlockContext

	// SetConstructorBody sets the constructorBody rule contexts.
	SetConstructorBody(IBlockContext)

	// Getter signatures
	Identifier() IIdentifierContext
	FormalParameters() IFormalParametersContext
	Block() IBlockContext
	THROWS() antlr.TerminalNode
	QualifiedNameList() IQualifiedNameListContext

	// IsConstructorDeclarationContext differentiates from other interfaces.
	IsConstructorDeclarationContext()
}

type ConstructorDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	constructorBody IBlockContext
}

func NewEmptyConstructorDeclarationContext() *ConstructorDeclarationContext {
	var p = new(ConstructorDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_constructorDeclaration
	return p
}

func InitEmptyConstructorDeclarationContext(p *ConstructorDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_constructorDeclaration
}

func (*ConstructorDeclarationContext) IsConstructorDeclarationContext() {}

func NewConstructorDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorDeclarationContext {
	var p = new(ConstructorDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_constructorDeclaration

	return p
}

func (s *ConstructorDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorDeclarationContext) GetConstructorBody() IBlockContext { return s.constructorBody }

func (s *ConstructorDeclarationContext) SetConstructorBody(v IBlockContext) { s.constructorBody = v }

func (s *ConstructorDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstructorDeclarationContext) FormalParameters() IFormalParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *ConstructorDeclarationContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ConstructorDeclarationContext) THROWS() antlr.TerminalNode {
	return s.GetToken(JavaParserTHROWS, 0)
}

func (s *ConstructorDeclarationContext) QualifiedNameList() IQualifiedNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameListContext)
}

func (s *ConstructorDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterConstructorDeclaration(s)
	}
}

func (s *ConstructorDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitConstructorDeclaration(s)
	}
}

func (s *ConstructorDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitConstructorDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ConstructorDeclaration() (localctx IConstructorDeclarationContext) {
	localctx = NewConstructorDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, JavaParserRULE_constructorDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(521)
		p.Identifier()
	}
	{
		p.SetState(522)
		p.FormalParameters()
	}
	p.SetState(525)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserTHROWS {
		{
			p.SetState(523)
			p.Match(JavaParserTHROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(524)
			p.QualifiedNameList()
		}

	}
	{
		p.SetState(527)

		var _x = p.Block()

		localctx.(*ConstructorDeclarationContext).constructorBody = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompactConstructorDeclarationContext is an interface to support dynamic dispatch.
type ICompactConstructorDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConstructorBody returns the constructorBody rule contexts.
	GetConstructorBody() IBlockContext

	// SetConstructorBody sets the constructorBody rule contexts.
	SetConstructorBody(IBlockContext)

	// Getter signatures
	Identifier() IIdentifierContext
	Block() IBlockContext
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext

	// IsCompactConstructorDeclarationContext differentiates from other interfaces.
	IsCompactConstructorDeclarationContext()
}

type CompactConstructorDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	constructorBody IBlockContext
}

func NewEmptyCompactConstructorDeclarationContext() *CompactConstructorDeclarationContext {
	var p = new(CompactConstructorDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_compactConstructorDeclaration
	return p
}

func InitEmptyCompactConstructorDeclarationContext(p *CompactConstructorDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_compactConstructorDeclaration
}

func (*CompactConstructorDeclarationContext) IsCompactConstructorDeclarationContext() {}

func NewCompactConstructorDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompactConstructorDeclarationContext {
	var p = new(CompactConstructorDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_compactConstructorDeclaration

	return p
}

func (s *CompactConstructorDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *CompactConstructorDeclarationContext) GetConstructorBody() IBlockContext {
	return s.constructorBody
}

func (s *CompactConstructorDeclarationContext) SetConstructorBody(v IBlockContext) {
	s.constructorBody = v
}

func (s *CompactConstructorDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CompactConstructorDeclarationContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CompactConstructorDeclarationContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *CompactConstructorDeclarationContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *CompactConstructorDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompactConstructorDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompactConstructorDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterCompactConstructorDeclaration(s)
	}
}

func (s *CompactConstructorDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitCompactConstructorDeclaration(s)
	}
}

func (s *CompactConstructorDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitCompactConstructorDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) CompactConstructorDeclaration() (localctx ICompactConstructorDeclarationContext) {
	localctx = NewCompactConstructorDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, JavaParserRULE_compactConstructorDeclaration)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(532)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(529)
				p.Modifier()
			}

		}
		p.SetState(534)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(535)
		p.Identifier()
	}
	{
		p.SetState(536)

		var _x = p.Block()

		localctx.(*CompactConstructorDeclarationContext).constructorBody = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldDeclarationContext is an interface to support dynamic dispatch.
type IFieldDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeType() ITypeTypeContext
	VariableDeclarators() IVariableDeclaratorsContext
	SEMI() antlr.TerminalNode

	// IsFieldDeclarationContext differentiates from other interfaces.
	IsFieldDeclarationContext()
}

type FieldDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDeclarationContext() *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_fieldDeclaration
	return p
}

func InitEmptyFieldDeclarationContext(p *FieldDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_fieldDeclaration
}

func (*FieldDeclarationContext) IsFieldDeclarationContext() {}

func NewFieldDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_fieldDeclaration

	return p
}

func (s *FieldDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclarationContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *FieldDeclarationContext) VariableDeclarators() IVariableDeclaratorsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorsContext)
}

func (s *FieldDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *FieldDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterFieldDeclaration(s)
	}
}

func (s *FieldDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitFieldDeclaration(s)
	}
}

func (s *FieldDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitFieldDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) FieldDeclaration() (localctx IFieldDeclarationContext) {
	localctx = NewFieldDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, JavaParserRULE_fieldDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(538)
		p.TypeType()
	}
	{
		p.SetState(539)
		p.VariableDeclarators()
	}
	{
		p.SetState(540)
		p.Match(JavaParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceBodyDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceBodyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InterfaceMemberDeclaration() IInterfaceMemberDeclarationContext
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext
	SEMI() antlr.TerminalNode

	// IsInterfaceBodyDeclarationContext differentiates from other interfaces.
	IsInterfaceBodyDeclarationContext()
}

type InterfaceBodyDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceBodyDeclarationContext() *InterfaceBodyDeclarationContext {
	var p = new(InterfaceBodyDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceBodyDeclaration
	return p
}

func InitEmptyInterfaceBodyDeclarationContext(p *InterfaceBodyDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceBodyDeclaration
}

func (*InterfaceBodyDeclarationContext) IsInterfaceBodyDeclarationContext() {}

func NewInterfaceBodyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceBodyDeclarationContext {
	var p = new(InterfaceBodyDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_interfaceBodyDeclaration

	return p
}

func (s *InterfaceBodyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceBodyDeclarationContext) InterfaceMemberDeclaration() IInterfaceMemberDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMemberDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMemberDeclarationContext)
}

func (s *InterfaceBodyDeclarationContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBodyDeclarationContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *InterfaceBodyDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *InterfaceBodyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceBodyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceBodyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterInterfaceBodyDeclaration(s)
	}
}

func (s *InterfaceBodyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitInterfaceBodyDeclaration(s)
	}
}

func (s *InterfaceBodyDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitInterfaceBodyDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) InterfaceBodyDeclaration() (localctx IInterfaceBodyDeclarationContext) {
	localctx = NewInterfaceBodyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, JavaParserRULE_interfaceBodyDeclaration)
	var _alt int

	p.SetState(550)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserABSTRACT, JavaParserBOOLEAN, JavaParserBYTE, JavaParserCHAR, JavaParserCLASS, JavaParserDEFAULT, JavaParserDOUBLE, JavaParserENUM, JavaParserFINAL, JavaParserFLOAT, JavaParserINT, JavaParserINTERFACE, JavaParserLONG, JavaParserNATIVE, JavaParserPRIVATE, JavaParserPROTECTED, JavaParserPUBLIC, JavaParserSHORT, JavaParserSTATIC, JavaParserSTRICTFP, JavaParserSYNCHRONIZED, JavaParserTRANSIENT, JavaParserVOID, JavaParserVOLATILE, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserNON_SEALED, JavaParserLT, JavaParserAT, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(545)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(542)
					p.Modifier()
				}

			}
			p.SetState(547)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(548)
			p.InterfaceMemberDeclaration()
		}

	case JavaParserSEMI:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(549)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceMemberDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RecordDeclaration() IRecordDeclarationContext
	ConstDeclaration() IConstDeclarationContext
	InterfaceMethodDeclaration() IInterfaceMethodDeclarationContext
	GenericInterfaceMethodDeclaration() IGenericInterfaceMethodDeclarationContext
	InterfaceDeclaration() IInterfaceDeclarationContext
	AnnotationTypeDeclaration() IAnnotationTypeDeclarationContext
	ClassDeclaration() IClassDeclarationContext
	EnumDeclaration() IEnumDeclarationContext

	// IsInterfaceMemberDeclarationContext differentiates from other interfaces.
	IsInterfaceMemberDeclarationContext()
}

type InterfaceMemberDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMemberDeclarationContext() *InterfaceMemberDeclarationContext {
	var p = new(InterfaceMemberDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceMemberDeclaration
	return p
}

func InitEmptyInterfaceMemberDeclarationContext(p *InterfaceMemberDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceMemberDeclaration
}

func (*InterfaceMemberDeclarationContext) IsInterfaceMemberDeclarationContext() {}

func NewInterfaceMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMemberDeclarationContext {
	var p = new(InterfaceMemberDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_interfaceMemberDeclaration

	return p
}

func (s *InterfaceMemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMemberDeclarationContext) RecordDeclaration() IRecordDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) ConstDeclaration() IConstDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) InterfaceMethodDeclaration() IInterfaceMethodDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) GenericInterfaceMethodDeclaration() IGenericInterfaceMethodDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericInterfaceMethodDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericInterfaceMethodDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) AnnotationTypeDeclaration() IAnnotationTypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationTypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationTypeDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterInterfaceMemberDeclaration(s)
	}
}

func (s *InterfaceMemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitInterfaceMemberDeclaration(s)
	}
}

func (s *InterfaceMemberDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitInterfaceMemberDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) InterfaceMemberDeclaration() (localctx IInterfaceMemberDeclarationContext) {
	localctx = NewInterfaceMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, JavaParserRULE_interfaceMemberDeclaration)
	p.SetState(560)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(552)
			p.RecordDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(553)
			p.ConstDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(554)
			p.InterfaceMethodDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(555)
			p.GenericInterfaceMethodDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(556)
			p.InterfaceDeclaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(557)
			p.AnnotationTypeDeclaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(558)
			p.ClassDeclaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(559)
			p.EnumDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstDeclarationContext is an interface to support dynamic dispatch.
type IConstDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeType() ITypeTypeContext
	AllConstantDeclarator() []IConstantDeclaratorContext
	ConstantDeclarator(i int) IConstantDeclaratorContext
	SEMI() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsConstDeclarationContext differentiates from other interfaces.
	IsConstDeclarationContext()
}

type ConstDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstDeclarationContext() *ConstDeclarationContext {
	var p = new(ConstDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_constDeclaration
	return p
}

func InitEmptyConstDeclarationContext(p *ConstDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_constDeclaration
}

func (*ConstDeclarationContext) IsConstDeclarationContext() {}

func NewConstDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstDeclarationContext {
	var p = new(ConstDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_constDeclaration

	return p
}

func (s *ConstDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstDeclarationContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *ConstDeclarationContext) AllConstantDeclarator() []IConstantDeclaratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDeclaratorContext); ok {
			len++
		}
	}

	tst := make([]IConstantDeclaratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDeclaratorContext); ok {
			tst[i] = t.(IConstantDeclaratorContext)
			i++
		}
	}

	return tst
}

func (s *ConstDeclarationContext) ConstantDeclarator(i int) IConstantDeclaratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDeclaratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDeclaratorContext)
}

func (s *ConstDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *ConstDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *ConstDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *ConstDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterConstDeclaration(s)
	}
}

func (s *ConstDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitConstDeclaration(s)
	}
}

func (s *ConstDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitConstDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ConstDeclaration() (localctx IConstDeclarationContext) {
	localctx = NewConstDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, JavaParserRULE_constDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(562)
		p.TypeType()
	}
	{
		p.SetState(563)
		p.ConstantDeclarator()
	}
	p.SetState(568)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCOMMA {
		{
			p.SetState(564)
			p.Match(JavaParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(565)
			p.ConstantDeclarator()
		}

		p.SetState(570)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(571)
		p.Match(JavaParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantDeclaratorContext is an interface to support dynamic dispatch.
type IConstantDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	VariableInitializer() IVariableInitializerContext
	AllLBRACK() []antlr.TerminalNode
	LBRACK(i int) antlr.TerminalNode
	AllRBRACK() []antlr.TerminalNode
	RBRACK(i int) antlr.TerminalNode

	// IsConstantDeclaratorContext differentiates from other interfaces.
	IsConstantDeclaratorContext()
}

type ConstantDeclaratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantDeclaratorContext() *ConstantDeclaratorContext {
	var p = new(ConstantDeclaratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_constantDeclarator
	return p
}

func InitEmptyConstantDeclaratorContext(p *ConstantDeclaratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_constantDeclarator
}

func (*ConstantDeclaratorContext) IsConstantDeclaratorContext() {}

func NewConstantDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantDeclaratorContext {
	var p = new(ConstantDeclaratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_constantDeclarator

	return p
}

func (s *ConstantDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantDeclaratorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstantDeclaratorContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserASSIGN, 0)
}

func (s *ConstantDeclaratorContext) VariableInitializer() IVariableInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *ConstantDeclaratorContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserLBRACK)
}

func (s *ConstantDeclaratorContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACK, i)
}

func (s *ConstantDeclaratorContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserRBRACK)
}

func (s *ConstantDeclaratorContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACK, i)
}

func (s *ConstantDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterConstantDeclarator(s)
	}
}

func (s *ConstantDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitConstantDeclarator(s)
	}
}

func (s *ConstantDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitConstantDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ConstantDeclarator() (localctx IConstantDeclaratorContext) {
	localctx = NewConstantDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, JavaParserRULE_constantDeclarator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(573)
		p.Identifier()
	}
	p.SetState(578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserLBRACK {
		{
			p.SetState(574)
			p.Match(JavaParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(575)
			p.Match(JavaParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(580)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(581)
		p.Match(JavaParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(582)
		p.VariableInitializer()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceMethodDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InterfaceCommonBodyDeclaration() IInterfaceCommonBodyDeclarationContext
	AllInterfaceMethodModifier() []IInterfaceMethodModifierContext
	InterfaceMethodModifier(i int) IInterfaceMethodModifierContext

	// IsInterfaceMethodDeclarationContext differentiates from other interfaces.
	IsInterfaceMethodDeclarationContext()
}

type InterfaceMethodDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMethodDeclarationContext() *InterfaceMethodDeclarationContext {
	var p = new(InterfaceMethodDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceMethodDeclaration
	return p
}

func InitEmptyInterfaceMethodDeclarationContext(p *InterfaceMethodDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceMethodDeclaration
}

func (*InterfaceMethodDeclarationContext) IsInterfaceMethodDeclarationContext() {}

func NewInterfaceMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMethodDeclarationContext {
	var p = new(InterfaceMethodDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_interfaceMethodDeclaration

	return p
}

func (s *InterfaceMethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMethodDeclarationContext) InterfaceCommonBodyDeclaration() IInterfaceCommonBodyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceCommonBodyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceCommonBodyDeclarationContext)
}

func (s *InterfaceMethodDeclarationContext) AllInterfaceMethodModifier() []IInterfaceMethodModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceMethodModifierContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceMethodModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceMethodModifierContext); ok {
			tst[i] = t.(IInterfaceMethodModifierContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceMethodDeclarationContext) InterfaceMethodModifier(i int) IInterfaceMethodModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodModifierContext)
}

func (s *InterfaceMethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterInterfaceMethodDeclaration(s)
	}
}

func (s *InterfaceMethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitInterfaceMethodDeclaration(s)
	}
}

func (s *InterfaceMethodDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitInterfaceMethodDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) InterfaceMethodDeclaration() (localctx IInterfaceMethodDeclarationContext) {
	localctx = NewInterfaceMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, JavaParserRULE_interfaceMethodDeclaration)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(587)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(584)
				p.InterfaceMethodModifier()
			}

		}
		p.SetState(589)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(590)
		p.InterfaceCommonBodyDeclaration()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceMethodModifierContext is an interface to support dynamic dispatch.
type IInterfaceMethodModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext
	PUBLIC() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	STATIC() antlr.TerminalNode
	STRICTFP() antlr.TerminalNode

	// IsInterfaceMethodModifierContext differentiates from other interfaces.
	IsInterfaceMethodModifierContext()
}

type InterfaceMethodModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMethodModifierContext() *InterfaceMethodModifierContext {
	var p = new(InterfaceMethodModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceMethodModifier
	return p
}

func InitEmptyInterfaceMethodModifierContext(p *InterfaceMethodModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceMethodModifier
}

func (*InterfaceMethodModifierContext) IsInterfaceMethodModifierContext() {}

func NewInterfaceMethodModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMethodModifierContext {
	var p = new(InterfaceMethodModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_interfaceMethodModifier

	return p
}

func (s *InterfaceMethodModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMethodModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *InterfaceMethodModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(JavaParserPUBLIC, 0)
}

func (s *InterfaceMethodModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(JavaParserABSTRACT, 0)
}

func (s *InterfaceMethodModifierContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(JavaParserDEFAULT, 0)
}

func (s *InterfaceMethodModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(JavaParserSTATIC, 0)
}

func (s *InterfaceMethodModifierContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(JavaParserSTRICTFP, 0)
}

func (s *InterfaceMethodModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMethodModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMethodModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterInterfaceMethodModifier(s)
	}
}

func (s *InterfaceMethodModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitInterfaceMethodModifier(s)
	}
}

func (s *InterfaceMethodModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitInterfaceMethodModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) InterfaceMethodModifier() (localctx IInterfaceMethodModifierContext) {
	localctx = NewInterfaceMethodModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, JavaParserRULE_interfaceMethodModifier)
	p.SetState(598)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserAT, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(592)
			p.Annotation()
		}

	case JavaParserPUBLIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(593)
			p.Match(JavaParserPUBLIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaParserABSTRACT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(594)
			p.Match(JavaParserABSTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaParserDEFAULT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(595)
			p.Match(JavaParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaParserSTATIC:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(596)
			p.Match(JavaParserSTATIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaParserSTRICTFP:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(597)
			p.Match(JavaParserSTRICTFP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericInterfaceMethodDeclarationContext is an interface to support dynamic dispatch.
type IGenericInterfaceMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeParameters() ITypeParametersContext
	InterfaceCommonBodyDeclaration() IInterfaceCommonBodyDeclarationContext
	AllInterfaceMethodModifier() []IInterfaceMethodModifierContext
	InterfaceMethodModifier(i int) IInterfaceMethodModifierContext

	// IsGenericInterfaceMethodDeclarationContext differentiates from other interfaces.
	IsGenericInterfaceMethodDeclarationContext()
}

type GenericInterfaceMethodDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericInterfaceMethodDeclarationContext() *GenericInterfaceMethodDeclarationContext {
	var p = new(GenericInterfaceMethodDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_genericInterfaceMethodDeclaration
	return p
}

func InitEmptyGenericInterfaceMethodDeclarationContext(p *GenericInterfaceMethodDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_genericInterfaceMethodDeclaration
}

func (*GenericInterfaceMethodDeclarationContext) IsGenericInterfaceMethodDeclarationContext() {}

func NewGenericInterfaceMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericInterfaceMethodDeclarationContext {
	var p = new(GenericInterfaceMethodDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_genericInterfaceMethodDeclaration

	return p
}

func (s *GenericInterfaceMethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericInterfaceMethodDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *GenericInterfaceMethodDeclarationContext) InterfaceCommonBodyDeclaration() IInterfaceCommonBodyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceCommonBodyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceCommonBodyDeclarationContext)
}

func (s *GenericInterfaceMethodDeclarationContext) AllInterfaceMethodModifier() []IInterfaceMethodModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceMethodModifierContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceMethodModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceMethodModifierContext); ok {
			tst[i] = t.(IInterfaceMethodModifierContext)
			i++
		}
	}

	return tst
}

func (s *GenericInterfaceMethodDeclarationContext) InterfaceMethodModifier(i int) IInterfaceMethodModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodModifierContext)
}

func (s *GenericInterfaceMethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericInterfaceMethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericInterfaceMethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterGenericInterfaceMethodDeclaration(s)
	}
}

func (s *GenericInterfaceMethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitGenericInterfaceMethodDeclaration(s)
	}
}

func (s *GenericInterfaceMethodDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitGenericInterfaceMethodDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) GenericInterfaceMethodDeclaration() (localctx IGenericInterfaceMethodDeclarationContext) {
	localctx = NewGenericInterfaceMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, JavaParserRULE_genericInterfaceMethodDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-1125470410110975) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-8935141660703064063) != 0) {
		{
			p.SetState(600)
			p.InterfaceMethodModifier()
		}

		p.SetState(605)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(606)
		p.TypeParameters()
	}
	{
		p.SetState(607)
		p.InterfaceCommonBodyDeclaration()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceCommonBodyDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceCommonBodyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeTypeOrVoid() ITypeTypeOrVoidContext
	Identifier() IIdentifierContext
	FormalParameters() IFormalParametersContext
	MethodBody() IMethodBodyContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	AllLBRACK() []antlr.TerminalNode
	LBRACK(i int) antlr.TerminalNode
	AllRBRACK() []antlr.TerminalNode
	RBRACK(i int) antlr.TerminalNode
	THROWS() antlr.TerminalNode
	QualifiedNameList() IQualifiedNameListContext

	// IsInterfaceCommonBodyDeclarationContext differentiates from other interfaces.
	IsInterfaceCommonBodyDeclarationContext()
}

type InterfaceCommonBodyDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceCommonBodyDeclarationContext() *InterfaceCommonBodyDeclarationContext {
	var p = new(InterfaceCommonBodyDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceCommonBodyDeclaration
	return p
}

func InitEmptyInterfaceCommonBodyDeclarationContext(p *InterfaceCommonBodyDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_interfaceCommonBodyDeclaration
}

func (*InterfaceCommonBodyDeclarationContext) IsInterfaceCommonBodyDeclarationContext() {}

func NewInterfaceCommonBodyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceCommonBodyDeclarationContext {
	var p = new(InterfaceCommonBodyDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_interfaceCommonBodyDeclaration

	return p
}

func (s *InterfaceCommonBodyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceCommonBodyDeclarationContext) TypeTypeOrVoid() ITypeTypeOrVoidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeOrVoidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeOrVoidContext)
}

func (s *InterfaceCommonBodyDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InterfaceCommonBodyDeclarationContext) FormalParameters() IFormalParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *InterfaceCommonBodyDeclarationContext) MethodBody() IMethodBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *InterfaceCommonBodyDeclarationContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceCommonBodyDeclarationContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *InterfaceCommonBodyDeclarationContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserLBRACK)
}

func (s *InterfaceCommonBodyDeclarationContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACK, i)
}

func (s *InterfaceCommonBodyDeclarationContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserRBRACK)
}

func (s *InterfaceCommonBodyDeclarationContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACK, i)
}

func (s *InterfaceCommonBodyDeclarationContext) THROWS() antlr.TerminalNode {
	return s.GetToken(JavaParserTHROWS, 0)
}

func (s *InterfaceCommonBodyDeclarationContext) QualifiedNameList() IQualifiedNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameListContext)
}

func (s *InterfaceCommonBodyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceCommonBodyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceCommonBodyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterInterfaceCommonBodyDeclaration(s)
	}
}

func (s *InterfaceCommonBodyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitInterfaceCommonBodyDeclaration(s)
	}
}

func (s *InterfaceCommonBodyDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitInterfaceCommonBodyDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) InterfaceCommonBodyDeclaration() (localctx IInterfaceCommonBodyDeclarationContext) {
	localctx = NewInterfaceCommonBodyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, JavaParserRULE_interfaceCommonBodyDeclaration)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(609)
				p.Annotation()
			}

		}
		p.SetState(614)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(615)
		p.TypeTypeOrVoid()
	}
	{
		p.SetState(616)
		p.Identifier()
	}
	{
		p.SetState(617)
		p.FormalParameters()
	}
	p.SetState(622)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserLBRACK {
		{
			p.SetState(618)
			p.Match(JavaParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(619)
			p.Match(JavaParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(624)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(627)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserTHROWS {
		{
			p.SetState(625)
			p.Match(JavaParserTHROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(626)
			p.QualifiedNameList()
		}

	}
	{
		p.SetState(629)
		p.MethodBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclaratorsContext is an interface to support dynamic dispatch.
type IVariableDeclaratorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableDeclarator() []IVariableDeclaratorContext
	VariableDeclarator(i int) IVariableDeclaratorContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsVariableDeclaratorsContext differentiates from other interfaces.
	IsVariableDeclaratorsContext()
}

type VariableDeclaratorsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorsContext() *VariableDeclaratorsContext {
	var p = new(VariableDeclaratorsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_variableDeclarators
	return p
}

func InitEmptyVariableDeclaratorsContext(p *VariableDeclaratorsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_variableDeclarators
}

func (*VariableDeclaratorsContext) IsVariableDeclaratorsContext() {}

func NewVariableDeclaratorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorsContext {
	var p = new(VariableDeclaratorsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_variableDeclarators

	return p
}

func (s *VariableDeclaratorsContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorsContext) AllVariableDeclarator() []IVariableDeclaratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclaratorContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclaratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclaratorContext); ok {
			tst[i] = t.(IVariableDeclaratorContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclaratorsContext) VariableDeclarator(i int) IVariableDeclaratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorContext)
}

func (s *VariableDeclaratorsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *VariableDeclaratorsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *VariableDeclaratorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterVariableDeclarators(s)
	}
}

func (s *VariableDeclaratorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitVariableDeclarators(s)
	}
}

func (s *VariableDeclaratorsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitVariableDeclarators(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) VariableDeclarators() (localctx IVariableDeclaratorsContext) {
	localctx = NewVariableDeclaratorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, JavaParserRULE_variableDeclarators)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(631)
		p.VariableDeclarator()
	}
	p.SetState(636)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCOMMA {
		{
			p.SetState(632)
			p.Match(JavaParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(633)
			p.VariableDeclarator()
		}

		p.SetState(638)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclaratorContext is an interface to support dynamic dispatch.
type IVariableDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDeclaratorId() IVariableDeclaratorIdContext
	ASSIGN() antlr.TerminalNode
	VariableInitializer() IVariableInitializerContext

	// IsVariableDeclaratorContext differentiates from other interfaces.
	IsVariableDeclaratorContext()
}

type VariableDeclaratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorContext() *VariableDeclaratorContext {
	var p = new(VariableDeclaratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_variableDeclarator
	return p
}

func InitEmptyVariableDeclaratorContext(p *VariableDeclaratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_variableDeclarator
}

func (*VariableDeclaratorContext) IsVariableDeclaratorContext() {}

func NewVariableDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorContext {
	var p = new(VariableDeclaratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_variableDeclarator

	return p
}

func (s *VariableDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *VariableDeclaratorContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserASSIGN, 0)
}

func (s *VariableDeclaratorContext) VariableInitializer() IVariableInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *VariableDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterVariableDeclarator(s)
	}
}

func (s *VariableDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitVariableDeclarator(s)
	}
}

func (s *VariableDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitVariableDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) VariableDeclarator() (localctx IVariableDeclaratorContext) {
	localctx = NewVariableDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, JavaParserRULE_variableDeclarator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(639)
		p.VariableDeclaratorId()
	}
	p.SetState(642)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserASSIGN {
		{
			p.SetState(640)
			p.Match(JavaParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(641)
			p.VariableInitializer()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclaratorIdContext is an interface to support dynamic dispatch.
type IVariableDeclaratorIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllLBRACK() []antlr.TerminalNode
	LBRACK(i int) antlr.TerminalNode
	AllRBRACK() []antlr.TerminalNode
	RBRACK(i int) antlr.TerminalNode

	// IsVariableDeclaratorIdContext differentiates from other interfaces.
	IsVariableDeclaratorIdContext()
}

type VariableDeclaratorIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorIdContext() *VariableDeclaratorIdContext {
	var p = new(VariableDeclaratorIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_variableDeclaratorId
	return p
}

func InitEmptyVariableDeclaratorIdContext(p *VariableDeclaratorIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_variableDeclaratorId
}

func (*VariableDeclaratorIdContext) IsVariableDeclaratorIdContext() {}

func NewVariableDeclaratorIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorIdContext {
	var p = new(VariableDeclaratorIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_variableDeclaratorId

	return p
}

func (s *VariableDeclaratorIdContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorIdContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableDeclaratorIdContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserLBRACK)
}

func (s *VariableDeclaratorIdContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACK, i)
}

func (s *VariableDeclaratorIdContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserRBRACK)
}

func (s *VariableDeclaratorIdContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACK, i)
}

func (s *VariableDeclaratorIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterVariableDeclaratorId(s)
	}
}

func (s *VariableDeclaratorIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitVariableDeclaratorId(s)
	}
}

func (s *VariableDeclaratorIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitVariableDeclaratorId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) VariableDeclaratorId() (localctx IVariableDeclaratorIdContext) {
	localctx = NewVariableDeclaratorIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, JavaParserRULE_variableDeclaratorId)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(644)
		p.Identifier()
	}
	p.SetState(649)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserLBRACK {
		{
			p.SetState(645)
			p.Match(JavaParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(646)
			p.Match(JavaParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(651)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableInitializerContext is an interface to support dynamic dispatch.
type IVariableInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ArrayInitializer() IArrayInitializerContext
	Expression() IExpressionContext

	// IsVariableInitializerContext differentiates from other interfaces.
	IsVariableInitializerContext()
}

type VariableInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableInitializerContext() *VariableInitializerContext {
	var p = new(VariableInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_variableInitializer
	return p
}

func InitEmptyVariableInitializerContext(p *VariableInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_variableInitializer
}

func (*VariableInitializerContext) IsVariableInitializerContext() {}

func NewVariableInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableInitializerContext {
	var p = new(VariableInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_variableInitializer

	return p
}

func (s *VariableInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableInitializerContext) ArrayInitializer() IArrayInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayInitializerContext)
}

func (s *VariableInitializerContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterVariableInitializer(s)
	}
}

func (s *VariableInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitVariableInitializer(s)
	}
}

func (s *VariableInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitVariableInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) VariableInitializer() (localctx IVariableInitializerContext) {
	localctx = NewVariableInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, JavaParserRULE_variableInitializer)
	p.SetState(654)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserLBRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(652)
			p.ArrayInitializer()
		}

	case JavaParserBOOLEAN, JavaParserBYTE, JavaParserCHAR, JavaParserDOUBLE, JavaParserFLOAT, JavaParserINT, JavaParserLONG, JavaParserNEW, JavaParserSHORT, JavaParserSUPER, JavaParserSWITCH, JavaParserTHIS, JavaParserVOID, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserDECIMAL_LITERAL, JavaParserHEX_LITERAL, JavaParserOCT_LITERAL, JavaParserBINARY_LITERAL, JavaParserFLOAT_LITERAL, JavaParserHEX_FLOAT_LITERAL, JavaParserBOOL_LITERAL, JavaParserCHAR_LITERAL, JavaParserSTRING_LITERAL, JavaParserTEXT_BLOCK, JavaParserNULL_LITERAL, JavaParserLPAREN, JavaParserLT, JavaParserBANG, JavaParserTILDE, JavaParserINC, JavaParserDEC, JavaParserADD, JavaParserSUB, JavaParserAT, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(653)
			p.expression(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayInitializerContext is an interface to support dynamic dispatch.
type IArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllVariableInitializer() []IVariableInitializerContext
	VariableInitializer(i int) IVariableInitializerContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsArrayInitializerContext differentiates from other interfaces.
	IsArrayInitializerContext()
}

type ArrayInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayInitializerContext() *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_arrayInitializer
	return p
}

func InitEmptyArrayInitializerContext(p *ArrayInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_arrayInitializer
}

func (*ArrayInitializerContext) IsArrayInitializerContext() {}

func NewArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_arrayInitializer

	return p
}

func (s *ArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayInitializerContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *ArrayInitializerContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *ArrayInitializerContext) AllVariableInitializer() []IVariableInitializerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			len++
		}
	}

	tst := make([]IVariableInitializerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableInitializerContext); ok {
			tst[i] = t.(IVariableInitializerContext)
			i++
		}
	}

	return tst
}

func (s *ArrayInitializerContext) VariableInitializer(i int) IVariableInitializerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableInitializerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *ArrayInitializerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *ArrayInitializerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *ArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterArrayInitializer(s)
	}
}

func (s *ArrayInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitArrayInitializer(s)
	}
}

func (s *ArrayInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitArrayInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ArrayInitializer() (localctx IArrayInitializerContext) {
	localctx = NewArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, JavaParserRULE_arrayInitializer)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(656)
		p.Match(JavaParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(668)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-3)) & ^0x3f) == 0 && ((int64(1)<<(_la-3))&9223127275610966053) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&2377900732130013183) != 0) {
		{
			p.SetState(657)
			p.VariableInitializer()
		}
		p.SetState(662)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(658)
					p.Match(JavaParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(659)
					p.VariableInitializer()
				}

			}
			p.SetState(664)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(666)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserCOMMA {
			{
				p.SetState(665)
				p.Match(JavaParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(670)
		p.Match(JavaParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IClassOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllTypeArguments() []ITypeArgumentsContext
	TypeArguments(i int) ITypeArgumentsContext

	// IsClassOrInterfaceTypeContext differentiates from other interfaces.
	IsClassOrInterfaceTypeContext()
}

type ClassOrInterfaceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOrInterfaceTypeContext() *ClassOrInterfaceTypeContext {
	var p = new(ClassOrInterfaceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_classOrInterfaceType
	return p
}

func InitEmptyClassOrInterfaceTypeContext(p *ClassOrInterfaceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_classOrInterfaceType
}

func (*ClassOrInterfaceTypeContext) IsClassOrInterfaceTypeContext() {}

func NewClassOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceTypeContext {
	var p = new(ClassOrInterfaceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_classOrInterfaceType

	return p
}

func (s *ClassOrInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ClassOrInterfaceTypeContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ClassOrInterfaceTypeContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassOrInterfaceTypeContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(JavaParserDOT)
}

func (s *ClassOrInterfaceTypeContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserDOT, i)
}

func (s *ClassOrInterfaceTypeContext) AllTypeArguments() []ITypeArgumentsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			len++
		}
	}

	tst := make([]ITypeArgumentsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeArgumentsContext); ok {
			tst[i] = t.(ITypeArgumentsContext)
			i++
		}
	}

	return tst
}

func (s *ClassOrInterfaceTypeContext) TypeArguments(i int) ITypeArgumentsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ClassOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterClassOrInterfaceType(s)
	}
}

func (s *ClassOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitClassOrInterfaceType(s)
	}
}

func (s *ClassOrInterfaceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitClassOrInterfaceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ClassOrInterfaceType() (localctx IClassOrInterfaceTypeContext) {
	localctx = NewClassOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, JavaParserRULE_classOrInterfaceType)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(680)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(672)
				p.Identifier()
			}
			p.SetState(674)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == JavaParserLT {
				{
					p.SetState(673)
					p.TypeArguments()
				}

			}
			{
				p.SetState(676)
				p.Match(JavaParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(682)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(683)
		p.TypeIdentifier()
	}
	p.SetState(685)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(684)
			p.TypeArguments()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeArgumentContext is an interface to support dynamic dispatch.
type ITypeArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeType() ITypeTypeContext
	QUESTION() antlr.TerminalNode
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	EXTENDS() antlr.TerminalNode
	SUPER() antlr.TerminalNode

	// IsTypeArgumentContext differentiates from other interfaces.
	IsTypeArgumentContext()
}

type TypeArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentContext() *TypeArgumentContext {
	var p = new(TypeArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeArgument
	return p
}

func InitEmptyTypeArgumentContext(p *TypeArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeArgument
}

func (*TypeArgumentContext) IsTypeArgumentContext() {}

func NewTypeArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentContext {
	var p = new(TypeArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeArgument

	return p
}

func (s *TypeArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeArgumentContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(JavaParserQUESTION, 0)
}

func (s *TypeArgumentContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *TypeArgumentContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeArgumentContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(JavaParserEXTENDS, 0)
}

func (s *TypeArgumentContext) SUPER() antlr.TerminalNode {
	return s.GetToken(JavaParserSUPER, 0)
}

func (s *TypeArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeArgument(s)
	}
}

func (s *TypeArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeArgument(s)
	}
}

func (s *TypeArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitTypeArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) TypeArgument() (localctx ITypeArgumentContext) {
	localctx = NewTypeArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, JavaParserRULE_typeArgument)
	var _la int

	p.SetState(699)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(687)
			p.TypeType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(691)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64((_la-51)) & ^0x3f) == 0 && ((int64(1)<<(_la-51))&32767) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
			{
				p.SetState(688)
				p.Annotation()
			}

			p.SetState(693)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(694)
			p.Match(JavaParserQUESTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserEXTENDS || _la == JavaParserSUPER {
			{
				p.SetState(695)
				_la = p.GetTokenStream().LA(1)

				if !(_la == JavaParserEXTENDS || _la == JavaParserSUPER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(696)
				p.TypeType()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedNameListContext is an interface to support dynamic dispatch.
type IQualifiedNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsQualifiedNameListContext differentiates from other interfaces.
	IsQualifiedNameListContext()
}

type QualifiedNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameListContext() *QualifiedNameListContext {
	var p = new(QualifiedNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_qualifiedNameList
	return p
}

func InitEmptyQualifiedNameListContext(p *QualifiedNameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_qualifiedNameList
}

func (*QualifiedNameListContext) IsQualifiedNameListContext() {}

func NewQualifiedNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameListContext {
	var p = new(QualifiedNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_qualifiedNameList

	return p
}

func (s *QualifiedNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameListContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameListContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *QualifiedNameListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *QualifiedNameListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *QualifiedNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterQualifiedNameList(s)
	}
}

func (s *QualifiedNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitQualifiedNameList(s)
	}
}

func (s *QualifiedNameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitQualifiedNameList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) QualifiedNameList() (localctx IQualifiedNameListContext) {
	localctx = NewQualifiedNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, JavaParserRULE_qualifiedNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(701)
		p.QualifiedName()
	}
	p.SetState(706)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCOMMA {
		{
			p.SetState(702)
			p.Match(JavaParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(703)
			p.QualifiedName()
		}

		p.SetState(708)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParametersContext is an interface to support dynamic dispatch.
type IFormalParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ReceiverParameter() IReceiverParameterContext
	COMMA() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsFormalParametersContext differentiates from other interfaces.
	IsFormalParametersContext()
}

type FormalParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParametersContext() *FormalParametersContext {
	var p = new(FormalParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_formalParameters
	return p
}

func InitEmptyFormalParametersContext(p *FormalParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_formalParameters
}

func (*FormalParametersContext) IsFormalParametersContext() {}

func NewFormalParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParametersContext {
	var p = new(FormalParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_formalParameters

	return p
}

func (s *FormalParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *FormalParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *FormalParametersContext) ReceiverParameter() IReceiverParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverParameterContext)
}

func (s *FormalParametersContext) COMMA() antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, 0)
}

func (s *FormalParametersContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FormalParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterFormalParameters(s)
	}
}

func (s *FormalParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitFormalParameters(s)
	}
}

func (s *FormalParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitFormalParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) FormalParameters() (localctx IFormalParametersContext) {
	localctx = NewFormalParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, JavaParserRULE_formalParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(709)
		p.Match(JavaParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(721)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.SetState(711)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-3)) & ^0x3f) == 0 && ((int64(1)<<(_la-3))&9223090579141953573) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
			{
				p.SetState(710)
				p.ReceiverParameter()
			}

		}

	case 2:
		{
			p.SetState(713)
			p.ReceiverParameter()
		}
		p.SetState(716)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserCOMMA {
			{
				p.SetState(714)
				p.Match(JavaParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(715)
				p.FormalParameterList()
			}

		}

	case 3:
		p.SetState(719)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-3)) & ^0x3f) == 0 && ((int64(1)<<(_la-3))&9223090579141986341) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
			{
				p.SetState(718)
				p.FormalParameterList()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(723)
		p.Match(JavaParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReceiverParameterContext is an interface to support dynamic dispatch.
type IReceiverParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeType() ITypeTypeContext
	THIS() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsReceiverParameterContext differentiates from other interfaces.
	IsReceiverParameterContext()
}

type ReceiverParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiverParameterContext() *ReceiverParameterContext {
	var p = new(ReceiverParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_receiverParameter
	return p
}

func InitEmptyReceiverParameterContext(p *ReceiverParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_receiverParameter
}

func (*ReceiverParameterContext) IsReceiverParameterContext() {}

func NewReceiverParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiverParameterContext {
	var p = new(ReceiverParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_receiverParameter

	return p
}

func (s *ReceiverParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiverParameterContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *ReceiverParameterContext) THIS() antlr.TerminalNode {
	return s.GetToken(JavaParserTHIS, 0)
}

func (s *ReceiverParameterContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ReceiverParameterContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReceiverParameterContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(JavaParserDOT)
}

func (s *ReceiverParameterContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserDOT, i)
}

func (s *ReceiverParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiverParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiverParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterReceiverParameter(s)
	}
}

func (s *ReceiverParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitReceiverParameter(s)
	}
}

func (s *ReceiverParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitReceiverParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ReceiverParameter() (localctx IReceiverParameterContext) {
	localctx = NewReceiverParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, JavaParserRULE_receiverParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(725)
		p.TypeType()
	}
	p.SetState(731)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-51)) & ^0x3f) == 0 && ((int64(1)<<(_la-51))&32767) != 0) || _la == JavaParserIDENTIFIER {
		{
			p.SetState(726)
			p.Identifier()
		}
		{
			p.SetState(727)
			p.Match(JavaParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(733)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(734)
		p.Match(JavaParserTHIS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFormalParameter() []IFormalParameterContext
	FormalParameter(i int) IFormalParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	LastFormalParameter() ILastFormalParameterContext

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_formalParameterList
	return p
}

func InitEmptyFormalParameterListContext(p *FormalParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_formalParameterList
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) AllFormalParameter() []IFormalParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterContext); ok {
			tst[i] = t.(IFormalParameterContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameter(i int) IFormalParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterContext)
}

func (s *FormalParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *FormalParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *FormalParameterListContext) LastFormalParameter() ILastFormalParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILastFormalParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILastFormalParameterContext)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitFormalParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) FormalParameterList() (localctx IFormalParameterListContext) {
	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, JavaParserRULE_formalParameterList)
	var _la int

	var _alt int

	p.SetState(749)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(736)
			p.FormalParameter()
		}
		p.SetState(741)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(737)
					p.Match(JavaParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(738)
					p.FormalParameter()
				}

			}
			p.SetState(743)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserCOMMA {
			{
				p.SetState(744)
				p.Match(JavaParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(745)
				p.LastFormalParameter()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(748)
			p.LastFormalParameter()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterContext is an interface to support dynamic dispatch.
type IFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeType() ITypeTypeContext
	VariableDeclaratorId() IVariableDeclaratorIdContext
	AllVariableModifier() []IVariableModifierContext
	VariableModifier(i int) IVariableModifierContext

	// IsFormalParameterContext differentiates from other interfaces.
	IsFormalParameterContext()
}

type FormalParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterContext() *FormalParameterContext {
	var p = new(FormalParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_formalParameter
	return p
}

func InitEmptyFormalParameterContext(p *FormalParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_formalParameter
}

func (*FormalParameterContext) IsFormalParameterContext() {}

func NewFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterContext {
	var p = new(FormalParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_formalParameter

	return p
}

func (s *FormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *FormalParameterContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *FormalParameterContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *FormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterFormalParameter(s)
	}
}

func (s *FormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitFormalParameter(s)
	}
}

func (s *FormalParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitFormalParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) FormalParameter() (localctx IFormalParameterContext) {
	localctx = NewFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, JavaParserRULE_formalParameter)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(754)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(751)
				p.VariableModifier()
			}

		}
		p.SetState(756)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(757)
		p.TypeType()
	}
	{
		p.SetState(758)
		p.VariableDeclaratorId()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILastFormalParameterContext is an interface to support dynamic dispatch.
type ILastFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeType() ITypeTypeContext
	ELLIPSIS() antlr.TerminalNode
	VariableDeclaratorId() IVariableDeclaratorIdContext
	AllVariableModifier() []IVariableModifierContext
	VariableModifier(i int) IVariableModifierContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext

	// IsLastFormalParameterContext differentiates from other interfaces.
	IsLastFormalParameterContext()
}

type LastFormalParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLastFormalParameterContext() *LastFormalParameterContext {
	var p = new(LastFormalParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_lastFormalParameter
	return p
}

func InitEmptyLastFormalParameterContext(p *LastFormalParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_lastFormalParameter
}

func (*LastFormalParameterContext) IsLastFormalParameterContext() {}

func NewLastFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LastFormalParameterContext {
	var p = new(LastFormalParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_lastFormalParameter

	return p
}

func (s *LastFormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *LastFormalParameterContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *LastFormalParameterContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(JavaParserELLIPSIS, 0)
}

func (s *LastFormalParameterContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *LastFormalParameterContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *LastFormalParameterContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *LastFormalParameterContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *LastFormalParameterContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *LastFormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LastFormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LastFormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterLastFormalParameter(s)
	}
}

func (s *LastFormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitLastFormalParameter(s)
	}
}

func (s *LastFormalParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitLastFormalParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) LastFormalParameter() (localctx ILastFormalParameterContext) {
	localctx = NewLastFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, JavaParserRULE_lastFormalParameter)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(763)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(760)
				p.VariableModifier()
			}

		}
		p.SetState(765)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(766)
		p.TypeType()
	}
	p.SetState(770)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-51)) & ^0x3f) == 0 && ((int64(1)<<(_la-51))&32767) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
		{
			p.SetState(767)
			p.Annotation()
		}

		p.SetState(772)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(773)
		p.Match(JavaParserELLIPSIS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(774)
		p.VariableDeclaratorId()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaLVTIListContext is an interface to support dynamic dispatch.
type ILambdaLVTIListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLambdaLVTIParameter() []ILambdaLVTIParameterContext
	LambdaLVTIParameter(i int) ILambdaLVTIParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLambdaLVTIListContext differentiates from other interfaces.
	IsLambdaLVTIListContext()
}

type LambdaLVTIListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaLVTIListContext() *LambdaLVTIListContext {
	var p = new(LambdaLVTIListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_lambdaLVTIList
	return p
}

func InitEmptyLambdaLVTIListContext(p *LambdaLVTIListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_lambdaLVTIList
}

func (*LambdaLVTIListContext) IsLambdaLVTIListContext() {}

func NewLambdaLVTIListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaLVTIListContext {
	var p = new(LambdaLVTIListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_lambdaLVTIList

	return p
}

func (s *LambdaLVTIListContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaLVTIListContext) AllLambdaLVTIParameter() []ILambdaLVTIParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILambdaLVTIParameterContext); ok {
			len++
		}
	}

	tst := make([]ILambdaLVTIParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILambdaLVTIParameterContext); ok {
			tst[i] = t.(ILambdaLVTIParameterContext)
			i++
		}
	}

	return tst
}

func (s *LambdaLVTIListContext) LambdaLVTIParameter(i int) ILambdaLVTIParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaLVTIParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaLVTIParameterContext)
}

func (s *LambdaLVTIListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *LambdaLVTIListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *LambdaLVTIListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaLVTIListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaLVTIListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterLambdaLVTIList(s)
	}
}

func (s *LambdaLVTIListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitLambdaLVTIList(s)
	}
}

func (s *LambdaLVTIListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitLambdaLVTIList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) LambdaLVTIList() (localctx ILambdaLVTIListContext) {
	localctx = NewLambdaLVTIListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, JavaParserRULE_lambdaLVTIList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(776)
		p.LambdaLVTIParameter()
	}
	p.SetState(781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCOMMA {
		{
			p.SetState(777)
			p.Match(JavaParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(778)
			p.LambdaLVTIParameter()
		}

		p.SetState(783)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaLVTIParameterContext is an interface to support dynamic dispatch.
type ILambdaLVTIParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VAR() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllVariableModifier() []IVariableModifierContext
	VariableModifier(i int) IVariableModifierContext

	// IsLambdaLVTIParameterContext differentiates from other interfaces.
	IsLambdaLVTIParameterContext()
}

type LambdaLVTIParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaLVTIParameterContext() *LambdaLVTIParameterContext {
	var p = new(LambdaLVTIParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_lambdaLVTIParameter
	return p
}

func InitEmptyLambdaLVTIParameterContext(p *LambdaLVTIParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_lambdaLVTIParameter
}

func (*LambdaLVTIParameterContext) IsLambdaLVTIParameterContext() {}

func NewLambdaLVTIParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaLVTIParameterContext {
	var p = new(LambdaLVTIParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_lambdaLVTIParameter

	return p
}

func (s *LambdaLVTIParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaLVTIParameterContext) VAR() antlr.TerminalNode {
	return s.GetToken(JavaParserVAR, 0)
}

func (s *LambdaLVTIParameterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaLVTIParameterContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *LambdaLVTIParameterContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *LambdaLVTIParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaLVTIParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaLVTIParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterLambdaLVTIParameter(s)
	}
}

func (s *LambdaLVTIParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitLambdaLVTIParameter(s)
	}
}

func (s *LambdaLVTIParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitLambdaLVTIParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) LambdaLVTIParameter() (localctx ILambdaLVTIParameterContext) {
	localctx = NewLambdaLVTIParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, JavaParserRULE_lambdaLVTIParameter)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(787)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(784)
				p.VariableModifier()
			}

		}
		p.SetState(789)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(790)
		p.Match(JavaParserVAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(791)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_qualifiedName
	return p
}

func InitEmptyQualifiedNameContext(p *QualifiedNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_qualifiedName
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(JavaParserDOT)
}

func (s *QualifiedNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserDOT, i)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}

func (s *QualifiedNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitQualifiedName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, JavaParserRULE_qualifiedName)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(793)
		p.Identifier()
	}
	p.SetState(798)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(794)
				p.Match(JavaParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(795)
				p.Identifier()
			}

		}
		p.SetState(800)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntegerLiteral() IIntegerLiteralContext
	FloatLiteral() IFloatLiteralContext
	CHAR_LITERAL() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	BOOL_LITERAL() antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	TEXT_BLOCK() antlr.TerminalNode

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *LiteralContext) FloatLiteral() IFloatLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatLiteralContext)
}

func (s *LiteralContext) CHAR_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserCHAR_LITERAL, 0)
}

func (s *LiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserSTRING_LITERAL, 0)
}

func (s *LiteralContext) BOOL_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserBOOL_LITERAL, 0)
}

func (s *LiteralContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserNULL_LITERAL, 0)
}

func (s *LiteralContext) TEXT_BLOCK() antlr.TerminalNode {
	return s.GetToken(JavaParserTEXT_BLOCK, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, JavaParserRULE_literal)
	p.SetState(808)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserDECIMAL_LITERAL, JavaParserHEX_LITERAL, JavaParserOCT_LITERAL, JavaParserBINARY_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(801)
			p.IntegerLiteral()
		}

	case JavaParserFLOAT_LITERAL, JavaParserHEX_FLOAT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(802)
			p.FloatLiteral()
		}

	case JavaParserCHAR_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(803)
			p.Match(JavaParserCHAR_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(804)
			p.Match(JavaParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaParserBOOL_LITERAL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(805)
			p.Match(JavaParserBOOL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaParserNULL_LITERAL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(806)
			p.Match(JavaParserNULL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaParserTEXT_BLOCK:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(807)
			p.Match(JavaParserTEXT_BLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntegerLiteralContext is an interface to support dynamic dispatch.
type IIntegerLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECIMAL_LITERAL() antlr.TerminalNode
	HEX_LITERAL() antlr.TerminalNode
	OCT_LITERAL() antlr.TerminalNode
	BINARY_LITERAL() antlr.TerminalNode

	// IsIntegerLiteralContext differentiates from other interfaces.
	IsIntegerLiteralContext()
}

type IntegerLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerLiteralContext() *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_integerLiteral
	return p
}

func InitEmptyIntegerLiteralContext(p *IntegerLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_integerLiteral
}

func (*IntegerLiteralContext) IsIntegerLiteralContext() {}

func NewIntegerLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_integerLiteral

	return p
}

func (s *IntegerLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerLiteralContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserDECIMAL_LITERAL, 0)
}

func (s *IntegerLiteralContext) HEX_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserHEX_LITERAL, 0)
}

func (s *IntegerLiteralContext) OCT_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserOCT_LITERAL, 0)
}

func (s *IntegerLiteralContext) BINARY_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserBINARY_LITERAL, 0)
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitIntegerLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) IntegerLiteral() (localctx IIntegerLiteralContext) {
	localctx = NewIntegerLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, JavaParserRULE_integerLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(810)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFloatLiteralContext is an interface to support dynamic dispatch.
type IFloatLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOAT_LITERAL() antlr.TerminalNode
	HEX_FLOAT_LITERAL() antlr.TerminalNode

	// IsFloatLiteralContext differentiates from other interfaces.
	IsFloatLiteralContext()
}

type FloatLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloatLiteralContext() *FloatLiteralContext {
	var p = new(FloatLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_floatLiteral
	return p
}

func InitEmptyFloatLiteralContext(p *FloatLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_floatLiteral
}

func (*FloatLiteralContext) IsFloatLiteralContext() {}

func NewFloatLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloatLiteralContext {
	var p = new(FloatLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_floatLiteral

	return p
}

func (s *FloatLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *FloatLiteralContext) FLOAT_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserFLOAT_LITERAL, 0)
}

func (s *FloatLiteralContext) HEX_FLOAT_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserHEX_FLOAT_LITERAL, 0)
}

func (s *FloatLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FloatLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterFloatLiteral(s)
	}
}

func (s *FloatLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitFloatLiteral(s)
	}
}

func (s *FloatLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitFloatLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) FloatLiteral() (localctx IFloatLiteralContext) {
	localctx = NewFloatLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, JavaParserRULE_floatLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(812)
		_la = p.GetTokenStream().LA(1)

		if !(_la == JavaParserFLOAT_LITERAL || _la == JavaParserHEX_FLOAT_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAltAnnotationQualifiedNameContext is an interface to support dynamic dispatch.
type IAltAnnotationQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsAltAnnotationQualifiedNameContext differentiates from other interfaces.
	IsAltAnnotationQualifiedNameContext()
}

type AltAnnotationQualifiedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAltAnnotationQualifiedNameContext() *AltAnnotationQualifiedNameContext {
	var p = new(AltAnnotationQualifiedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_altAnnotationQualifiedName
	return p
}

func InitEmptyAltAnnotationQualifiedNameContext(p *AltAnnotationQualifiedNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_altAnnotationQualifiedName
}

func (*AltAnnotationQualifiedNameContext) IsAltAnnotationQualifiedNameContext() {}

func NewAltAnnotationQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AltAnnotationQualifiedNameContext {
	var p = new(AltAnnotationQualifiedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_altAnnotationQualifiedName

	return p
}

func (s *AltAnnotationQualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AltAnnotationQualifiedNameContext) AT() antlr.TerminalNode {
	return s.GetToken(JavaParserAT, 0)
}

func (s *AltAnnotationQualifiedNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AltAnnotationQualifiedNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AltAnnotationQualifiedNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(JavaParserDOT)
}

func (s *AltAnnotationQualifiedNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserDOT, i)
}

func (s *AltAnnotationQualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AltAnnotationQualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AltAnnotationQualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterAltAnnotationQualifiedName(s)
	}
}

func (s *AltAnnotationQualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitAltAnnotationQualifiedName(s)
	}
}

func (s *AltAnnotationQualifiedNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitAltAnnotationQualifiedName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) AltAnnotationQualifiedName() (localctx IAltAnnotationQualifiedNameContext) {
	localctx = NewAltAnnotationQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, JavaParserRULE_altAnnotationQualifiedName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(819)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-51)) & ^0x3f) == 0 && ((int64(1)<<(_la-51))&32767) != 0) || _la == JavaParserIDENTIFIER {
		{
			p.SetState(814)
			p.Identifier()
		}
		{
			p.SetState(815)
			p.Match(JavaParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(821)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(822)
		p.Match(JavaParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(823)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AltAnnotationQualifiedName() IAltAnnotationQualifiedNameContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ElementValuePairs() IElementValuePairsContext
	ElementValue() IElementValueContext

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_annotation
	return p
}

func InitEmptyAnnotationContext(p *AnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_annotation
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) AT() antlr.TerminalNode {
	return s.GetToken(JavaParserAT, 0)
}

func (s *AnnotationContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AnnotationContext) AltAnnotationQualifiedName() IAltAnnotationQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAltAnnotationQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAltAnnotationQualifiedNameContext)
}

func (s *AnnotationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *AnnotationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *AnnotationContext) ElementValuePairs() IElementValuePairsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValuePairsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValuePairsContext)
}

func (s *AnnotationContext) ElementValue() IElementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (s *AnnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitAnnotation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, JavaParserRULE_annotation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(825)
			p.Match(JavaParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(826)
			p.QualifiedName()
		}

	case 2:
		{
			p.SetState(827)
			p.AltAnnotationQualifiedName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(836)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserLPAREN {
		{
			p.SetState(830)
			p.Match(JavaParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(833)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(831)
				p.ElementValuePairs()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(832)
				p.ElementValue()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(835)
			p.Match(JavaParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementValuePairsContext is an interface to support dynamic dispatch.
type IElementValuePairsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllElementValuePair() []IElementValuePairContext
	ElementValuePair(i int) IElementValuePairContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsElementValuePairsContext differentiates from other interfaces.
	IsElementValuePairsContext()
}

type ElementValuePairsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairsContext() *ElementValuePairsContext {
	var p = new(ElementValuePairsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_elementValuePairs
	return p
}

func InitEmptyElementValuePairsContext(p *ElementValuePairsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_elementValuePairs
}

func (*ElementValuePairsContext) IsElementValuePairsContext() {}

func NewElementValuePairsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairsContext {
	var p = new(ElementValuePairsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_elementValuePairs

	return p
}

func (s *ElementValuePairsContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairsContext) AllElementValuePair() []IElementValuePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementValuePairContext); ok {
			len++
		}
	}

	tst := make([]IElementValuePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementValuePairContext); ok {
			tst[i] = t.(IElementValuePairContext)
			i++
		}
	}

	return tst
}

func (s *ElementValuePairsContext) ElementValuePair(i int) IElementValuePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValuePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValuePairContext)
}

func (s *ElementValuePairsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *ElementValuePairsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *ElementValuePairsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterElementValuePairs(s)
	}
}

func (s *ElementValuePairsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitElementValuePairs(s)
	}
}

func (s *ElementValuePairsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitElementValuePairs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ElementValuePairs() (localctx IElementValuePairsContext) {
	localctx = NewElementValuePairsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, JavaParserRULE_elementValuePairs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(838)
		p.ElementValuePair()
	}
	p.SetState(843)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCOMMA {
		{
			p.SetState(839)
			p.Match(JavaParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(840)
			p.ElementValuePair()
		}

		p.SetState(845)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementValuePairContext is an interface to support dynamic dispatch.
type IElementValuePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	ElementValue() IElementValueContext

	// IsElementValuePairContext differentiates from other interfaces.
	IsElementValuePairContext()
}

type ElementValuePairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairContext() *ElementValuePairContext {
	var p = new(ElementValuePairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_elementValuePair
	return p
}

func InitEmptyElementValuePairContext(p *ElementValuePairContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_elementValuePair
}

func (*ElementValuePairContext) IsElementValuePairContext() {}

func NewElementValuePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairContext {
	var p = new(ElementValuePairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_elementValuePair

	return p
}

func (s *ElementValuePairContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ElementValuePairContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserASSIGN, 0)
}

func (s *ElementValuePairContext) ElementValue() IElementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValuePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterElementValuePair(s)
	}
}

func (s *ElementValuePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitElementValuePair(s)
	}
}

func (s *ElementValuePairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitElementValuePair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ElementValuePair() (localctx IElementValuePairContext) {
	localctx = NewElementValuePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, JavaParserRULE_elementValuePair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(846)
		p.Identifier()
	}
	{
		p.SetState(847)
		p.Match(JavaParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(848)
		p.ElementValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementValueContext is an interface to support dynamic dispatch.
type IElementValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Annotation() IAnnotationContext
	ElementValueArrayInitializer() IElementValueArrayInitializerContext

	// IsElementValueContext differentiates from other interfaces.
	IsElementValueContext()
}

type ElementValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueContext() *ElementValueContext {
	var p = new(ElementValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_elementValue
	return p
}

func InitEmptyElementValueContext(p *ElementValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_elementValue
}

func (*ElementValueContext) IsElementValueContext() {}

func NewElementValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueContext {
	var p = new(ElementValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_elementValue

	return p
}

func (s *ElementValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElementValueContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ElementValueContext) ElementValueArrayInitializer() IElementValueArrayInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueArrayInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueArrayInitializerContext)
}

func (s *ElementValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterElementValue(s)
	}
}

func (s *ElementValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitElementValue(s)
	}
}

func (s *ElementValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitElementValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ElementValue() (localctx IElementValueContext) {
	localctx = NewElementValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, JavaParserRULE_elementValue)
	p.SetState(853)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(850)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(851)
			p.Annotation()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(852)
			p.ElementValueArrayInitializer()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementValueArrayInitializerContext is an interface to support dynamic dispatch.
type IElementValueArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllElementValue() []IElementValueContext
	ElementValue(i int) IElementValueContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsElementValueArrayInitializerContext differentiates from other interfaces.
	IsElementValueArrayInitializerContext()
}

type ElementValueArrayInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueArrayInitializerContext() *ElementValueArrayInitializerContext {
	var p = new(ElementValueArrayInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_elementValueArrayInitializer
	return p
}

func InitEmptyElementValueArrayInitializerContext(p *ElementValueArrayInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_elementValueArrayInitializer
}

func (*ElementValueArrayInitializerContext) IsElementValueArrayInitializerContext() {}

func NewElementValueArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueArrayInitializerContext {
	var p = new(ElementValueArrayInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_elementValueArrayInitializer

	return p
}

func (s *ElementValueArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueArrayInitializerContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *ElementValueArrayInitializerContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *ElementValueArrayInitializerContext) AllElementValue() []IElementValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementValueContext); ok {
			len++
		}
	}

	tst := make([]IElementValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementValueContext); ok {
			tst[i] = t.(IElementValueContext)
			i++
		}
	}

	return tst
}

func (s *ElementValueArrayInitializerContext) ElementValue(i int) IElementValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValueArrayInitializerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *ElementValueArrayInitializerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *ElementValueArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValueArrayInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterElementValueArrayInitializer(s)
	}
}

func (s *ElementValueArrayInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitElementValueArrayInitializer(s)
	}
}

func (s *ElementValueArrayInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitElementValueArrayInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ElementValueArrayInitializer() (localctx IElementValueArrayInitializerContext) {
	localctx = NewElementValueArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, JavaParserRULE_elementValueArrayInitializer)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(855)
		p.Match(JavaParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(864)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-3)) & ^0x3f) == 0 && ((int64(1)<<(_la-3))&9223127275610966053) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&2377900732130013183) != 0) {
		{
			p.SetState(856)
			p.ElementValue()
		}
		p.SetState(861)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(857)
					p.Match(JavaParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(858)
					p.ElementValue()
				}

			}
			p.SetState(863)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	}
	p.SetState(867)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserCOMMA {
		{
			p.SetState(866)
			p.Match(JavaParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(869)
		p.Match(JavaParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationTypeDeclarationContext is an interface to support dynamic dispatch.
type IAnnotationTypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	INTERFACE() antlr.TerminalNode
	Identifier() IIdentifierContext
	AnnotationTypeBody() IAnnotationTypeBodyContext

	// IsAnnotationTypeDeclarationContext differentiates from other interfaces.
	IsAnnotationTypeDeclarationContext()
}

type AnnotationTypeDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationTypeDeclarationContext() *AnnotationTypeDeclarationContext {
	var p = new(AnnotationTypeDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_annotationTypeDeclaration
	return p
}

func InitEmptyAnnotationTypeDeclarationContext(p *AnnotationTypeDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_annotationTypeDeclaration
}

func (*AnnotationTypeDeclarationContext) IsAnnotationTypeDeclarationContext() {}

func NewAnnotationTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationTypeDeclarationContext {
	var p = new(AnnotationTypeDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_annotationTypeDeclaration

	return p
}

func (s *AnnotationTypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationTypeDeclarationContext) AT() antlr.TerminalNode {
	return s.GetToken(JavaParserAT, 0)
}

func (s *AnnotationTypeDeclarationContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(JavaParserINTERFACE, 0)
}

func (s *AnnotationTypeDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AnnotationTypeDeclarationContext) AnnotationTypeBody() IAnnotationTypeBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationTypeBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationTypeBodyContext)
}

func (s *AnnotationTypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationTypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationTypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterAnnotationTypeDeclaration(s)
	}
}

func (s *AnnotationTypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitAnnotationTypeDeclaration(s)
	}
}

func (s *AnnotationTypeDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitAnnotationTypeDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) AnnotationTypeDeclaration() (localctx IAnnotationTypeDeclarationContext) {
	localctx = NewAnnotationTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, JavaParserRULE_annotationTypeDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(871)
		p.Match(JavaParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(872)
		p.Match(JavaParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(873)
		p.Identifier()
	}
	{
		p.SetState(874)
		p.AnnotationTypeBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationTypeBodyContext is an interface to support dynamic dispatch.
type IAnnotationTypeBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllAnnotationTypeElementDeclaration() []IAnnotationTypeElementDeclarationContext
	AnnotationTypeElementDeclaration(i int) IAnnotationTypeElementDeclarationContext

	// IsAnnotationTypeBodyContext differentiates from other interfaces.
	IsAnnotationTypeBodyContext()
}

type AnnotationTypeBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationTypeBodyContext() *AnnotationTypeBodyContext {
	var p = new(AnnotationTypeBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_annotationTypeBody
	return p
}

func InitEmptyAnnotationTypeBodyContext(p *AnnotationTypeBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_annotationTypeBody
}

func (*AnnotationTypeBodyContext) IsAnnotationTypeBodyContext() {}

func NewAnnotationTypeBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationTypeBodyContext {
	var p = new(AnnotationTypeBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_annotationTypeBody

	return p
}

func (s *AnnotationTypeBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationTypeBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *AnnotationTypeBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *AnnotationTypeBodyContext) AllAnnotationTypeElementDeclaration() []IAnnotationTypeElementDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationTypeElementDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationTypeElementDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationTypeElementDeclarationContext); ok {
			tst[i] = t.(IAnnotationTypeElementDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *AnnotationTypeBodyContext) AnnotationTypeElementDeclaration(i int) IAnnotationTypeElementDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationTypeElementDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationTypeElementDeclarationContext)
}

func (s *AnnotationTypeBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationTypeBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationTypeBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterAnnotationTypeBody(s)
	}
}

func (s *AnnotationTypeBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitAnnotationTypeBody(s)
	}
}

func (s *AnnotationTypeBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitAnnotationTypeBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) AnnotationTypeBody() (localctx IAnnotationTypeBodyContext) {
	localctx = NewAnnotationTypeBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, JavaParserRULE_annotationTypeBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(876)
		p.Match(JavaParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(880)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-806529426349675) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-8935141660702539773) != 0) {
		{
			p.SetState(877)
			p.AnnotationTypeElementDeclaration()
		}

		p.SetState(882)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(883)
		p.Match(JavaParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationTypeElementDeclarationContext is an interface to support dynamic dispatch.
type IAnnotationTypeElementDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnnotationTypeElementRest() IAnnotationTypeElementRestContext
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext
	SEMI() antlr.TerminalNode

	// IsAnnotationTypeElementDeclarationContext differentiates from other interfaces.
	IsAnnotationTypeElementDeclarationContext()
}

type AnnotationTypeElementDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationTypeElementDeclarationContext() *AnnotationTypeElementDeclarationContext {
	var p = new(AnnotationTypeElementDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_annotationTypeElementDeclaration
	return p
}

func InitEmptyAnnotationTypeElementDeclarationContext(p *AnnotationTypeElementDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_annotationTypeElementDeclaration
}

func (*AnnotationTypeElementDeclarationContext) IsAnnotationTypeElementDeclarationContext() {}

func NewAnnotationTypeElementDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationTypeElementDeclarationContext {
	var p = new(AnnotationTypeElementDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_annotationTypeElementDeclaration

	return p
}

func (s *AnnotationTypeElementDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationTypeElementDeclarationContext) AnnotationTypeElementRest() IAnnotationTypeElementRestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationTypeElementRestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationTypeElementRestContext)
}

func (s *AnnotationTypeElementDeclarationContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *AnnotationTypeElementDeclarationContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *AnnotationTypeElementDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *AnnotationTypeElementDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationTypeElementDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationTypeElementDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterAnnotationTypeElementDeclaration(s)
	}
}

func (s *AnnotationTypeElementDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitAnnotationTypeElementDeclaration(s)
	}
}

func (s *AnnotationTypeElementDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitAnnotationTypeElementDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) AnnotationTypeElementDeclaration() (localctx IAnnotationTypeElementDeclarationContext) {
	localctx = NewAnnotationTypeElementDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, JavaParserRULE_annotationTypeElementDeclaration)
	var _alt int

	p.SetState(893)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserABSTRACT, JavaParserBOOLEAN, JavaParserBYTE, JavaParserCHAR, JavaParserCLASS, JavaParserDOUBLE, JavaParserENUM, JavaParserFINAL, JavaParserFLOAT, JavaParserINT, JavaParserINTERFACE, JavaParserLONG, JavaParserNATIVE, JavaParserPRIVATE, JavaParserPROTECTED, JavaParserPUBLIC, JavaParserSHORT, JavaParserSTATIC, JavaParserSTRICTFP, JavaParserSYNCHRONIZED, JavaParserTRANSIENT, JavaParserVOLATILE, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserNON_SEALED, JavaParserAT, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(888)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(885)
					p.Modifier()
				}

			}
			p.SetState(890)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(891)
			p.AnnotationTypeElementRest()
		}

	case JavaParserSEMI:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(892)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationTypeElementRestContext is an interface to support dynamic dispatch.
type IAnnotationTypeElementRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeType() ITypeTypeContext
	AnnotationMethodOrConstantRest() IAnnotationMethodOrConstantRestContext
	SEMI() antlr.TerminalNode
	ClassDeclaration() IClassDeclarationContext
	InterfaceDeclaration() IInterfaceDeclarationContext
	EnumDeclaration() IEnumDeclarationContext
	AnnotationTypeDeclaration() IAnnotationTypeDeclarationContext
	RecordDeclaration() IRecordDeclarationContext

	// IsAnnotationTypeElementRestContext differentiates from other interfaces.
	IsAnnotationTypeElementRestContext()
}

type AnnotationTypeElementRestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationTypeElementRestContext() *AnnotationTypeElementRestContext {
	var p = new(AnnotationTypeElementRestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_annotationTypeElementRest
	return p
}

func InitEmptyAnnotationTypeElementRestContext(p *AnnotationTypeElementRestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_annotationTypeElementRest
}

func (*AnnotationTypeElementRestContext) IsAnnotationTypeElementRestContext() {}

func NewAnnotationTypeElementRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationTypeElementRestContext {
	var p = new(AnnotationTypeElementRestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_annotationTypeElementRest

	return p
}

func (s *AnnotationTypeElementRestContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationTypeElementRestContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *AnnotationTypeElementRestContext) AnnotationMethodOrConstantRest() IAnnotationMethodOrConstantRestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationMethodOrConstantRestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationMethodOrConstantRestContext)
}

func (s *AnnotationTypeElementRestContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *AnnotationTypeElementRestContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *AnnotationTypeElementRestContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *AnnotationTypeElementRestContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *AnnotationTypeElementRestContext) AnnotationTypeDeclaration() IAnnotationTypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationTypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationTypeDeclarationContext)
}

func (s *AnnotationTypeElementRestContext) RecordDeclaration() IRecordDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationContext)
}

func (s *AnnotationTypeElementRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationTypeElementRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationTypeElementRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterAnnotationTypeElementRest(s)
	}
}

func (s *AnnotationTypeElementRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitAnnotationTypeElementRest(s)
	}
}

func (s *AnnotationTypeElementRestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitAnnotationTypeElementRest(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) AnnotationTypeElementRest() (localctx IAnnotationTypeElementRestContext) {
	localctx = NewAnnotationTypeElementRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, JavaParserRULE_annotationTypeElementRest)
	p.SetState(919)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(895)
			p.TypeType()
		}
		{
			p.SetState(896)
			p.AnnotationMethodOrConstantRest()
		}
		{
			p.SetState(897)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(899)
			p.ClassDeclaration()
		}
		p.SetState(901)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(900)
				p.Match(JavaParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(903)
			p.InterfaceDeclaration()
		}
		p.SetState(905)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(904)
				p.Match(JavaParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(907)
			p.EnumDeclaration()
		}
		p.SetState(909)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(908)
				p.Match(JavaParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(911)
			p.AnnotationTypeDeclaration()
		}
		p.SetState(913)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(912)
				p.Match(JavaParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(915)
			p.RecordDeclaration()
		}
		p.SetState(917)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(916)
				p.Match(JavaParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationMethodOrConstantRestContext is an interface to support dynamic dispatch.
type IAnnotationMethodOrConstantRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnnotationMethodRest() IAnnotationMethodRestContext
	AnnotationConstantRest() IAnnotationConstantRestContext

	// IsAnnotationMethodOrConstantRestContext differentiates from other interfaces.
	IsAnnotationMethodOrConstantRestContext()
}

type AnnotationMethodOrConstantRestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationMethodOrConstantRestContext() *AnnotationMethodOrConstantRestContext {
	var p = new(AnnotationMethodOrConstantRestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_annotationMethodOrConstantRest
	return p
}

func InitEmptyAnnotationMethodOrConstantRestContext(p *AnnotationMethodOrConstantRestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_annotationMethodOrConstantRest
}

func (*AnnotationMethodOrConstantRestContext) IsAnnotationMethodOrConstantRestContext() {}

func NewAnnotationMethodOrConstantRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationMethodOrConstantRestContext {
	var p = new(AnnotationMethodOrConstantRestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_annotationMethodOrConstantRest

	return p
}

func (s *AnnotationMethodOrConstantRestContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationMethodOrConstantRestContext) AnnotationMethodRest() IAnnotationMethodRestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationMethodRestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationMethodRestContext)
}

func (s *AnnotationMethodOrConstantRestContext) AnnotationConstantRest() IAnnotationConstantRestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationConstantRestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationConstantRestContext)
}

func (s *AnnotationMethodOrConstantRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationMethodOrConstantRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationMethodOrConstantRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterAnnotationMethodOrConstantRest(s)
	}
}

func (s *AnnotationMethodOrConstantRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitAnnotationMethodOrConstantRest(s)
	}
}

func (s *AnnotationMethodOrConstantRestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitAnnotationMethodOrConstantRest(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) AnnotationMethodOrConstantRest() (localctx IAnnotationMethodOrConstantRestContext) {
	localctx = NewAnnotationMethodOrConstantRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, JavaParserRULE_annotationMethodOrConstantRest)
	p.SetState(923)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(921)
			p.AnnotationMethodRest()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(922)
			p.AnnotationConstantRest()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationMethodRestContext is an interface to support dynamic dispatch.
type IAnnotationMethodRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	DefaultValue() IDefaultValueContext

	// IsAnnotationMethodRestContext differentiates from other interfaces.
	IsAnnotationMethodRestContext()
}

type AnnotationMethodRestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationMethodRestContext() *AnnotationMethodRestContext {
	var p = new(AnnotationMethodRestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_annotationMethodRest
	return p
}

func InitEmptyAnnotationMethodRestContext(p *AnnotationMethodRestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_annotationMethodRest
}

func (*AnnotationMethodRestContext) IsAnnotationMethodRestContext() {}

func NewAnnotationMethodRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationMethodRestContext {
	var p = new(AnnotationMethodRestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_annotationMethodRest

	return p
}

func (s *AnnotationMethodRestContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationMethodRestContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AnnotationMethodRestContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *AnnotationMethodRestContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *AnnotationMethodRestContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *AnnotationMethodRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationMethodRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationMethodRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterAnnotationMethodRest(s)
	}
}

func (s *AnnotationMethodRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitAnnotationMethodRest(s)
	}
}

func (s *AnnotationMethodRestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitAnnotationMethodRest(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) AnnotationMethodRest() (localctx IAnnotationMethodRestContext) {
	localctx = NewAnnotationMethodRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, JavaParserRULE_annotationMethodRest)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(925)
		p.Identifier()
	}
	{
		p.SetState(926)
		p.Match(JavaParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(927)
		p.Match(JavaParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserDEFAULT {
		{
			p.SetState(928)
			p.DefaultValue()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationConstantRestContext is an interface to support dynamic dispatch.
type IAnnotationConstantRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDeclarators() IVariableDeclaratorsContext

	// IsAnnotationConstantRestContext differentiates from other interfaces.
	IsAnnotationConstantRestContext()
}

type AnnotationConstantRestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationConstantRestContext() *AnnotationConstantRestContext {
	var p = new(AnnotationConstantRestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_annotationConstantRest
	return p
}

func InitEmptyAnnotationConstantRestContext(p *AnnotationConstantRestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_annotationConstantRest
}

func (*AnnotationConstantRestContext) IsAnnotationConstantRestContext() {}

func NewAnnotationConstantRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationConstantRestContext {
	var p = new(AnnotationConstantRestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_annotationConstantRest

	return p
}

func (s *AnnotationConstantRestContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationConstantRestContext) VariableDeclarators() IVariableDeclaratorsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorsContext)
}

func (s *AnnotationConstantRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationConstantRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationConstantRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterAnnotationConstantRest(s)
	}
}

func (s *AnnotationConstantRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitAnnotationConstantRest(s)
	}
}

func (s *AnnotationConstantRestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitAnnotationConstantRest(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) AnnotationConstantRest() (localctx IAnnotationConstantRestContext) {
	localctx = NewAnnotationConstantRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, JavaParserRULE_annotationConstantRest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(931)
		p.VariableDeclarators()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultValueContext is an interface to support dynamic dispatch.
type IDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	ElementValue() IElementValueContext

	// IsDefaultValueContext differentiates from other interfaces.
	IsDefaultValueContext()
}

type DefaultValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValueContext() *DefaultValueContext {
	var p = new(DefaultValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_defaultValue
	return p
}

func InitEmptyDefaultValueContext(p *DefaultValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_defaultValue
}

func (*DefaultValueContext) IsDefaultValueContext() {}

func NewDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValueContext {
	var p = new(DefaultValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_defaultValue

	return p
}

func (s *DefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValueContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(JavaParserDEFAULT, 0)
}

func (s *DefaultValueContext) ElementValue() IElementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *DefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterDefaultValue(s)
	}
}

func (s *DefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitDefaultValue(s)
	}
}

func (s *DefaultValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitDefaultValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) DefaultValue() (localctx IDefaultValueContext) {
	localctx = NewDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, JavaParserRULE_defaultValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(933)
		p.Match(JavaParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(934)
		p.ElementValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModuleDeclarationContext is an interface to support dynamic dispatch.
type IModuleDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODULE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	ModuleBody() IModuleBodyContext
	OPEN() antlr.TerminalNode

	// IsModuleDeclarationContext differentiates from other interfaces.
	IsModuleDeclarationContext()
}

type ModuleDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleDeclarationContext() *ModuleDeclarationContext {
	var p = new(ModuleDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_moduleDeclaration
	return p
}

func InitEmptyModuleDeclarationContext(p *ModuleDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_moduleDeclaration
}

func (*ModuleDeclarationContext) IsModuleDeclarationContext() {}

func NewModuleDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleDeclarationContext {
	var p = new(ModuleDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_moduleDeclaration

	return p
}

func (s *ModuleDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleDeclarationContext) MODULE() antlr.TerminalNode {
	return s.GetToken(JavaParserMODULE, 0)
}

func (s *ModuleDeclarationContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ModuleDeclarationContext) ModuleBody() IModuleBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleBodyContext)
}

func (s *ModuleDeclarationContext) OPEN() antlr.TerminalNode {
	return s.GetToken(JavaParserOPEN, 0)
}

func (s *ModuleDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterModuleDeclaration(s)
	}
}

func (s *ModuleDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitModuleDeclaration(s)
	}
}

func (s *ModuleDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitModuleDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ModuleDeclaration() (localctx IModuleDeclarationContext) {
	localctx = NewModuleDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, JavaParserRULE_moduleDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(937)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserOPEN {
		{
			p.SetState(936)
			p.Match(JavaParserOPEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(939)
		p.Match(JavaParserMODULE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(940)
		p.QualifiedName()
	}
	{
		p.SetState(941)
		p.ModuleBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModuleBodyContext is an interface to support dynamic dispatch.
type IModuleBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllModuleDirective() []IModuleDirectiveContext
	ModuleDirective(i int) IModuleDirectiveContext

	// IsModuleBodyContext differentiates from other interfaces.
	IsModuleBodyContext()
}

type ModuleBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleBodyContext() *ModuleBodyContext {
	var p = new(ModuleBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_moduleBody
	return p
}

func InitEmptyModuleBodyContext(p *ModuleBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_moduleBody
}

func (*ModuleBodyContext) IsModuleBodyContext() {}

func NewModuleBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleBodyContext {
	var p = new(ModuleBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_moduleBody

	return p
}

func (s *ModuleBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *ModuleBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *ModuleBodyContext) AllModuleDirective() []IModuleDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModuleDirectiveContext); ok {
			len++
		}
	}

	tst := make([]IModuleDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModuleDirectiveContext); ok {
			tst[i] = t.(IModuleDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *ModuleBodyContext) ModuleDirective(i int) IModuleDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleDirectiveContext)
}

func (s *ModuleBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterModuleBody(s)
	}
}

func (s *ModuleBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitModuleBody(s)
	}
}

func (s *ModuleBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitModuleBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ModuleBody() (localctx IModuleBodyContext) {
	localctx = NewModuleBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, JavaParserRULE_moduleBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(943)
		p.Match(JavaParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(947)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&495395959010754560) != 0 {
		{
			p.SetState(944)
			p.ModuleDirective()
		}

		p.SetState(949)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(950)
		p.Match(JavaParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModuleDirectiveContext is an interface to support dynamic dispatch.
type IModuleDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REQUIRES() antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	SEMI() antlr.TerminalNode
	AllRequiresModifier() []IRequiresModifierContext
	RequiresModifier(i int) IRequiresModifierContext
	EXPORTS() antlr.TerminalNode
	TO() antlr.TerminalNode
	OPENS() antlr.TerminalNode
	USES() antlr.TerminalNode
	PROVIDES() antlr.TerminalNode
	WITH() antlr.TerminalNode

	// IsModuleDirectiveContext differentiates from other interfaces.
	IsModuleDirectiveContext()
}

type ModuleDirectiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleDirectiveContext() *ModuleDirectiveContext {
	var p = new(ModuleDirectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_moduleDirective
	return p
}

func InitEmptyModuleDirectiveContext(p *ModuleDirectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_moduleDirective
}

func (*ModuleDirectiveContext) IsModuleDirectiveContext() {}

func NewModuleDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleDirectiveContext {
	var p = new(ModuleDirectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_moduleDirective

	return p
}

func (s *ModuleDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleDirectiveContext) REQUIRES() antlr.TerminalNode {
	return s.GetToken(JavaParserREQUIRES, 0)
}

func (s *ModuleDirectiveContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ModuleDirectiveContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ModuleDirectiveContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *ModuleDirectiveContext) AllRequiresModifier() []IRequiresModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRequiresModifierContext); ok {
			len++
		}
	}

	tst := make([]IRequiresModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRequiresModifierContext); ok {
			tst[i] = t.(IRequiresModifierContext)
			i++
		}
	}

	return tst
}

func (s *ModuleDirectiveContext) RequiresModifier(i int) IRequiresModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRequiresModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRequiresModifierContext)
}

func (s *ModuleDirectiveContext) EXPORTS() antlr.TerminalNode {
	return s.GetToken(JavaParserEXPORTS, 0)
}

func (s *ModuleDirectiveContext) TO() antlr.TerminalNode {
	return s.GetToken(JavaParserTO, 0)
}

func (s *ModuleDirectiveContext) OPENS() antlr.TerminalNode {
	return s.GetToken(JavaParserOPENS, 0)
}

func (s *ModuleDirectiveContext) USES() antlr.TerminalNode {
	return s.GetToken(JavaParserUSES, 0)
}

func (s *ModuleDirectiveContext) PROVIDES() antlr.TerminalNode {
	return s.GetToken(JavaParserPROVIDES, 0)
}

func (s *ModuleDirectiveContext) WITH() antlr.TerminalNode {
	return s.GetToken(JavaParserWITH, 0)
}

func (s *ModuleDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterModuleDirective(s)
	}
}

func (s *ModuleDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitModuleDirective(s)
	}
}

func (s *ModuleDirectiveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitModuleDirective(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ModuleDirective() (localctx IModuleDirectiveContext) {
	localctx = NewModuleDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, JavaParserRULE_moduleDirective)
	var _la int

	var _alt int

	p.SetState(988)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserREQUIRES:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(952)
			p.Match(JavaParserREQUIRES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(956)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 109, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(953)
					p.RequiresModifier()
				}

			}
			p.SetState(958)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 109, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(959)
			p.QualifiedName()
		}
		{
			p.SetState(960)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaParserEXPORTS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(962)
			p.Match(JavaParserEXPORTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(963)
			p.QualifiedName()
		}
		p.SetState(966)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserTO {
			{
				p.SetState(964)
				p.Match(JavaParserTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(965)
				p.QualifiedName()
			}

		}
		{
			p.SetState(968)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaParserOPENS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(970)
			p.Match(JavaParserOPENS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(971)
			p.QualifiedName()
		}
		p.SetState(974)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserTO {
			{
				p.SetState(972)
				p.Match(JavaParserTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(973)
				p.QualifiedName()
			}

		}
		{
			p.SetState(976)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaParserUSES:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(978)
			p.Match(JavaParserUSES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(979)
			p.QualifiedName()
		}
		{
			p.SetState(980)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaParserPROVIDES:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(982)
			p.Match(JavaParserPROVIDES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(983)
			p.QualifiedName()
		}
		{
			p.SetState(984)
			p.Match(JavaParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(985)
			p.QualifiedName()
		}
		{
			p.SetState(986)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRequiresModifierContext is an interface to support dynamic dispatch.
type IRequiresModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRANSITIVE() antlr.TerminalNode
	STATIC() antlr.TerminalNode

	// IsRequiresModifierContext differentiates from other interfaces.
	IsRequiresModifierContext()
}

type RequiresModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRequiresModifierContext() *RequiresModifierContext {
	var p = new(RequiresModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_requiresModifier
	return p
}

func InitEmptyRequiresModifierContext(p *RequiresModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_requiresModifier
}

func (*RequiresModifierContext) IsRequiresModifierContext() {}

func NewRequiresModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RequiresModifierContext {
	var p = new(RequiresModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_requiresModifier

	return p
}

func (s *RequiresModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *RequiresModifierContext) TRANSITIVE() antlr.TerminalNode {
	return s.GetToken(JavaParserTRANSITIVE, 0)
}

func (s *RequiresModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(JavaParserSTATIC, 0)
}

func (s *RequiresModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RequiresModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RequiresModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterRequiresModifier(s)
	}
}

func (s *RequiresModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitRequiresModifier(s)
	}
}

func (s *RequiresModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitRequiresModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) RequiresModifier() (localctx IRequiresModifierContext) {
	localctx = NewRequiresModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, JavaParserRULE_requiresModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(990)
		_la = p.GetTokenStream().LA(1)

		if !(_la == JavaParserSTATIC || _la == JavaParserTRANSITIVE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordDeclarationContext is an interface to support dynamic dispatch.
type IRecordDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECORD() antlr.TerminalNode
	Identifier() IIdentifierContext
	RecordHeader() IRecordHeaderContext
	RecordBody() IRecordBodyContext
	TypeParameters() ITypeParametersContext
	IMPLEMENTS() antlr.TerminalNode
	TypeList() ITypeListContext

	// IsRecordDeclarationContext differentiates from other interfaces.
	IsRecordDeclarationContext()
}

type RecordDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordDeclarationContext() *RecordDeclarationContext {
	var p = new(RecordDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_recordDeclaration
	return p
}

func InitEmptyRecordDeclarationContext(p *RecordDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_recordDeclaration
}

func (*RecordDeclarationContext) IsRecordDeclarationContext() {}

func NewRecordDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordDeclarationContext {
	var p = new(RecordDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_recordDeclaration

	return p
}

func (s *RecordDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordDeclarationContext) RECORD() antlr.TerminalNode {
	return s.GetToken(JavaParserRECORD, 0)
}

func (s *RecordDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecordDeclarationContext) RecordHeader() IRecordHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordHeaderContext)
}

func (s *RecordDeclarationContext) RecordBody() IRecordBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordBodyContext)
}

func (s *RecordDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *RecordDeclarationContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(JavaParserIMPLEMENTS, 0)
}

func (s *RecordDeclarationContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *RecordDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterRecordDeclaration(s)
	}
}

func (s *RecordDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitRecordDeclaration(s)
	}
}

func (s *RecordDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitRecordDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) RecordDeclaration() (localctx IRecordDeclarationContext) {
	localctx = NewRecordDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, JavaParserRULE_recordDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(992)
		p.Match(JavaParserRECORD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(993)
		p.Identifier()
	}
	p.SetState(995)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserLT {
		{
			p.SetState(994)
			p.TypeParameters()
		}

	}
	{
		p.SetState(997)
		p.RecordHeader()
	}
	p.SetState(1000)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserIMPLEMENTS {
		{
			p.SetState(998)
			p.Match(JavaParserIMPLEMENTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(999)
			p.TypeList()
		}

	}
	{
		p.SetState(1002)
		p.RecordBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordHeaderContext is an interface to support dynamic dispatch.
type IRecordHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	RecordComponentList() IRecordComponentListContext

	// IsRecordHeaderContext differentiates from other interfaces.
	IsRecordHeaderContext()
}

type RecordHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordHeaderContext() *RecordHeaderContext {
	var p = new(RecordHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_recordHeader
	return p
}

func InitEmptyRecordHeaderContext(p *RecordHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_recordHeader
}

func (*RecordHeaderContext) IsRecordHeaderContext() {}

func NewRecordHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordHeaderContext {
	var p = new(RecordHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_recordHeader

	return p
}

func (s *RecordHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordHeaderContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *RecordHeaderContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *RecordHeaderContext) RecordComponentList() IRecordComponentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordComponentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordComponentListContext)
}

func (s *RecordHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterRecordHeader(s)
	}
}

func (s *RecordHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitRecordHeader(s)
	}
}

func (s *RecordHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitRecordHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) RecordHeader() (localctx IRecordHeaderContext) {
	localctx = NewRecordHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, JavaParserRULE_recordHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1004)
		p.Match(JavaParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1006)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-3)) & ^0x3f) == 0 && ((int64(1)<<(_la-3))&9223090579141953573) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
		{
			p.SetState(1005)
			p.RecordComponentList()
		}

	}
	{
		p.SetState(1008)
		p.Match(JavaParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordComponentListContext is an interface to support dynamic dispatch.
type IRecordComponentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRecordComponent() []IRecordComponentContext
	RecordComponent(i int) IRecordComponentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRecordComponentListContext differentiates from other interfaces.
	IsRecordComponentListContext()
}

type RecordComponentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordComponentListContext() *RecordComponentListContext {
	var p = new(RecordComponentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_recordComponentList
	return p
}

func InitEmptyRecordComponentListContext(p *RecordComponentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_recordComponentList
}

func (*RecordComponentListContext) IsRecordComponentListContext() {}

func NewRecordComponentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordComponentListContext {
	var p = new(RecordComponentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_recordComponentList

	return p
}

func (s *RecordComponentListContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordComponentListContext) AllRecordComponent() []IRecordComponentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordComponentContext); ok {
			len++
		}
	}

	tst := make([]IRecordComponentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordComponentContext); ok {
			tst[i] = t.(IRecordComponentContext)
			i++
		}
	}

	return tst
}

func (s *RecordComponentListContext) RecordComponent(i int) IRecordComponentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordComponentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordComponentContext)
}

func (s *RecordComponentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *RecordComponentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *RecordComponentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordComponentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordComponentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterRecordComponentList(s)
	}
}

func (s *RecordComponentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitRecordComponentList(s)
	}
}

func (s *RecordComponentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitRecordComponentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) RecordComponentList() (localctx IRecordComponentListContext) {
	localctx = NewRecordComponentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, JavaParserRULE_recordComponentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1010)
		p.RecordComponent()
	}
	p.SetState(1015)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCOMMA {
		{
			p.SetState(1011)
			p.Match(JavaParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1012)
			p.RecordComponent()
		}

		p.SetState(1017)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordComponentContext is an interface to support dynamic dispatch.
type IRecordComponentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeType() ITypeTypeContext
	Identifier() IIdentifierContext

	// IsRecordComponentContext differentiates from other interfaces.
	IsRecordComponentContext()
}

type RecordComponentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordComponentContext() *RecordComponentContext {
	var p = new(RecordComponentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_recordComponent
	return p
}

func InitEmptyRecordComponentContext(p *RecordComponentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_recordComponent
}

func (*RecordComponentContext) IsRecordComponentContext() {}

func NewRecordComponentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordComponentContext {
	var p = new(RecordComponentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_recordComponent

	return p
}

func (s *RecordComponentContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordComponentContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *RecordComponentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecordComponentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordComponentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordComponentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterRecordComponent(s)
	}
}

func (s *RecordComponentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitRecordComponent(s)
	}
}

func (s *RecordComponentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitRecordComponent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) RecordComponent() (localctx IRecordComponentContext) {
	localctx = NewRecordComponentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, JavaParserRULE_recordComponent)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1018)
		p.TypeType()
	}
	{
		p.SetState(1019)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordBodyContext is an interface to support dynamic dispatch.
type IRecordBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllClassBodyDeclaration() []IClassBodyDeclarationContext
	ClassBodyDeclaration(i int) IClassBodyDeclarationContext
	AllCompactConstructorDeclaration() []ICompactConstructorDeclarationContext
	CompactConstructorDeclaration(i int) ICompactConstructorDeclarationContext

	// IsRecordBodyContext differentiates from other interfaces.
	IsRecordBodyContext()
}

type RecordBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordBodyContext() *RecordBodyContext {
	var p = new(RecordBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_recordBody
	return p
}

func InitEmptyRecordBodyContext(p *RecordBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_recordBody
}

func (*RecordBodyContext) IsRecordBodyContext() {}

func NewRecordBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordBodyContext {
	var p = new(RecordBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_recordBody

	return p
}

func (s *RecordBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *RecordBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *RecordBodyContext) AllClassBodyDeclaration() []IClassBodyDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassBodyDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassBodyDeclarationContext); ok {
			tst[i] = t.(IClassBodyDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *RecordBodyContext) ClassBodyDeclaration(i int) IClassBodyDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyDeclarationContext)
}

func (s *RecordBodyContext) AllCompactConstructorDeclaration() []ICompactConstructorDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICompactConstructorDeclarationContext); ok {
			len++
		}
	}

	tst := make([]ICompactConstructorDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICompactConstructorDeclarationContext); ok {
			tst[i] = t.(ICompactConstructorDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *RecordBodyContext) CompactConstructorDeclaration(i int) ICompactConstructorDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompactConstructorDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompactConstructorDeclarationContext)
}

func (s *RecordBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterRecordBody(s)
	}
}

func (s *RecordBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitRecordBody(s)
	}
}

func (s *RecordBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitRecordBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) RecordBody() (localctx IRecordBodyContext) {
	localctx = NewRecordBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, JavaParserRULE_recordBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1021)
		p.Match(JavaParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1026)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-665791937994347) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-8935141660685729789) != 0) {
		p.SetState(1024)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1022)
				p.ClassBodyDeclaration()
			}

		case 2:
			{
				p.SetState(1023)
				p.CompactConstructorDeclaration()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(1028)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1029)
		p.Match(JavaParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllBlockStatement() []IBlockStatementContext
	BlockStatement(i int) IBlockStatementContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *BlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *BlockContext) AllBlockStatement() []IBlockStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockStatementContext); ok {
			len++
		}
	}

	tst := make([]IBlockStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockStatementContext); ok {
			tst[i] = t.(IBlockStatementContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) BlockStatement(i int) IBlockStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, JavaParserRULE_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1031)
		p.Match(JavaParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1035)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-334254282492513) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-8935141145188974593) != 0) {
		{
			p.SetState(1032)
			p.BlockStatement()
		}

		p.SetState(1037)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1038)
		p.Match(JavaParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockStatementContext is an interface to support dynamic dispatch.
type IBlockStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LocalVariableDeclaration() ILocalVariableDeclarationContext
	SEMI() antlr.TerminalNode
	LocalTypeDeclaration() ILocalTypeDeclarationContext
	Statement() IStatementContext

	// IsBlockStatementContext differentiates from other interfaces.
	IsBlockStatementContext()
}

type BlockStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementContext() *BlockStatementContext {
	var p = new(BlockStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_blockStatement
	return p
}

func InitEmptyBlockStatementContext(p *BlockStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_blockStatement
}

func (*BlockStatementContext) IsBlockStatementContext() {}

func NewBlockStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementContext {
	var p = new(BlockStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_blockStatement

	return p
}

func (s *BlockStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *BlockStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *BlockStatementContext) LocalTypeDeclaration() ILocalTypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalTypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalTypeDeclarationContext)
}

func (s *BlockStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterBlockStatement(s)
	}
}

func (s *BlockStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitBlockStatement(s)
	}
}

func (s *BlockStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitBlockStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) BlockStatement() (localctx IBlockStatementContext) {
	localctx = NewBlockStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, JavaParserRULE_blockStatement)
	p.SetState(1045)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1040)
			p.LocalVariableDeclaration()
		}
		{
			p.SetState(1041)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1043)
			p.LocalTypeDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1044)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocalVariableDeclarationContext is an interface to support dynamic dispatch.
type ILocalVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VAR() antlr.TerminalNode
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext
	TypeType() ITypeTypeContext
	VariableDeclarators() IVariableDeclaratorsContext
	AllVariableModifier() []IVariableModifierContext
	VariableModifier(i int) IVariableModifierContext

	// IsLocalVariableDeclarationContext differentiates from other interfaces.
	IsLocalVariableDeclarationContext()
}

type LocalVariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalVariableDeclarationContext() *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_localVariableDeclaration
	return p
}

func InitEmptyLocalVariableDeclarationContext(p *LocalVariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_localVariableDeclaration
}

func (*LocalVariableDeclarationContext) IsLocalVariableDeclarationContext() {}

func NewLocalVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_localVariableDeclaration

	return p
}

func (s *LocalVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalVariableDeclarationContext) VAR() antlr.TerminalNode {
	return s.GetToken(JavaParserVAR, 0)
}

func (s *LocalVariableDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LocalVariableDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserASSIGN, 0)
}

func (s *LocalVariableDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LocalVariableDeclarationContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *LocalVariableDeclarationContext) VariableDeclarators() IVariableDeclaratorsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorsContext)
}

func (s *LocalVariableDeclarationContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *LocalVariableDeclarationContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *LocalVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterLocalVariableDeclaration(s)
	}
}

func (s *LocalVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitLocalVariableDeclaration(s)
	}
}

func (s *LocalVariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitLocalVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) LocalVariableDeclaration() (localctx ILocalVariableDeclarationContext) {
	localctx = NewLocalVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, JavaParserRULE_localVariableDeclaration)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1050)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1047)
				p.VariableModifier()
			}

		}
		p.SetState(1052)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1053)
			p.Match(JavaParserVAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1054)
			p.Identifier()
		}
		{
			p.SetState(1055)
			p.Match(JavaParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1056)
			p.expression(0)
		}

	case 2:
		{
			p.SetState(1058)
			p.TypeType()
		}
		{
			p.SetState(1059)
			p.VariableDeclarators()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	MODULE() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	REQUIRES() antlr.TerminalNode
	EXPORTS() antlr.TerminalNode
	OPENS() antlr.TerminalNode
	TO() antlr.TerminalNode
	USES() antlr.TerminalNode
	PROVIDES() antlr.TerminalNode
	WITH() antlr.TerminalNode
	TRANSITIVE() antlr.TerminalNode
	YIELD() antlr.TerminalNode
	SEALED() antlr.TerminalNode
	PERMITS() antlr.TerminalNode
	RECORD() antlr.TerminalNode
	VAR() antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(JavaParserIDENTIFIER, 0)
}

func (s *IdentifierContext) MODULE() antlr.TerminalNode {
	return s.GetToken(JavaParserMODULE, 0)
}

func (s *IdentifierContext) OPEN() antlr.TerminalNode {
	return s.GetToken(JavaParserOPEN, 0)
}

func (s *IdentifierContext) REQUIRES() antlr.TerminalNode {
	return s.GetToken(JavaParserREQUIRES, 0)
}

func (s *IdentifierContext) EXPORTS() antlr.TerminalNode {
	return s.GetToken(JavaParserEXPORTS, 0)
}

func (s *IdentifierContext) OPENS() antlr.TerminalNode {
	return s.GetToken(JavaParserOPENS, 0)
}

func (s *IdentifierContext) TO() antlr.TerminalNode {
	return s.GetToken(JavaParserTO, 0)
}

func (s *IdentifierContext) USES() antlr.TerminalNode {
	return s.GetToken(JavaParserUSES, 0)
}

func (s *IdentifierContext) PROVIDES() antlr.TerminalNode {
	return s.GetToken(JavaParserPROVIDES, 0)
}

func (s *IdentifierContext) WITH() antlr.TerminalNode {
	return s.GetToken(JavaParserWITH, 0)
}

func (s *IdentifierContext) TRANSITIVE() antlr.TerminalNode {
	return s.GetToken(JavaParserTRANSITIVE, 0)
}

func (s *IdentifierContext) YIELD() antlr.TerminalNode {
	return s.GetToken(JavaParserYIELD, 0)
}

func (s *IdentifierContext) SEALED() antlr.TerminalNode {
	return s.GetToken(JavaParserSEALED, 0)
}

func (s *IdentifierContext) PERMITS() antlr.TerminalNode {
	return s.GetToken(JavaParserPERMITS, 0)
}

func (s *IdentifierContext) RECORD() antlr.TerminalNode {
	return s.GetToken(JavaParserRECORD, 0)
}

func (s *IdentifierContext) VAR() antlr.TerminalNode {
	return s.GetToken(JavaParserVAR, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, JavaParserRULE_identifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1063)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-51)) & ^0x3f) == 0 && ((int64(1)<<(_la-51))&32767) != 0) || _la == JavaParserIDENTIFIER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeIdentifierContext is an interface to support dynamic dispatch.
type ITypeIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	MODULE() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	REQUIRES() antlr.TerminalNode
	EXPORTS() antlr.TerminalNode
	OPENS() antlr.TerminalNode
	TO() antlr.TerminalNode
	USES() antlr.TerminalNode
	PROVIDES() antlr.TerminalNode
	WITH() antlr.TerminalNode
	TRANSITIVE() antlr.TerminalNode
	SEALED() antlr.TerminalNode
	PERMITS() antlr.TerminalNode
	RECORD() antlr.TerminalNode

	// IsTypeIdentifierContext differentiates from other interfaces.
	IsTypeIdentifierContext()
}

type TypeIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeIdentifierContext() *TypeIdentifierContext {
	var p = new(TypeIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeIdentifier
	return p
}

func InitEmptyTypeIdentifierContext(p *TypeIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeIdentifier
}

func (*TypeIdentifierContext) IsTypeIdentifierContext() {}

func NewTypeIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeIdentifierContext {
	var p = new(TypeIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeIdentifier

	return p
}

func (s *TypeIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(JavaParserIDENTIFIER, 0)
}

func (s *TypeIdentifierContext) MODULE() antlr.TerminalNode {
	return s.GetToken(JavaParserMODULE, 0)
}

func (s *TypeIdentifierContext) OPEN() antlr.TerminalNode {
	return s.GetToken(JavaParserOPEN, 0)
}

func (s *TypeIdentifierContext) REQUIRES() antlr.TerminalNode {
	return s.GetToken(JavaParserREQUIRES, 0)
}

func (s *TypeIdentifierContext) EXPORTS() antlr.TerminalNode {
	return s.GetToken(JavaParserEXPORTS, 0)
}

func (s *TypeIdentifierContext) OPENS() antlr.TerminalNode {
	return s.GetToken(JavaParserOPENS, 0)
}

func (s *TypeIdentifierContext) TO() antlr.TerminalNode {
	return s.GetToken(JavaParserTO, 0)
}

func (s *TypeIdentifierContext) USES() antlr.TerminalNode {
	return s.GetToken(JavaParserUSES, 0)
}

func (s *TypeIdentifierContext) PROVIDES() antlr.TerminalNode {
	return s.GetToken(JavaParserPROVIDES, 0)
}

func (s *TypeIdentifierContext) WITH() antlr.TerminalNode {
	return s.GetToken(JavaParserWITH, 0)
}

func (s *TypeIdentifierContext) TRANSITIVE() antlr.TerminalNode {
	return s.GetToken(JavaParserTRANSITIVE, 0)
}

func (s *TypeIdentifierContext) SEALED() antlr.TerminalNode {
	return s.GetToken(JavaParserSEALED, 0)
}

func (s *TypeIdentifierContext) PERMITS() antlr.TerminalNode {
	return s.GetToken(JavaParserPERMITS, 0)
}

func (s *TypeIdentifierContext) RECORD() antlr.TerminalNode {
	return s.GetToken(JavaParserRECORD, 0)
}

func (s *TypeIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeIdentifier(s)
	}
}

func (s *TypeIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeIdentifier(s)
	}
}

func (s *TypeIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitTypeIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) TypeIdentifier() (localctx ITypeIdentifierContext) {
	localctx = NewTypeIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, JavaParserRULE_typeIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1065)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-51)) & ^0x3f) == 0 && ((int64(1)<<(_la-51))&29695) != 0) || _la == JavaParserIDENTIFIER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocalTypeDeclarationContext is an interface to support dynamic dispatch.
type ILocalTypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassDeclaration() IClassDeclarationContext
	InterfaceDeclaration() IInterfaceDeclarationContext
	RecordDeclaration() IRecordDeclarationContext
	AllClassOrInterfaceModifier() []IClassOrInterfaceModifierContext
	ClassOrInterfaceModifier(i int) IClassOrInterfaceModifierContext

	// IsLocalTypeDeclarationContext differentiates from other interfaces.
	IsLocalTypeDeclarationContext()
}

type LocalTypeDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalTypeDeclarationContext() *LocalTypeDeclarationContext {
	var p = new(LocalTypeDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_localTypeDeclaration
	return p
}

func InitEmptyLocalTypeDeclarationContext(p *LocalTypeDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_localTypeDeclaration
}

func (*LocalTypeDeclarationContext) IsLocalTypeDeclarationContext() {}

func NewLocalTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalTypeDeclarationContext {
	var p = new(LocalTypeDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_localTypeDeclaration

	return p
}

func (s *LocalTypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalTypeDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *LocalTypeDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *LocalTypeDeclarationContext) RecordDeclaration() IRecordDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationContext)
}

func (s *LocalTypeDeclarationContext) AllClassOrInterfaceModifier() []IClassOrInterfaceModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			len++
		}
	}

	tst := make([]IClassOrInterfaceModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			tst[i] = t.(IClassOrInterfaceModifierContext)
			i++
		}
	}

	return tst
}

func (s *LocalTypeDeclarationContext) ClassOrInterfaceModifier(i int) IClassOrInterfaceModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceModifierContext)
}

func (s *LocalTypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalTypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalTypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterLocalTypeDeclaration(s)
	}
}

func (s *LocalTypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitLocalTypeDeclaration(s)
	}
}

func (s *LocalTypeDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitLocalTypeDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) LocalTypeDeclaration() (localctx ILocalTypeDeclarationContext) {
	localctx = NewLocalTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, JavaParserRULE_localTypeDeclaration)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1070)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1067)
				p.ClassOrInterfaceModifier()
			}

		}
		p.SetState(1072)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1076)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserCLASS:
		{
			p.SetState(1073)
			p.ClassDeclaration()
		}

	case JavaParserINTERFACE:
		{
			p.SetState(1074)
			p.InterfaceDeclaration()
		}

	case JavaParserRECORD:
		{
			p.SetState(1075)
			p.RecordDeclaration()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBlockLabel returns the blockLabel rule contexts.
	GetBlockLabel() IBlockContext

	// GetStatementExpression returns the statementExpression rule contexts.
	GetStatementExpression() IExpressionContext

	// GetIdentifierLabel returns the identifierLabel rule contexts.
	GetIdentifierLabel() IIdentifierContext

	// SetBlockLabel sets the blockLabel rule contexts.
	SetBlockLabel(IBlockContext)

	// SetStatementExpression sets the statementExpression rule contexts.
	SetStatementExpression(IExpressionContext)

	// SetIdentifierLabel sets the identifierLabel rule contexts.
	SetIdentifierLabel(IIdentifierContext)

	// Getter signatures
	Block() IBlockContext
	ASSERT() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	SEMI() antlr.TerminalNode
	COLON() antlr.TerminalNode
	IF() antlr.TerminalNode
	ParExpression() IParExpressionContext
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	ELSE() antlr.TerminalNode
	FOR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	ForControl() IForControlContext
	RPAREN() antlr.TerminalNode
	WHILE() antlr.TerminalNode
	DO() antlr.TerminalNode
	TRY() antlr.TerminalNode
	FinallyBlock() IFinallyBlockContext
	AllCatchClause() []ICatchClauseContext
	CatchClause(i int) ICatchClauseContext
	ResourceSpecification() IResourceSpecificationContext
	SWITCH() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllSwitchBlockStatementGroup() []ISwitchBlockStatementGroupContext
	SwitchBlockStatementGroup(i int) ISwitchBlockStatementGroupContext
	AllSwitchLabel() []ISwitchLabelContext
	SwitchLabel(i int) ISwitchLabelContext
	SYNCHRONIZED() antlr.TerminalNode
	RETURN() antlr.TerminalNode
	THROW() antlr.TerminalNode
	BREAK() antlr.TerminalNode
	Identifier() IIdentifierContext
	CONTINUE() antlr.TerminalNode
	YIELD() antlr.TerminalNode
	SwitchExpression() ISwitchExpressionContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	blockLabel          IBlockContext
	statementExpression IExpressionContext
	identifierLabel     IIdentifierContext
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) GetBlockLabel() IBlockContext { return s.blockLabel }

func (s *StatementContext) GetStatementExpression() IExpressionContext { return s.statementExpression }

func (s *StatementContext) GetIdentifierLabel() IIdentifierContext { return s.identifierLabel }

func (s *StatementContext) SetBlockLabel(v IBlockContext) { s.blockLabel = v }

func (s *StatementContext) SetStatementExpression(v IExpressionContext) { s.statementExpression = v }

func (s *StatementContext) SetIdentifierLabel(v IIdentifierContext) { s.identifierLabel = v }

func (s *StatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(JavaParserASSERT, 0)
}

func (s *StatementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *StatementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *StatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(JavaParserCOLON, 0)
}

func (s *StatementContext) IF() antlr.TerminalNode {
	return s.GetToken(JavaParserIF, 0)
}

func (s *StatementContext) ParExpression() IParExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParExpressionContext)
}

func (s *StatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(JavaParserELSE, 0)
}

func (s *StatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(JavaParserFOR, 0)
}

func (s *StatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *StatementContext) ForControl() IForControlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForControlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForControlContext)
}

func (s *StatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *StatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(JavaParserWHILE, 0)
}

func (s *StatementContext) DO() antlr.TerminalNode {
	return s.GetToken(JavaParserDO, 0)
}

func (s *StatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(JavaParserTRY, 0)
}

func (s *StatementContext) FinallyBlock() IFinallyBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinallyBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinallyBlockContext)
}

func (s *StatementContext) AllCatchClause() []ICatchClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICatchClauseContext); ok {
			len++
		}
	}

	tst := make([]ICatchClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICatchClauseContext); ok {
			tst[i] = t.(ICatchClauseContext)
			i++
		}
	}

	return tst
}

func (s *StatementContext) CatchClause(i int) ICatchClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchClauseContext)
}

func (s *StatementContext) ResourceSpecification() IResourceSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceSpecificationContext)
}

func (s *StatementContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(JavaParserSWITCH, 0)
}

func (s *StatementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *StatementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *StatementContext) AllSwitchBlockStatementGroup() []ISwitchBlockStatementGroupContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchBlockStatementGroupContext); ok {
			len++
		}
	}

	tst := make([]ISwitchBlockStatementGroupContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchBlockStatementGroupContext); ok {
			tst[i] = t.(ISwitchBlockStatementGroupContext)
			i++
		}
	}

	return tst
}

func (s *StatementContext) SwitchBlockStatementGroup(i int) ISwitchBlockStatementGroupContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchBlockStatementGroupContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchBlockStatementGroupContext)
}

func (s *StatementContext) AllSwitchLabel() []ISwitchLabelContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchLabelContext); ok {
			len++
		}
	}

	tst := make([]ISwitchLabelContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchLabelContext); ok {
			tst[i] = t.(ISwitchLabelContext)
			i++
		}
	}

	return tst
}

func (s *StatementContext) SwitchLabel(i int) ISwitchLabelContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchLabelContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchLabelContext)
}

func (s *StatementContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(JavaParserSYNCHRONIZED, 0)
}

func (s *StatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(JavaParserRETURN, 0)
}

func (s *StatementContext) THROW() antlr.TerminalNode {
	return s.GetToken(JavaParserTHROW, 0)
}

func (s *StatementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(JavaParserBREAK, 0)
}

func (s *StatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(JavaParserCONTINUE, 0)
}

func (s *StatementContext) YIELD() antlr.TerminalNode {
	return s.GetToken(JavaParserYIELD, 0)
}

func (s *StatementContext) SwitchExpression() ISwitchExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchExpressionContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, JavaParserRULE_statement)
	var _la int

	var _alt int

	p.SetState(1191)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 138, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1078)

			var _x = p.Block()

			localctx.(*StatementContext).blockLabel = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1079)
			p.Match(JavaParserASSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1080)
			p.expression(0)
		}
		p.SetState(1083)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserCOLON {
			{
				p.SetState(1081)
				p.Match(JavaParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1082)
				p.expression(0)
			}

		}
		{
			p.SetState(1085)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1087)
			p.Match(JavaParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1088)
			p.ParExpression()
		}
		{
			p.SetState(1089)
			p.Statement()
		}
		p.SetState(1092)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1090)
				p.Match(JavaParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1091)
				p.Statement()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1094)
			p.Match(JavaParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1095)
			p.Match(JavaParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1096)
			p.ForControl()
		}
		{
			p.SetState(1097)
			p.Match(JavaParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1098)
			p.Statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1100)
			p.Match(JavaParserWHILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1101)
			p.ParExpression()
		}
		{
			p.SetState(1102)
			p.Statement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1104)
			p.Match(JavaParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1105)
			p.Statement()
		}
		{
			p.SetState(1106)
			p.Match(JavaParserWHILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1107)
			p.ParExpression()
		}
		{
			p.SetState(1108)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1110)
			p.Match(JavaParserTRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1111)
			p.Block()
		}
		p.SetState(1121)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case JavaParserCATCH:
			p.SetState(1113)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == JavaParserCATCH {
				{
					p.SetState(1112)
					p.CatchClause()
				}

				p.SetState(1115)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(1118)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == JavaParserFINALLY {
				{
					p.SetState(1117)
					p.FinallyBlock()
				}

			}

		case JavaParserFINALLY:
			{
				p.SetState(1120)
				p.FinallyBlock()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1123)
			p.Match(JavaParserTRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1124)
			p.ResourceSpecification()
		}
		{
			p.SetState(1125)
			p.Block()
		}
		p.SetState(1129)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JavaParserCATCH {
			{
				p.SetState(1126)
				p.CatchClause()
			}

			p.SetState(1131)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1133)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserFINALLY {
			{
				p.SetState(1132)
				p.FinallyBlock()
			}

		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1135)
			p.Match(JavaParserSWITCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1136)
			p.ParExpression()
		}
		{
			p.SetState(1137)
			p.Match(JavaParserLBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1141)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 132, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1138)
					p.SwitchBlockStatementGroup()
				}

			}
			p.SetState(1143)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 132, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1147)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JavaParserCASE || _la == JavaParserDEFAULT {
			{
				p.SetState(1144)
				p.SwitchLabel()
			}

			p.SetState(1149)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1150)
			p.Match(JavaParserRBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1152)
			p.Match(JavaParserSYNCHRONIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1153)
			p.ParExpression()
		}
		{
			p.SetState(1154)
			p.Block()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1156)
			p.Match(JavaParserRETURN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1158)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-3)) & ^0x3f) == 0 && ((int64(1)<<(_la-3))&9223127275610966053) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&2377900732130004991) != 0) {
			{
				p.SetState(1157)
				p.expression(0)
			}

		}
		{
			p.SetState(1160)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1161)
			p.Match(JavaParserTHROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1162)
			p.expression(0)
		}
		{
			p.SetState(1163)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1165)
			p.Match(JavaParserBREAK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1167)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-51)) & ^0x3f) == 0 && ((int64(1)<<(_la-51))&32767) != 0) || _la == JavaParserIDENTIFIER {
			{
				p.SetState(1166)
				p.Identifier()
			}

		}
		{
			p.SetState(1169)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1170)
			p.Match(JavaParserCONTINUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1172)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-51)) & ^0x3f) == 0 && ((int64(1)<<(_la-51))&32767) != 0) || _la == JavaParserIDENTIFIER {
			{
				p.SetState(1171)
				p.Identifier()
			}

		}
		{
			p.SetState(1174)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1175)
			p.Match(JavaParserYIELD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1176)
			p.expression(0)
		}
		{
			p.SetState(1177)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1179)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1180)

			var _x = p.expression(0)

			localctx.(*StatementContext).statementExpression = _x
		}
		{
			p.SetState(1181)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1183)
			p.SwitchExpression()
		}
		p.SetState(1185)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 137, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1184)
				p.Match(JavaParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1187)

			var _x = p.Identifier()

			localctx.(*StatementContext).identifierLabel = _x
		}
		{
			p.SetState(1188)
			p.Match(JavaParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1189)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatchClauseContext is an interface to support dynamic dispatch.
type ICatchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CATCH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	CatchType() ICatchTypeContext
	Identifier() IIdentifierContext
	RPAREN() antlr.TerminalNode
	Block() IBlockContext
	AllVariableModifier() []IVariableModifierContext
	VariableModifier(i int) IVariableModifierContext

	// IsCatchClauseContext differentiates from other interfaces.
	IsCatchClauseContext()
}

type CatchClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchClauseContext() *CatchClauseContext {
	var p = new(CatchClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_catchClause
	return p
}

func InitEmptyCatchClauseContext(p *CatchClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_catchClause
}

func (*CatchClauseContext) IsCatchClauseContext() {}

func NewCatchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchClauseContext {
	var p = new(CatchClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_catchClause

	return p
}

func (s *CatchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchClauseContext) CATCH() antlr.TerminalNode {
	return s.GetToken(JavaParserCATCH, 0)
}

func (s *CatchClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *CatchClauseContext) CatchType() ICatchTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchTypeContext)
}

func (s *CatchClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CatchClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *CatchClauseContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchClauseContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *CatchClauseContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *CatchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterCatchClause(s)
	}
}

func (s *CatchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitCatchClause(s)
	}
}

func (s *CatchClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitCatchClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) CatchClause() (localctx ICatchClauseContext) {
	localctx = NewCatchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, JavaParserRULE_catchClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1193)
		p.Match(JavaParserCATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1194)
		p.Match(JavaParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1198)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1195)
				p.VariableModifier()
			}

		}
		p.SetState(1200)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1201)
		p.CatchType()
	}
	{
		p.SetState(1202)
		p.Identifier()
	}
	{
		p.SetState(1203)
		p.Match(JavaParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1204)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatchTypeContext is an interface to support dynamic dispatch.
type ICatchTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	AllBITOR() []antlr.TerminalNode
	BITOR(i int) antlr.TerminalNode

	// IsCatchTypeContext differentiates from other interfaces.
	IsCatchTypeContext()
}

type CatchTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchTypeContext() *CatchTypeContext {
	var p = new(CatchTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_catchType
	return p
}

func InitEmptyCatchTypeContext(p *CatchTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_catchType
}

func (*CatchTypeContext) IsCatchTypeContext() {}

func NewCatchTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchTypeContext {
	var p = new(CatchTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_catchType

	return p
}

func (s *CatchTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchTypeContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *CatchTypeContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CatchTypeContext) AllBITOR() []antlr.TerminalNode {
	return s.GetTokens(JavaParserBITOR)
}

func (s *CatchTypeContext) BITOR(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserBITOR, i)
}

func (s *CatchTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterCatchType(s)
	}
}

func (s *CatchTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitCatchType(s)
	}
}

func (s *CatchTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitCatchType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) CatchType() (localctx ICatchTypeContext) {
	localctx = NewCatchTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, JavaParserRULE_catchType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1206)
		p.QualifiedName()
	}
	p.SetState(1211)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserBITOR {
		{
			p.SetState(1207)
			p.Match(JavaParserBITOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1208)
			p.QualifiedName()
		}

		p.SetState(1213)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinallyBlockContext is an interface to support dynamic dispatch.
type IFinallyBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FINALLY() antlr.TerminalNode
	Block() IBlockContext

	// IsFinallyBlockContext differentiates from other interfaces.
	IsFinallyBlockContext()
}

type FinallyBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyBlockContext() *FinallyBlockContext {
	var p = new(FinallyBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_finallyBlock
	return p
}

func InitEmptyFinallyBlockContext(p *FinallyBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_finallyBlock
}

func (*FinallyBlockContext) IsFinallyBlockContext() {}

func NewFinallyBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyBlockContext {
	var p = new(FinallyBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_finallyBlock

	return p
}

func (s *FinallyBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyBlockContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(JavaParserFINALLY, 0)
}

func (s *FinallyBlockContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterFinallyBlock(s)
	}
}

func (s *FinallyBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitFinallyBlock(s)
	}
}

func (s *FinallyBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitFinallyBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) FinallyBlock() (localctx IFinallyBlockContext) {
	localctx = NewFinallyBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, JavaParserRULE_finallyBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1214)
		p.Match(JavaParserFINALLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1215)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceSpecificationContext is an interface to support dynamic dispatch.
type IResourceSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Resources() IResourcesContext
	RPAREN() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsResourceSpecificationContext differentiates from other interfaces.
	IsResourceSpecificationContext()
}

type ResourceSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceSpecificationContext() *ResourceSpecificationContext {
	var p = new(ResourceSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_resourceSpecification
	return p
}

func InitEmptyResourceSpecificationContext(p *ResourceSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_resourceSpecification
}

func (*ResourceSpecificationContext) IsResourceSpecificationContext() {}

func NewResourceSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceSpecificationContext {
	var p = new(ResourceSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_resourceSpecification

	return p
}

func (s *ResourceSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceSpecificationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *ResourceSpecificationContext) Resources() IResourcesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourcesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourcesContext)
}

func (s *ResourceSpecificationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *ResourceSpecificationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, 0)
}

func (s *ResourceSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterResourceSpecification(s)
	}
}

func (s *ResourceSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitResourceSpecification(s)
	}
}

func (s *ResourceSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitResourceSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ResourceSpecification() (localctx IResourceSpecificationContext) {
	localctx = NewResourceSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, JavaParserRULE_resourceSpecification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1217)
		p.Match(JavaParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1218)
		p.Resources()
	}
	p.SetState(1220)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserSEMI {
		{
			p.SetState(1219)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1222)
		p.Match(JavaParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourcesContext is an interface to support dynamic dispatch.
type IResourcesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllResource() []IResourceContext
	Resource(i int) IResourceContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsResourcesContext differentiates from other interfaces.
	IsResourcesContext()
}

type ResourcesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourcesContext() *ResourcesContext {
	var p = new(ResourcesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_resources
	return p
}

func InitEmptyResourcesContext(p *ResourcesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_resources
}

func (*ResourcesContext) IsResourcesContext() {}

func NewResourcesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourcesContext {
	var p = new(ResourcesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_resources

	return p
}

func (s *ResourcesContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourcesContext) AllResource() []IResourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceContext); ok {
			len++
		}
	}

	tst := make([]IResourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceContext); ok {
			tst[i] = t.(IResourceContext)
			i++
		}
	}

	return tst
}

func (s *ResourcesContext) Resource(i int) IResourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceContext)
}

func (s *ResourcesContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(JavaParserSEMI)
}

func (s *ResourcesContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, i)
}

func (s *ResourcesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourcesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourcesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterResources(s)
	}
}

func (s *ResourcesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitResources(s)
	}
}

func (s *ResourcesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitResources(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) Resources() (localctx IResourcesContext) {
	localctx = NewResourcesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, JavaParserRULE_resources)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1224)
		p.Resource()
	}
	p.SetState(1229)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1225)
				p.Match(JavaParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1226)
				p.Resource()
			}

		}
		p.SetState(1231)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceContext is an interface to support dynamic dispatch.
type IResourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext
	ClassOrInterfaceType() IClassOrInterfaceTypeContext
	VariableDeclaratorId() IVariableDeclaratorIdContext
	VAR() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllVariableModifier() []IVariableModifierContext
	VariableModifier(i int) IVariableModifierContext
	QualifiedName() IQualifiedNameContext

	// IsResourceContext differentiates from other interfaces.
	IsResourceContext()
}

type ResourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceContext() *ResourceContext {
	var p = new(ResourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_resource
	return p
}

func InitEmptyResourceContext(p *ResourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_resource
}

func (*ResourceContext) IsResourceContext() {}

func NewResourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceContext {
	var p = new(ResourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_resource

	return p
}

func (s *ResourceContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserASSIGN, 0)
}

func (s *ResourceContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ResourceContext) ClassOrInterfaceType() IClassOrInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeContext)
}

func (s *ResourceContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *ResourceContext) VAR() antlr.TerminalNode {
	return s.GetToken(JavaParserVAR, 0)
}

func (s *ResourceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResourceContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *ResourceContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *ResourceContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterResource(s)
	}
}

func (s *ResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitResource(s)
	}
}

func (s *ResourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitResource(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) Resource() (localctx IResourceContext) {
	localctx = NewResourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, JavaParserRULE_resource)
	var _alt int

	p.SetState(1249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1235)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1232)
					p.VariableModifier()
				}

			}
			p.SetState(1237)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1243)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 144, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1238)
				p.ClassOrInterfaceType()
			}
			{
				p.SetState(1239)
				p.VariableDeclaratorId()
			}

		case 2:
			{
				p.SetState(1241)
				p.Match(JavaParserVAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1242)
				p.Identifier()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(1245)
			p.Match(JavaParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1246)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1248)
			p.QualifiedName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchBlockStatementGroupContext is an interface to support dynamic dispatch.
type ISwitchBlockStatementGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSwitchLabel() []ISwitchLabelContext
	SwitchLabel(i int) ISwitchLabelContext
	AllBlockStatement() []IBlockStatementContext
	BlockStatement(i int) IBlockStatementContext

	// IsSwitchBlockStatementGroupContext differentiates from other interfaces.
	IsSwitchBlockStatementGroupContext()
}

type SwitchBlockStatementGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchBlockStatementGroupContext() *SwitchBlockStatementGroupContext {
	var p = new(SwitchBlockStatementGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_switchBlockStatementGroup
	return p
}

func InitEmptySwitchBlockStatementGroupContext(p *SwitchBlockStatementGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_switchBlockStatementGroup
}

func (*SwitchBlockStatementGroupContext) IsSwitchBlockStatementGroupContext() {}

func NewSwitchBlockStatementGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchBlockStatementGroupContext {
	var p = new(SwitchBlockStatementGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_switchBlockStatementGroup

	return p
}

func (s *SwitchBlockStatementGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchBlockStatementGroupContext) AllSwitchLabel() []ISwitchLabelContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchLabelContext); ok {
			len++
		}
	}

	tst := make([]ISwitchLabelContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchLabelContext); ok {
			tst[i] = t.(ISwitchLabelContext)
			i++
		}
	}

	return tst
}

func (s *SwitchBlockStatementGroupContext) SwitchLabel(i int) ISwitchLabelContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchLabelContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchLabelContext)
}

func (s *SwitchBlockStatementGroupContext) AllBlockStatement() []IBlockStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockStatementContext); ok {
			len++
		}
	}

	tst := make([]IBlockStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockStatementContext); ok {
			tst[i] = t.(IBlockStatementContext)
			i++
		}
	}

	return tst
}

func (s *SwitchBlockStatementGroupContext) BlockStatement(i int) IBlockStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *SwitchBlockStatementGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchBlockStatementGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchBlockStatementGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterSwitchBlockStatementGroup(s)
	}
}

func (s *SwitchBlockStatementGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitSwitchBlockStatementGroup(s)
	}
}

func (s *SwitchBlockStatementGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitSwitchBlockStatementGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) SwitchBlockStatementGroup() (localctx ISwitchBlockStatementGroupContext) {
	localctx = NewSwitchBlockStatementGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, JavaParserRULE_switchBlockStatementGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1252)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == JavaParserCASE || _la == JavaParserDEFAULT {
		{
			p.SetState(1251)
			p.SwitchLabel()
		}

		p.SetState(1254)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1257)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-334254282492513) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-8935141145188974593) != 0) {
		{
			p.SetState(1256)
			p.BlockStatement()
		}

		p.SetState(1259)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchLabelContext is an interface to support dynamic dispatch.
type ISwitchLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetEnumConstantName returns the enumConstantName token.
	GetEnumConstantName() antlr.Token

	// SetEnumConstantName sets the enumConstantName token.
	SetEnumConstantName(antlr.Token)

	// GetConstantExpression returns the constantExpression rule contexts.
	GetConstantExpression() IExpressionContext

	// GetVarName returns the varName rule contexts.
	GetVarName() IIdentifierContext

	// SetConstantExpression sets the constantExpression rule contexts.
	SetConstantExpression(IExpressionContext)

	// SetVarName sets the varName rule contexts.
	SetVarName(IIdentifierContext)

	// Getter signatures
	CASE() antlr.TerminalNode
	COLON() antlr.TerminalNode
	TypeType() ITypeTypeContext
	Expression() IExpressionContext
	IDENTIFIER() antlr.TerminalNode
	Identifier() IIdentifierContext
	DEFAULT() antlr.TerminalNode

	// IsSwitchLabelContext differentiates from other interfaces.
	IsSwitchLabelContext()
}

type SwitchLabelContext struct {
	antlr.BaseParserRuleContext
	parser             antlr.Parser
	constantExpression IExpressionContext
	enumConstantName   antlr.Token
	varName            IIdentifierContext
}

func NewEmptySwitchLabelContext() *SwitchLabelContext {
	var p = new(SwitchLabelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_switchLabel
	return p
}

func InitEmptySwitchLabelContext(p *SwitchLabelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_switchLabel
}

func (*SwitchLabelContext) IsSwitchLabelContext() {}

func NewSwitchLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchLabelContext {
	var p = new(SwitchLabelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_switchLabel

	return p
}

func (s *SwitchLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchLabelContext) GetEnumConstantName() antlr.Token { return s.enumConstantName }

func (s *SwitchLabelContext) SetEnumConstantName(v antlr.Token) { s.enumConstantName = v }

func (s *SwitchLabelContext) GetConstantExpression() IExpressionContext { return s.constantExpression }

func (s *SwitchLabelContext) GetVarName() IIdentifierContext { return s.varName }

func (s *SwitchLabelContext) SetConstantExpression(v IExpressionContext) { s.constantExpression = v }

func (s *SwitchLabelContext) SetVarName(v IIdentifierContext) { s.varName = v }

func (s *SwitchLabelContext) CASE() antlr.TerminalNode {
	return s.GetToken(JavaParserCASE, 0)
}

func (s *SwitchLabelContext) COLON() antlr.TerminalNode {
	return s.GetToken(JavaParserCOLON, 0)
}

func (s *SwitchLabelContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *SwitchLabelContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SwitchLabelContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(JavaParserIDENTIFIER, 0)
}

func (s *SwitchLabelContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SwitchLabelContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(JavaParserDEFAULT, 0)
}

func (s *SwitchLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterSwitchLabel(s)
	}
}

func (s *SwitchLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitSwitchLabel(s)
	}
}

func (s *SwitchLabelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitSwitchLabel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) SwitchLabel() (localctx ISwitchLabelContext) {
	localctx = NewSwitchLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, JavaParserRULE_switchLabel)
	p.SetState(1272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserCASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1261)
			p.Match(JavaParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1267)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1262)

				var _x = p.expression(0)

				localctx.(*SwitchLabelContext).constantExpression = _x
			}

		case 2:
			{
				p.SetState(1263)

				var _m = p.Match(JavaParserIDENTIFIER)

				localctx.(*SwitchLabelContext).enumConstantName = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(1264)
				p.TypeType()
			}
			{
				p.SetState(1265)

				var _x = p.Identifier()

				localctx.(*SwitchLabelContext).varName = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(1269)
			p.Match(JavaParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1270)
			p.Match(JavaParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1271)
			p.Match(JavaParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForControlContext is an interface to support dynamic dispatch.
type IForControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetForUpdate returns the forUpdate rule contexts.
	GetForUpdate() IExpressionListContext

	// SetForUpdate sets the forUpdate rule contexts.
	SetForUpdate(IExpressionListContext)

	// Getter signatures
	EnhancedForControl() IEnhancedForControlContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	ForInit() IForInitContext
	Expression() IExpressionContext
	ExpressionList() IExpressionListContext

	// IsForControlContext differentiates from other interfaces.
	IsForControlContext()
}

type ForControlContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	forUpdate IExpressionListContext
}

func NewEmptyForControlContext() *ForControlContext {
	var p = new(ForControlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_forControl
	return p
}

func InitEmptyForControlContext(p *ForControlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_forControl
}

func (*ForControlContext) IsForControlContext() {}

func NewForControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForControlContext {
	var p = new(ForControlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_forControl

	return p
}

func (s *ForControlContext) GetParser() antlr.Parser { return s.parser }

func (s *ForControlContext) GetForUpdate() IExpressionListContext { return s.forUpdate }

func (s *ForControlContext) SetForUpdate(v IExpressionListContext) { s.forUpdate = v }

func (s *ForControlContext) EnhancedForControl() IEnhancedForControlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnhancedForControlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnhancedForControlContext)
}

func (s *ForControlContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(JavaParserSEMI)
}

func (s *ForControlContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserSEMI, i)
}

func (s *ForControlContext) ForInit() IForInitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForInitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForInitContext)
}

func (s *ForControlContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForControlContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForControlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterForControl(s)
	}
}

func (s *ForControlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitForControl(s)
	}
}

func (s *ForControlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitForControl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ForControl() (localctx IForControlContext) {
	localctx = NewForControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, JavaParserRULE_forControl)
	var _la int

	p.SetState(1286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1274)
			p.EnhancedForControl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1276)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-3)) & ^0x3f) == 0 && ((int64(1)<<(_la-3))&9223127275610998821) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&2377900732130004991) != 0) {
			{
				p.SetState(1275)
				p.ForInit()
			}

		}
		{
			p.SetState(1278)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1280)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-3)) & ^0x3f) == 0 && ((int64(1)<<(_la-3))&9223127275610966053) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&2377900732130004991) != 0) {
			{
				p.SetState(1279)
				p.expression(0)
			}

		}
		{
			p.SetState(1282)
			p.Match(JavaParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1284)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-3)) & ^0x3f) == 0 && ((int64(1)<<(_la-3))&9223127275610966053) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&2377900732130004991) != 0) {
			{
				p.SetState(1283)

				var _x = p.ExpressionList()

				localctx.(*ForControlContext).forUpdate = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForInitContext is an interface to support dynamic dispatch.
type IForInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LocalVariableDeclaration() ILocalVariableDeclarationContext
	ExpressionList() IExpressionListContext

	// IsForInitContext differentiates from other interfaces.
	IsForInitContext()
}

type ForInitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInitContext() *ForInitContext {
	var p = new(ForInitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_forInit
	return p
}

func InitEmptyForInitContext(p *ForInitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_forInit
}

func (*ForInitContext) IsForInitContext() {}

func NewForInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInitContext {
	var p = new(ForInitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_forInit

	return p
}

func (s *ForInitContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInitContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *ForInitContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForInitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterForInit(s)
	}
}

func (s *ForInitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitForInit(s)
	}
}

func (s *ForInitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitForInit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ForInit() (localctx IForInitContext) {
	localctx = NewForInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, JavaParserRULE_forInit)
	p.SetState(1290)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1288)
			p.LocalVariableDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1289)
			p.ExpressionList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnhancedForControlContext is an interface to support dynamic dispatch.
type IEnhancedForControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDeclaratorId() IVariableDeclaratorIdContext
	COLON() antlr.TerminalNode
	Expression() IExpressionContext
	TypeType() ITypeTypeContext
	VAR() antlr.TerminalNode
	AllVariableModifier() []IVariableModifierContext
	VariableModifier(i int) IVariableModifierContext

	// IsEnhancedForControlContext differentiates from other interfaces.
	IsEnhancedForControlContext()
}

type EnhancedForControlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedForControlContext() *EnhancedForControlContext {
	var p = new(EnhancedForControlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_enhancedForControl
	return p
}

func InitEmptyEnhancedForControlContext(p *EnhancedForControlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_enhancedForControl
}

func (*EnhancedForControlContext) IsEnhancedForControlContext() {}

func NewEnhancedForControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedForControlContext {
	var p = new(EnhancedForControlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_enhancedForControl

	return p
}

func (s *EnhancedForControlContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedForControlContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclaratorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *EnhancedForControlContext) COLON() antlr.TerminalNode {
	return s.GetToken(JavaParserCOLON, 0)
}

func (s *EnhancedForControlContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnhancedForControlContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *EnhancedForControlContext) VAR() antlr.TerminalNode {
	return s.GetToken(JavaParserVAR, 0)
}

func (s *EnhancedForControlContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *EnhancedForControlContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *EnhancedForControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedForControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnhancedForControlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterEnhancedForControl(s)
	}
}

func (s *EnhancedForControlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitEnhancedForControl(s)
	}
}

func (s *EnhancedForControlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitEnhancedForControl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) EnhancedForControl() (localctx IEnhancedForControlContext) {
	localctx = NewEnhancedForControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, JavaParserRULE_enhancedForControl)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 155, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1292)
				p.VariableModifier()
			}

		}
		p.SetState(1297)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 155, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1300)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1298)
			p.TypeType()
		}

	case 2:
		{
			p.SetState(1299)
			p.Match(JavaParserVAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(1302)
		p.VariableDeclaratorId()
	}
	{
		p.SetState(1303)
		p.Match(JavaParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1304)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParExpressionContext is an interface to support dynamic dispatch.
type IParExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsParExpressionContext differentiates from other interfaces.
	IsParExpressionContext()
}

type ParExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParExpressionContext() *ParExpressionContext {
	var p = new(ParExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_parExpression
	return p
}

func InitEmptyParExpressionContext(p *ParExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_parExpression
}

func (*ParExpressionContext) IsParExpressionContext() {}

func NewParExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParExpressionContext {
	var p = new(ParExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_parExpression

	return p
}

func (s *ParExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *ParExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *ParExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterParExpression(s)
	}
}

func (s *ParExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitParExpression(s)
	}
}

func (s *ParExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitParExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ParExpression() (localctx IParExpressionContext) {
	localctx = NewParExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, JavaParserRULE_parExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1306)
		p.Match(JavaParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1307)
		p.expression(0)
	}
	{
		p.SetState(1308)
		p.Match(JavaParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *ExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, JavaParserRULE_expressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1310)
		p.expression(0)
	}
	p.SetState(1315)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCOMMA {
		{
			p.SetState(1311)
			p.Match(JavaParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1312)
			p.expression(0)
		}

		p.SetState(1317)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodCallContext is an interface to support dynamic dispatch.
type IMethodCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Arguments() IArgumentsContext
	Identifier() IIdentifierContext
	THIS() antlr.TerminalNode
	SUPER() antlr.TerminalNode

	// IsMethodCallContext differentiates from other interfaces.
	IsMethodCallContext()
}

type MethodCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodCallContext() *MethodCallContext {
	var p = new(MethodCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_methodCall
	return p
}

func InitEmptyMethodCallContext(p *MethodCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_methodCall
}

func (*MethodCallContext) IsMethodCallContext() {}

func NewMethodCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodCallContext {
	var p = new(MethodCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_methodCall

	return p
}

func (s *MethodCallContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodCallContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *MethodCallContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodCallContext) THIS() antlr.TerminalNode {
	return s.GetToken(JavaParserTHIS, 0)
}

func (s *MethodCallContext) SUPER() antlr.TerminalNode {
	return s.GetToken(JavaParserSUPER, 0)
}

func (s *MethodCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterMethodCall(s)
	}
}

func (s *MethodCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitMethodCall(s)
	}
}

func (s *MethodCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitMethodCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) MethodCall() (localctx IMethodCallContext) {
	localctx = NewMethodCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, JavaParserRULE_methodCall)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1321)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserIDENTIFIER:
		{
			p.SetState(1318)
			p.Identifier()
		}

	case JavaParserTHIS:
		{
			p.SetState(1319)
			p.Match(JavaParserTHIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaParserSUPER:
		{
			p.SetState(1320)
			p.Match(JavaParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1323)
		p.Arguments()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPrefix returns the prefix token.
	GetPrefix() antlr.Token

	// GetBop returns the bop token.
	GetBop() antlr.Token

	// GetPostfix returns the postfix token.
	GetPostfix() antlr.Token

	// SetPrefix sets the prefix token.
	SetPrefix(antlr.Token)

	// SetBop sets the bop token.
	SetBop(antlr.Token)

	// SetPostfix sets the postfix token.
	SetPostfix(antlr.Token)

	// Getter signatures
	Primary() IPrimaryContext
	MethodCall() IMethodCallContext
	AllTypeType() []ITypeTypeContext
	TypeType(i int) ITypeTypeContext
	COLONCOLON() antlr.TerminalNode
	Identifier() IIdentifierContext
	NEW() antlr.TerminalNode
	TypeArguments() ITypeArgumentsContext
	ClassType() IClassTypeContext
	SwitchExpression() ISwitchExpressionContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	ADD() antlr.TerminalNode
	SUB() antlr.TerminalNode
	INC() antlr.TerminalNode
	DEC() antlr.TerminalNode
	TILDE() antlr.TerminalNode
	BANG() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	AllBITAND() []antlr.TerminalNode
	BITAND(i int) antlr.TerminalNode
	Creator() ICreatorContext
	LambdaExpression() ILambdaExpressionContext
	MUL() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode
	AllLT() []antlr.TerminalNode
	LT(i int) antlr.TerminalNode
	AllGT() []antlr.TerminalNode
	GT(i int) antlr.TerminalNode
	LE() antlr.TerminalNode
	GE() antlr.TerminalNode
	EQUAL() antlr.TerminalNode
	NOTEQUAL() antlr.TerminalNode
	CARET() antlr.TerminalNode
	BITOR() antlr.TerminalNode
	AND() antlr.TerminalNode
	OR() antlr.TerminalNode
	COLON() antlr.TerminalNode
	QUESTION() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	ADD_ASSIGN() antlr.TerminalNode
	SUB_ASSIGN() antlr.TerminalNode
	MUL_ASSIGN() antlr.TerminalNode
	DIV_ASSIGN() antlr.TerminalNode
	AND_ASSIGN() antlr.TerminalNode
	OR_ASSIGN() antlr.TerminalNode
	XOR_ASSIGN() antlr.TerminalNode
	RSHIFT_ASSIGN() antlr.TerminalNode
	URSHIFT_ASSIGN() antlr.TerminalNode
	LSHIFT_ASSIGN() antlr.TerminalNode
	MOD_ASSIGN() antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	DOT() antlr.TerminalNode
	THIS() antlr.TerminalNode
	InnerCreator() IInnerCreatorContext
	SUPER() antlr.TerminalNode
	SuperSuffix() ISuperSuffixContext
	ExplicitGenericInvocation() IExplicitGenericInvocationContext
	NonWildcardTypeArguments() INonWildcardTypeArgumentsContext
	INSTANCEOF() antlr.TerminalNode
	Pattern() IPatternContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	prefix  antlr.Token
	bop     antlr.Token
	postfix antlr.Token
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) GetPrefix() antlr.Token { return s.prefix }

func (s *ExpressionContext) GetBop() antlr.Token { return s.bop }

func (s *ExpressionContext) GetPostfix() antlr.Token { return s.postfix }

func (s *ExpressionContext) SetPrefix(v antlr.Token) { s.prefix = v }

func (s *ExpressionContext) SetBop(v antlr.Token) { s.bop = v }

func (s *ExpressionContext) SetPostfix(v antlr.Token) { s.postfix = v }

func (s *ExpressionContext) Primary() IPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *ExpressionContext) MethodCall() IMethodCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodCallContext)
}

func (s *ExpressionContext) AllTypeType() []ITypeTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeTypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeTypeContext); ok {
			tst[i] = t.(ITypeTypeContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) TypeType(i int) ITypeTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *ExpressionContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(JavaParserCOLONCOLON, 0)
}

func (s *ExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExpressionContext) NEW() antlr.TerminalNode {
	return s.GetToken(JavaParserNEW, 0)
}

func (s *ExpressionContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ExpressionContext) ClassType() IClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *ExpressionContext) SwitchExpression() ISwitchExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchExpressionContext)
}

func (s *ExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) ADD() antlr.TerminalNode {
	return s.GetToken(JavaParserADD, 0)
}

func (s *ExpressionContext) SUB() antlr.TerminalNode {
	return s.GetToken(JavaParserSUB, 0)
}

func (s *ExpressionContext) INC() antlr.TerminalNode {
	return s.GetToken(JavaParserINC, 0)
}

func (s *ExpressionContext) DEC() antlr.TerminalNode {
	return s.GetToken(JavaParserDEC, 0)
}

func (s *ExpressionContext) TILDE() antlr.TerminalNode {
	return s.GetToken(JavaParserTILDE, 0)
}

func (s *ExpressionContext) BANG() antlr.TerminalNode {
	return s.GetToken(JavaParserBANG, 0)
}

func (s *ExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *ExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *ExpressionContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ExpressionContext) AllBITAND() []antlr.TerminalNode {
	return s.GetTokens(JavaParserBITAND)
}

func (s *ExpressionContext) BITAND(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserBITAND, i)
}

func (s *ExpressionContext) Creator() ICreatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatorContext)
}

func (s *ExpressionContext) LambdaExpression() ILambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *ExpressionContext) MUL() antlr.TerminalNode {
	return s.GetToken(JavaParserMUL, 0)
}

func (s *ExpressionContext) DIV() antlr.TerminalNode {
	return s.GetToken(JavaParserDIV, 0)
}

func (s *ExpressionContext) MOD() antlr.TerminalNode {
	return s.GetToken(JavaParserMOD, 0)
}

func (s *ExpressionContext) AllLT() []antlr.TerminalNode {
	return s.GetTokens(JavaParserLT)
}

func (s *ExpressionContext) LT(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserLT, i)
}

func (s *ExpressionContext) AllGT() []antlr.TerminalNode {
	return s.GetTokens(JavaParserGT)
}

func (s *ExpressionContext) GT(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserGT, i)
}

func (s *ExpressionContext) LE() antlr.TerminalNode {
	return s.GetToken(JavaParserLE, 0)
}

func (s *ExpressionContext) GE() antlr.TerminalNode {
	return s.GetToken(JavaParserGE, 0)
}

func (s *ExpressionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(JavaParserEQUAL, 0)
}

func (s *ExpressionContext) NOTEQUAL() antlr.TerminalNode {
	return s.GetToken(JavaParserNOTEQUAL, 0)
}

func (s *ExpressionContext) CARET() antlr.TerminalNode {
	return s.GetToken(JavaParserCARET, 0)
}

func (s *ExpressionContext) BITOR() antlr.TerminalNode {
	return s.GetToken(JavaParserBITOR, 0)
}

func (s *ExpressionContext) AND() antlr.TerminalNode {
	return s.GetToken(JavaParserAND, 0)
}

func (s *ExpressionContext) OR() antlr.TerminalNode {
	return s.GetToken(JavaParserOR, 0)
}

func (s *ExpressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(JavaParserCOLON, 0)
}

func (s *ExpressionContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(JavaParserQUESTION, 0)
}

func (s *ExpressionContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserASSIGN, 0)
}

func (s *ExpressionContext) ADD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserADD_ASSIGN, 0)
}

func (s *ExpressionContext) SUB_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserSUB_ASSIGN, 0)
}

func (s *ExpressionContext) MUL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserMUL_ASSIGN, 0)
}

func (s *ExpressionContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserDIV_ASSIGN, 0)
}

func (s *ExpressionContext) AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserAND_ASSIGN, 0)
}

func (s *ExpressionContext) OR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserOR_ASSIGN, 0)
}

func (s *ExpressionContext) XOR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserXOR_ASSIGN, 0)
}

func (s *ExpressionContext) RSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserRSHIFT_ASSIGN, 0)
}

func (s *ExpressionContext) URSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserURSHIFT_ASSIGN, 0)
}

func (s *ExpressionContext) LSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserLSHIFT_ASSIGN, 0)
}

func (s *ExpressionContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(JavaParserMOD_ASSIGN, 0)
}

func (s *ExpressionContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACK, 0)
}

func (s *ExpressionContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACK, 0)
}

func (s *ExpressionContext) DOT() antlr.TerminalNode {
	return s.GetToken(JavaParserDOT, 0)
}

func (s *ExpressionContext) THIS() antlr.TerminalNode {
	return s.GetToken(JavaParserTHIS, 0)
}

func (s *ExpressionContext) InnerCreator() IInnerCreatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerCreatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerCreatorContext)
}

func (s *ExpressionContext) SUPER() antlr.TerminalNode {
	return s.GetToken(JavaParserSUPER, 0)
}

func (s *ExpressionContext) SuperSuffix() ISuperSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuperSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuperSuffixContext)
}

func (s *ExpressionContext) ExplicitGenericInvocation() IExplicitGenericInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplicitGenericInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplicitGenericInvocationContext)
}

func (s *ExpressionContext) NonWildcardTypeArguments() INonWildcardTypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonWildcardTypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonWildcardTypeArgumentsContext)
}

func (s *ExpressionContext) INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(JavaParserINSTANCEOF, 0)
}

func (s *ExpressionContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *JavaParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 198
	p.EnterRecursionRule(localctx, 198, JavaParserRULE_expression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 164, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1326)
			p.Primary()
		}

	case 2:
		{
			p.SetState(1327)
			p.MethodCall()
		}

	case 3:
		{
			p.SetState(1328)
			p.TypeType()
		}
		{
			p.SetState(1329)
			p.Match(JavaParserCOLONCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1335)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserLT, JavaParserIDENTIFIER:
			p.SetState(1331)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == JavaParserLT {
				{
					p.SetState(1330)
					p.TypeArguments()
				}

			}
			{
				p.SetState(1333)
				p.Identifier()
			}

		case JavaParserNEW:
			{
				p.SetState(1334)
				p.Match(JavaParserNEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		{
			p.SetState(1337)
			p.ClassType()
		}
		{
			p.SetState(1338)
			p.Match(JavaParserCOLONCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1340)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserLT {
			{
				p.SetState(1339)
				p.TypeArguments()
			}

		}
		{
			p.SetState(1342)
			p.Match(JavaParserNEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		{
			p.SetState(1344)
			p.SwitchExpression()
		}

	case 6:
		{
			p.SetState(1345)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExpressionContext).prefix = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-90)) & ^0x3f) == 0 && ((int64(1)<<(_la-90))&15363) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExpressionContext).prefix = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1346)
			p.expression(17)
		}

	case 7:
		{
			p.SetState(1347)
			p.Match(JavaParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1351)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1348)
					p.Annotation()
				}

			}
			p.SetState(1353)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(1354)
			p.TypeType()
		}
		p.SetState(1359)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JavaParserBITAND {
			{
				p.SetState(1355)
				p.Match(JavaParserBITAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1356)
				p.TypeType()
			}

			p.SetState(1361)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1362)
			p.Match(JavaParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1363)
			p.expression(16)
		}

	case 8:
		{
			p.SetState(1365)
			p.Match(JavaParserNEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1366)
			p.Creator()
		}

	case 9:
		{
			p.SetState(1367)
			p.LambdaExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1451)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1370)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(1371)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).bop = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-104)) & ^0x3f) == 0 && ((int64(1)<<(_la-104))&35) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).bop = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1372)
					p.expression(15)
				}

			case 2:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1373)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(1374)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).bop = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == JavaParserADD || _la == JavaParserSUB) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).bop = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1375)
					p.expression(14)
				}

			case 3:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1376)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				p.SetState(1384)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 165, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(1377)
						p.Match(JavaParserLT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1378)
						p.Match(JavaParserLT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 2:
					{
						p.SetState(1379)
						p.Match(JavaParserGT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1380)
						p.Match(JavaParserGT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1381)
						p.Match(JavaParserGT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 3:
					{
						p.SetState(1382)
						p.Match(JavaParserGT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1383)
						p.Match(JavaParserGT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}
				{
					p.SetState(1386)
					p.expression(13)
				}

			case 4:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1387)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(1388)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).bop = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-88)) & ^0x3f) == 0 && ((int64(1)<<(_la-88))&387) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).bop = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1389)
					p.expression(12)
				}

			case 5:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1390)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(1391)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).bop = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == JavaParserEQUAL || _la == JavaParserNOTEQUAL) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).bop = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1392)
					p.expression(10)
				}

			case 6:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1393)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(1394)

					var _m = p.Match(JavaParserBITAND)

					localctx.(*ExpressionContext).bop = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1395)
					p.expression(9)
				}

			case 7:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1396)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(1397)

					var _m = p.Match(JavaParserCARET)

					localctx.(*ExpressionContext).bop = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1398)
					p.expression(8)
				}

			case 8:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1399)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(1400)

					var _m = p.Match(JavaParserBITOR)

					localctx.(*ExpressionContext).bop = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1401)
					p.expression(7)
				}

			case 9:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1402)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(1403)

					var _m = p.Match(JavaParserAND)

					localctx.(*ExpressionContext).bop = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1404)
					p.expression(6)
				}

			case 10:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1405)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(1406)

					var _m = p.Match(JavaParserOR)

					localctx.(*ExpressionContext).bop = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1407)
					p.expression(5)
				}

			case 11:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1408)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(1409)

					var _m = p.Match(JavaParserQUESTION)

					localctx.(*ExpressionContext).bop = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1410)
					p.expression(0)
				}
				{
					p.SetState(1411)
					p.Match(JavaParserCOLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1412)
					p.expression(3)
				}

			case 12:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1414)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(1415)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).bop = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&17171480577) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).bop = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1416)
					p.expression(2)
				}

			case 13:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1417)

				if !(p.Precpred(p.GetParserRuleContext(), 25)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 25)", ""))
					goto errorExit
				}
				{
					p.SetState(1418)
					p.Match(JavaParserLBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1419)
					p.expression(0)
				}
				{
					p.SetState(1420)
					p.Match(JavaParserRBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 14:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1422)

				if !(p.Precpred(p.GetParserRuleContext(), 24)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 24)", ""))
					goto errorExit
				}
				{
					p.SetState(1423)

					var _m = p.Match(JavaParserDOT)

					localctx.(*ExpressionContext).bop = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1435)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 167, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(1424)
						p.Identifier()
					}

				case 2:
					{
						p.SetState(1425)
						p.MethodCall()
					}

				case 3:
					{
						p.SetState(1426)
						p.Match(JavaParserTHIS)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 4:
					{
						p.SetState(1427)
						p.Match(JavaParserNEW)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					p.SetState(1429)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == JavaParserLT {
						{
							p.SetState(1428)
							p.NonWildcardTypeArguments()
						}

					}
					{
						p.SetState(1431)
						p.InnerCreator()
					}

				case 5:
					{
						p.SetState(1432)
						p.Match(JavaParserSUPER)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1433)
						p.SuperSuffix()
					}

				case 6:
					{
						p.SetState(1434)
						p.ExplicitGenericInvocation()
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}

			case 15:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1437)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
					goto errorExit
				}
				{
					p.SetState(1438)
					p.Match(JavaParserCOLONCOLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1440)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == JavaParserLT {
					{
						p.SetState(1439)
						p.TypeArguments()
					}

				}
				{
					p.SetState(1442)
					p.Identifier()
				}

			case 16:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1443)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
					goto errorExit
				}
				{
					p.SetState(1444)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpressionContext).postfix = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == JavaParserINC || _la == JavaParserDEC) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpressionContext).postfix = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case 17:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_expression)
				p.SetState(1445)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				{
					p.SetState(1446)

					var _m = p.Match(JavaParserINSTANCEOF)

					localctx.(*ExpressionContext).bop = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1449)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(1447)
						p.TypeType()
					}

				case 2:
					{
						p.SetState(1448)
						p.Pattern()
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1455)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternContext is an interface to support dynamic dispatch.
type IPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeType() ITypeTypeContext
	Identifier() IIdentifierContext
	AllVariableModifier() []IVariableModifierContext
	VariableModifier(i int) IVariableModifierContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext

	// IsPatternContext differentiates from other interfaces.
	IsPatternContext()
}

type PatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternContext() *PatternContext {
	var p = new(PatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_pattern
	return p
}

func InitEmptyPatternContext(p *PatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_pattern
}

func (*PatternContext) IsPatternContext() {}

func NewPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternContext {
	var p = new(PatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_pattern

	return p
}

func (s *PatternContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *PatternContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PatternContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *PatternContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *PatternContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *PatternContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *PatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterPattern(s)
	}
}

func (s *PatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitPattern(s)
	}
}

func (s *PatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) Pattern() (localctx IPatternContext) {
	localctx = NewPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, JavaParserRULE_pattern)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1459)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 172, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1456)
				p.VariableModifier()
			}

		}
		p.SetState(1461)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 172, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1462)
		p.TypeType()
	}
	p.SetState(1466)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 173, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1463)
				p.Annotation()
			}

		}
		p.SetState(1468)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 173, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1469)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaExpressionContext is an interface to support dynamic dispatch.
type ILambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LambdaParameters() ILambdaParametersContext
	ARROW() antlr.TerminalNode
	LambdaBody() ILambdaBodyContext

	// IsLambdaExpressionContext differentiates from other interfaces.
	IsLambdaExpressionContext()
}

type LambdaExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaExpressionContext() *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_lambdaExpression
	return p
}

func InitEmptyLambdaExpressionContext(p *LambdaExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_lambdaExpression
}

func (*LambdaExpressionContext) IsLambdaExpressionContext() {}

func NewLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_lambdaExpression

	return p
}

func (s *LambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaExpressionContext) LambdaParameters() ILambdaParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaParametersContext)
}

func (s *LambdaExpressionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(JavaParserARROW, 0)
}

func (s *LambdaExpressionContext) LambdaBody() ILambdaBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaBodyContext)
}

func (s *LambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterLambdaExpression(s)
	}
}

func (s *LambdaExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitLambdaExpression(s)
	}
}

func (s *LambdaExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitLambdaExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) LambdaExpression() (localctx ILambdaExpressionContext) {
	localctx = NewLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, JavaParserRULE_lambdaExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1471)
		p.LambdaParameters()
	}
	{
		p.SetState(1472)
		p.Match(JavaParserARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1473)
		p.LambdaBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaParametersContext is an interface to support dynamic dispatch.
type ILambdaParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	LambdaLVTIList() ILambdaLVTIListContext

	// IsLambdaParametersContext differentiates from other interfaces.
	IsLambdaParametersContext()
}

type LambdaParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParametersContext() *LambdaParametersContext {
	var p = new(LambdaParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_lambdaParameters
	return p
}

func InitEmptyLambdaParametersContext(p *LambdaParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_lambdaParameters
}

func (*LambdaParametersContext) IsLambdaParametersContext() {}

func NewLambdaParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParametersContext {
	var p = new(LambdaParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_lambdaParameters

	return p
}

func (s *LambdaParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParametersContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LambdaParametersContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *LambdaParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *LambdaParametersContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *LambdaParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *LambdaParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *LambdaParametersContext) LambdaLVTIList() ILambdaLVTIListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaLVTIListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaLVTIListContext)
}

func (s *LambdaParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterLambdaParameters(s)
	}
}

func (s *LambdaParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitLambdaParameters(s)
	}
}

func (s *LambdaParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitLambdaParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) LambdaParameters() (localctx ILambdaParametersContext) {
	localctx = NewLambdaParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, JavaParserRULE_lambdaParameters)
	var _la int

	p.SetState(1497)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1475)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1476)
			p.Match(JavaParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1478)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-3)) & ^0x3f) == 0 && ((int64(1)<<(_la-3))&9223090579141986341) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
			{
				p.SetState(1477)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(1480)
			p.Match(JavaParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1481)
			p.Match(JavaParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1482)
			p.Identifier()
		}
		p.SetState(1487)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JavaParserCOMMA {
			{
				p.SetState(1483)
				p.Match(JavaParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1484)
				p.Identifier()
			}

			p.SetState(1489)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1490)
			p.Match(JavaParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1492)
			p.Match(JavaParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1494)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-18)) & ^0x3f) == 0 && ((int64(1)<<(_la-18))&281466386776065) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
			{
				p.SetState(1493)
				p.LambdaLVTIList()
			}

		}
		{
			p.SetState(1496)
			p.Match(JavaParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaBodyContext is an interface to support dynamic dispatch.
type ILambdaBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Block() IBlockContext

	// IsLambdaBodyContext differentiates from other interfaces.
	IsLambdaBodyContext()
}

type LambdaBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaBodyContext() *LambdaBodyContext {
	var p = new(LambdaBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_lambdaBody
	return p
}

func InitEmptyLambdaBodyContext(p *LambdaBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_lambdaBody
}

func (*LambdaBodyContext) IsLambdaBodyContext() {}

func NewLambdaBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaBodyContext {
	var p = new(LambdaBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_lambdaBody

	return p
}

func (s *LambdaBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaBodyContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *LambdaBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterLambdaBody(s)
	}
}

func (s *LambdaBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitLambdaBody(s)
	}
}

func (s *LambdaBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitLambdaBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) LambdaBody() (localctx ILambdaBodyContext) {
	localctx = NewLambdaBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, JavaParserRULE_lambdaBody)
	p.SetState(1501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserBOOLEAN, JavaParserBYTE, JavaParserCHAR, JavaParserDOUBLE, JavaParserFLOAT, JavaParserINT, JavaParserLONG, JavaParserNEW, JavaParserSHORT, JavaParserSUPER, JavaParserSWITCH, JavaParserTHIS, JavaParserVOID, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserDECIMAL_LITERAL, JavaParserHEX_LITERAL, JavaParserOCT_LITERAL, JavaParserBINARY_LITERAL, JavaParserFLOAT_LITERAL, JavaParserHEX_FLOAT_LITERAL, JavaParserBOOL_LITERAL, JavaParserCHAR_LITERAL, JavaParserSTRING_LITERAL, JavaParserTEXT_BLOCK, JavaParserNULL_LITERAL, JavaParserLPAREN, JavaParserLT, JavaParserBANG, JavaParserTILDE, JavaParserINC, JavaParserDEC, JavaParserADD, JavaParserSUB, JavaParserAT, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1499)
			p.expression(0)
		}

	case JavaParserLBRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1500)
			p.Block()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	THIS() antlr.TerminalNode
	SUPER() antlr.TerminalNode
	Literal() ILiteralContext
	Identifier() IIdentifierContext
	TypeTypeOrVoid() ITypeTypeOrVoidContext
	DOT() antlr.TerminalNode
	CLASS() antlr.TerminalNode
	NonWildcardTypeArguments() INonWildcardTypeArgumentsContext
	ExplicitGenericInvocationSuffix() IExplicitGenericInvocationSuffixContext
	Arguments() IArgumentsContext

	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_primary
	return p
}

func InitEmptyPrimaryContext(p *PrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_primary
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *PrimaryContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *PrimaryContext) THIS() antlr.TerminalNode {
	return s.GetToken(JavaParserTHIS, 0)
}

func (s *PrimaryContext) SUPER() antlr.TerminalNode {
	return s.GetToken(JavaParserSUPER, 0)
}

func (s *PrimaryContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrimaryContext) TypeTypeOrVoid() ITypeTypeOrVoidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeOrVoidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeOrVoidContext)
}

func (s *PrimaryContext) DOT() antlr.TerminalNode {
	return s.GetToken(JavaParserDOT, 0)
}

func (s *PrimaryContext) CLASS() antlr.TerminalNode {
	return s.GetToken(JavaParserCLASS, 0)
}

func (s *PrimaryContext) NonWildcardTypeArguments() INonWildcardTypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonWildcardTypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonWildcardTypeArgumentsContext)
}

func (s *PrimaryContext) ExplicitGenericInvocationSuffix() IExplicitGenericInvocationSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplicitGenericInvocationSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplicitGenericInvocationSuffixContext)
}

func (s *PrimaryContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterPrimary(s)
	}
}

func (s *PrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitPrimary(s)
	}
}

func (s *PrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) Primary() (localctx IPrimaryContext) {
	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, JavaParserRULE_primary)
	p.SetState(1521)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1503)
			p.Match(JavaParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1504)
			p.expression(0)
		}
		{
			p.SetState(1505)
			p.Match(JavaParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1507)
			p.Match(JavaParserTHIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1508)
			p.Match(JavaParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1509)
			p.Literal()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1510)
			p.Identifier()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1511)
			p.TypeTypeOrVoid()
		}
		{
			p.SetState(1512)
			p.Match(JavaParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1513)
			p.Match(JavaParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1515)
			p.NonWildcardTypeArguments()
		}
		p.SetState(1519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case JavaParserSUPER, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserIDENTIFIER:
			{
				p.SetState(1516)
				p.ExplicitGenericInvocationSuffix()
			}

		case JavaParserTHIS:
			{
				p.SetState(1517)
				p.Match(JavaParserTHIS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1518)
				p.Arguments()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchExpressionContext is an interface to support dynamic dispatch.
type ISwitchExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SWITCH() antlr.TerminalNode
	ParExpression() IParExpressionContext
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllSwitchLabeledRule() []ISwitchLabeledRuleContext
	SwitchLabeledRule(i int) ISwitchLabeledRuleContext

	// IsSwitchExpressionContext differentiates from other interfaces.
	IsSwitchExpressionContext()
}

type SwitchExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchExpressionContext() *SwitchExpressionContext {
	var p = new(SwitchExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_switchExpression
	return p
}

func InitEmptySwitchExpressionContext(p *SwitchExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_switchExpression
}

func (*SwitchExpressionContext) IsSwitchExpressionContext() {}

func NewSwitchExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchExpressionContext {
	var p = new(SwitchExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_switchExpression

	return p
}

func (s *SwitchExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchExpressionContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(JavaParserSWITCH, 0)
}

func (s *SwitchExpressionContext) ParExpression() IParExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParExpressionContext)
}

func (s *SwitchExpressionContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACE, 0)
}

func (s *SwitchExpressionContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACE, 0)
}

func (s *SwitchExpressionContext) AllSwitchLabeledRule() []ISwitchLabeledRuleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchLabeledRuleContext); ok {
			len++
		}
	}

	tst := make([]ISwitchLabeledRuleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchLabeledRuleContext); ok {
			tst[i] = t.(ISwitchLabeledRuleContext)
			i++
		}
	}

	return tst
}

func (s *SwitchExpressionContext) SwitchLabeledRule(i int) ISwitchLabeledRuleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchLabeledRuleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchLabeledRuleContext)
}

func (s *SwitchExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterSwitchExpression(s)
	}
}

func (s *SwitchExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitSwitchExpression(s)
	}
}

func (s *SwitchExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitSwitchExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) SwitchExpression() (localctx ISwitchExpressionContext) {
	localctx = NewSwitchExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, JavaParserRULE_switchExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1523)
		p.Match(JavaParserSWITCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1524)
		p.ParExpression()
	}
	{
		p.SetState(1525)
		p.Match(JavaParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCASE || _la == JavaParserDEFAULT {
		{
			p.SetState(1526)
			p.SwitchLabeledRule()
		}

		p.SetState(1531)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1532)
		p.Match(JavaParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchLabeledRuleContext is an interface to support dynamic dispatch.
type ISwitchLabeledRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	SwitchRuleOutcome() ISwitchRuleOutcomeContext
	ARROW() antlr.TerminalNode
	COLON() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	NULL_LITERAL() antlr.TerminalNode
	GuardedPattern() IGuardedPatternContext
	DEFAULT() antlr.TerminalNode

	// IsSwitchLabeledRuleContext differentiates from other interfaces.
	IsSwitchLabeledRuleContext()
}

type SwitchLabeledRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchLabeledRuleContext() *SwitchLabeledRuleContext {
	var p = new(SwitchLabeledRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_switchLabeledRule
	return p
}

func InitEmptySwitchLabeledRuleContext(p *SwitchLabeledRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_switchLabeledRule
}

func (*SwitchLabeledRuleContext) IsSwitchLabeledRuleContext() {}

func NewSwitchLabeledRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchLabeledRuleContext {
	var p = new(SwitchLabeledRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_switchLabeledRule

	return p
}

func (s *SwitchLabeledRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchLabeledRuleContext) CASE() antlr.TerminalNode {
	return s.GetToken(JavaParserCASE, 0)
}

func (s *SwitchLabeledRuleContext) SwitchRuleOutcome() ISwitchRuleOutcomeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchRuleOutcomeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchRuleOutcomeContext)
}

func (s *SwitchLabeledRuleContext) ARROW() antlr.TerminalNode {
	return s.GetToken(JavaParserARROW, 0)
}

func (s *SwitchLabeledRuleContext) COLON() antlr.TerminalNode {
	return s.GetToken(JavaParserCOLON, 0)
}

func (s *SwitchLabeledRuleContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *SwitchLabeledRuleContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(JavaParserNULL_LITERAL, 0)
}

func (s *SwitchLabeledRuleContext) GuardedPattern() IGuardedPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGuardedPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGuardedPatternContext)
}

func (s *SwitchLabeledRuleContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(JavaParserDEFAULT, 0)
}

func (s *SwitchLabeledRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchLabeledRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchLabeledRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterSwitchLabeledRule(s)
	}
}

func (s *SwitchLabeledRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitSwitchLabeledRule(s)
	}
}

func (s *SwitchLabeledRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitSwitchLabeledRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) SwitchLabeledRule() (localctx ISwitchLabeledRuleContext) {
	localctx = NewSwitchLabeledRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, JavaParserRULE_switchLabeledRule)
	var _la int

	p.SetState(1545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserCASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1534)
			p.Match(JavaParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1538)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1535)
				p.ExpressionList()
			}

		case 2:
			{
				p.SetState(1536)
				p.Match(JavaParserNULL_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(1537)
				p.guardedPattern(0)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(1540)
			_la = p.GetTokenStream().LA(1)

			if !(_la == JavaParserCOLON || _la == JavaParserARROW) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1541)
			p.SwitchRuleOutcome()
		}

	case JavaParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1542)
			p.Match(JavaParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1543)
			_la = p.GetTokenStream().LA(1)

			if !(_la == JavaParserCOLON || _la == JavaParserARROW) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1544)
			p.SwitchRuleOutcome()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGuardedPatternContext is an interface to support dynamic dispatch.
type IGuardedPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	GuardedPattern() IGuardedPatternContext
	RPAREN() antlr.TerminalNode
	TypeType() ITypeTypeContext
	Identifier() IIdentifierContext
	AllVariableModifier() []IVariableModifierContext
	VariableModifier(i int) IVariableModifierContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	AllAND() []antlr.TerminalNode
	AND(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsGuardedPatternContext differentiates from other interfaces.
	IsGuardedPatternContext()
}

type GuardedPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGuardedPatternContext() *GuardedPatternContext {
	var p = new(GuardedPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_guardedPattern
	return p
}

func InitEmptyGuardedPatternContext(p *GuardedPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_guardedPattern
}

func (*GuardedPatternContext) IsGuardedPatternContext() {}

func NewGuardedPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GuardedPatternContext {
	var p = new(GuardedPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_guardedPattern

	return p
}

func (s *GuardedPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *GuardedPatternContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *GuardedPatternContext) GuardedPattern() IGuardedPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGuardedPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGuardedPatternContext)
}

func (s *GuardedPatternContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *GuardedPatternContext) TypeType() ITypeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *GuardedPatternContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GuardedPatternContext) AllVariableModifier() []IVariableModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableModifierContext); ok {
			len++
		}
	}

	tst := make([]IVariableModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableModifierContext); ok {
			tst[i] = t.(IVariableModifierContext)
			i++
		}
	}

	return tst
}

func (s *GuardedPatternContext) VariableModifier(i int) IVariableModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *GuardedPatternContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *GuardedPatternContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *GuardedPatternContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(JavaParserAND)
}

func (s *GuardedPatternContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserAND, i)
}

func (s *GuardedPatternContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GuardedPatternContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GuardedPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GuardedPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GuardedPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterGuardedPattern(s)
	}
}

func (s *GuardedPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitGuardedPattern(s)
	}
}

func (s *GuardedPatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitGuardedPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) GuardedPattern() (localctx IGuardedPatternContext) {
	return p.guardedPattern(0)
}

func (p *JavaParser) guardedPattern(_p int) (localctx IGuardedPatternContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewGuardedPatternContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IGuardedPatternContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 214
	p.EnterRecursionRule(localctx, 214, JavaParserRULE_guardedPattern, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1573)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserLPAREN:
		{
			p.SetState(1548)
			p.Match(JavaParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1549)
			p.guardedPattern(0)
		}
		{
			p.SetState(1550)
			p.Match(JavaParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JavaParserBOOLEAN, JavaParserBYTE, JavaParserCHAR, JavaParserDOUBLE, JavaParserFINAL, JavaParserFLOAT, JavaParserINT, JavaParserLONG, JavaParserSHORT, JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserAT, JavaParserIDENTIFIER:
		p.SetState(1555)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1552)
					p.VariableModifier()
				}

			}
			p.SetState(1557)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(1558)
			p.TypeType()
		}
		p.SetState(1562)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 185, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1559)
					p.Annotation()
				}

			}
			p.SetState(1564)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 185, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(1565)
			p.Identifier()
		}
		p.SetState(1570)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1566)
					p.Match(JavaParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1567)
					p.expression(0)
				}

			}
			p.SetState(1572)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewGuardedPatternContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, JavaParserRULE_guardedPattern)
			p.SetState(1575)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(1576)
				p.Match(JavaParserAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1577)
				p.expression(0)
			}

		}
		p.SetState(1582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchRuleOutcomeContext is an interface to support dynamic dispatch.
type ISwitchRuleOutcomeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	AllBlockStatement() []IBlockStatementContext
	BlockStatement(i int) IBlockStatementContext

	// IsSwitchRuleOutcomeContext differentiates from other interfaces.
	IsSwitchRuleOutcomeContext()
}

type SwitchRuleOutcomeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchRuleOutcomeContext() *SwitchRuleOutcomeContext {
	var p = new(SwitchRuleOutcomeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_switchRuleOutcome
	return p
}

func InitEmptySwitchRuleOutcomeContext(p *SwitchRuleOutcomeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_switchRuleOutcome
}

func (*SwitchRuleOutcomeContext) IsSwitchRuleOutcomeContext() {}

func NewSwitchRuleOutcomeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchRuleOutcomeContext {
	var p = new(SwitchRuleOutcomeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_switchRuleOutcome

	return p
}

func (s *SwitchRuleOutcomeContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchRuleOutcomeContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SwitchRuleOutcomeContext) AllBlockStatement() []IBlockStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockStatementContext); ok {
			len++
		}
	}

	tst := make([]IBlockStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockStatementContext); ok {
			tst[i] = t.(IBlockStatementContext)
			i++
		}
	}

	return tst
}

func (s *SwitchRuleOutcomeContext) BlockStatement(i int) IBlockStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *SwitchRuleOutcomeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchRuleOutcomeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchRuleOutcomeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterSwitchRuleOutcome(s)
	}
}

func (s *SwitchRuleOutcomeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitSwitchRuleOutcome(s)
	}
}

func (s *SwitchRuleOutcomeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitSwitchRuleOutcome(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) SwitchRuleOutcome() (localctx ISwitchRuleOutcomeContext) {
	localctx = NewSwitchRuleOutcomeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, JavaParserRULE_switchRuleOutcome)
	var _la int

	p.SetState(1590)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 190, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1583)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1587)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-334254282492513) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-8935141145188974593) != 0) {
			{
				p.SetState(1584)
				p.BlockStatement()
			}

			p.SetState(1589)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassTypeContext is an interface to support dynamic dispatch.
type IClassTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ClassOrInterfaceType() IClassOrInterfaceTypeContext
	DOT() antlr.TerminalNode
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	TypeArguments() ITypeArgumentsContext

	// IsClassTypeContext differentiates from other interfaces.
	IsClassTypeContext()
}

type ClassTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTypeContext() *ClassTypeContext {
	var p = new(ClassTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_classType
	return p
}

func InitEmptyClassTypeContext(p *ClassTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_classType
}

func (*ClassTypeContext) IsClassTypeContext() {}

func NewClassTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTypeContext {
	var p = new(ClassTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_classType

	return p
}

func (s *ClassTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassTypeContext) ClassOrInterfaceType() IClassOrInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeContext)
}

func (s *ClassTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(JavaParserDOT, 0)
}

func (s *ClassTypeContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ClassTypeContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ClassTypeContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ClassTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterClassType(s)
	}
}

func (s *ClassTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitClassType(s)
	}
}

func (s *ClassTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitClassType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ClassType() (localctx IClassTypeContext) {
	localctx = NewClassTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, JavaParserRULE_classType)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1595)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1592)
			p.ClassOrInterfaceType()
		}
		{
			p.SetState(1593)
			p.Match(JavaParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1600)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 192, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1597)
				p.Annotation()
			}

		}
		p.SetState(1602)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 192, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1603)
		p.Identifier()
	}
	p.SetState(1605)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserLT {
		{
			p.SetState(1604)
			p.TypeArguments()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreatorContext is an interface to support dynamic dispatch.
type ICreatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreatedName() ICreatedNameContext
	ClassCreatorRest() IClassCreatorRestContext
	NonWildcardTypeArguments() INonWildcardTypeArgumentsContext
	ArrayCreatorRest() IArrayCreatorRestContext

	// IsCreatorContext differentiates from other interfaces.
	IsCreatorContext()
}

type CreatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreatorContext() *CreatorContext {
	var p = new(CreatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_creator
	return p
}

func InitEmptyCreatorContext(p *CreatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_creator
}

func (*CreatorContext) IsCreatorContext() {}

func NewCreatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreatorContext {
	var p = new(CreatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_creator

	return p
}

func (s *CreatorContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatorContext) CreatedName() ICreatedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatedNameContext)
}

func (s *CreatorContext) ClassCreatorRest() IClassCreatorRestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassCreatorRestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassCreatorRestContext)
}

func (s *CreatorContext) NonWildcardTypeArguments() INonWildcardTypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonWildcardTypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonWildcardTypeArgumentsContext)
}

func (s *CreatorContext) ArrayCreatorRest() IArrayCreatorRestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayCreatorRestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayCreatorRestContext)
}

func (s *CreatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterCreator(s)
	}
}

func (s *CreatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitCreator(s)
	}
}

func (s *CreatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitCreator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) Creator() (localctx ICreatorContext) {
	localctx = NewCreatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, JavaParserRULE_creator)
	var _la int

	p.SetState(1616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 195, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1608)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserLT {
			{
				p.SetState(1607)
				p.NonWildcardTypeArguments()
			}

		}
		{
			p.SetState(1610)
			p.CreatedName()
		}
		{
			p.SetState(1611)
			p.ClassCreatorRest()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1613)
			p.CreatedName()
		}
		{
			p.SetState(1614)
			p.ArrayCreatorRest()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreatedNameContext is an interface to support dynamic dispatch.
type ICreatedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllTypeArgumentsOrDiamond() []ITypeArgumentsOrDiamondContext
	TypeArgumentsOrDiamond(i int) ITypeArgumentsOrDiamondContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	PrimitiveType() IPrimitiveTypeContext

	// IsCreatedNameContext differentiates from other interfaces.
	IsCreatedNameContext()
}

type CreatedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreatedNameContext() *CreatedNameContext {
	var p = new(CreatedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_createdName
	return p
}

func InitEmptyCreatedNameContext(p *CreatedNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_createdName
}

func (*CreatedNameContext) IsCreatedNameContext() {}

func NewCreatedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreatedNameContext {
	var p = new(CreatedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_createdName

	return p
}

func (s *CreatedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatedNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreatedNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreatedNameContext) AllTypeArgumentsOrDiamond() []ITypeArgumentsOrDiamondContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeArgumentsOrDiamondContext); ok {
			len++
		}
	}

	tst := make([]ITypeArgumentsOrDiamondContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeArgumentsOrDiamondContext); ok {
			tst[i] = t.(ITypeArgumentsOrDiamondContext)
			i++
		}
	}

	return tst
}

func (s *CreatedNameContext) TypeArgumentsOrDiamond(i int) ITypeArgumentsOrDiamondContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsOrDiamondContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsOrDiamondContext)
}

func (s *CreatedNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(JavaParserDOT)
}

func (s *CreatedNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserDOT, i)
}

func (s *CreatedNameContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *CreatedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreatedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterCreatedName(s)
	}
}

func (s *CreatedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitCreatedName(s)
	}
}

func (s *CreatedNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitCreatedName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) CreatedName() (localctx ICreatedNameContext) {
	localctx = NewCreatedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, JavaParserRULE_createdName)
	var _la int

	p.SetState(1633)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1618)
			p.Identifier()
		}
		p.SetState(1620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserLT {
			{
				p.SetState(1619)
				p.TypeArgumentsOrDiamond()
			}

		}
		p.SetState(1629)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JavaParserDOT {
			{
				p.SetState(1622)
				p.Match(JavaParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1623)
				p.Identifier()
			}
			p.SetState(1625)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == JavaParserLT {
				{
					p.SetState(1624)
					p.TypeArgumentsOrDiamond()
				}

			}

			p.SetState(1631)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case JavaParserBOOLEAN, JavaParserBYTE, JavaParserCHAR, JavaParserDOUBLE, JavaParserFLOAT, JavaParserINT, JavaParserLONG, JavaParserSHORT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1632)
			p.PrimitiveType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInnerCreatorContext is an interface to support dynamic dispatch.
type IInnerCreatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ClassCreatorRest() IClassCreatorRestContext
	NonWildcardTypeArgumentsOrDiamond() INonWildcardTypeArgumentsOrDiamondContext

	// IsInnerCreatorContext differentiates from other interfaces.
	IsInnerCreatorContext()
}

type InnerCreatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInnerCreatorContext() *InnerCreatorContext {
	var p = new(InnerCreatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_innerCreator
	return p
}

func InitEmptyInnerCreatorContext(p *InnerCreatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_innerCreator
}

func (*InnerCreatorContext) IsInnerCreatorContext() {}

func NewInnerCreatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InnerCreatorContext {
	var p = new(InnerCreatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_innerCreator

	return p
}

func (s *InnerCreatorContext) GetParser() antlr.Parser { return s.parser }

func (s *InnerCreatorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InnerCreatorContext) ClassCreatorRest() IClassCreatorRestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassCreatorRestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassCreatorRestContext)
}

func (s *InnerCreatorContext) NonWildcardTypeArgumentsOrDiamond() INonWildcardTypeArgumentsOrDiamondContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonWildcardTypeArgumentsOrDiamondContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonWildcardTypeArgumentsOrDiamondContext)
}

func (s *InnerCreatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerCreatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InnerCreatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterInnerCreator(s)
	}
}

func (s *InnerCreatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitInnerCreator(s)
	}
}

func (s *InnerCreatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitInnerCreator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) InnerCreator() (localctx IInnerCreatorContext) {
	localctx = NewInnerCreatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, JavaParserRULE_innerCreator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1635)
		p.Identifier()
	}
	p.SetState(1637)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JavaParserLT {
		{
			p.SetState(1636)
			p.NonWildcardTypeArgumentsOrDiamond()
		}

	}
	{
		p.SetState(1639)
		p.ClassCreatorRest()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayCreatorRestContext is an interface to support dynamic dispatch.
type IArrayCreatorRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ArrayInitializer() IArrayInitializerContext
	AllLBRACK() []antlr.TerminalNode
	LBRACK(i int) antlr.TerminalNode
	AllRBRACK() []antlr.TerminalNode
	RBRACK(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsArrayCreatorRestContext differentiates from other interfaces.
	IsArrayCreatorRestContext()
}

type ArrayCreatorRestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayCreatorRestContext() *ArrayCreatorRestContext {
	var p = new(ArrayCreatorRestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_arrayCreatorRest
	return p
}

func InitEmptyArrayCreatorRestContext(p *ArrayCreatorRestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_arrayCreatorRest
}

func (*ArrayCreatorRestContext) IsArrayCreatorRestContext() {}

func NewArrayCreatorRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayCreatorRestContext {
	var p = new(ArrayCreatorRestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_arrayCreatorRest

	return p
}

func (s *ArrayCreatorRestContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayCreatorRestContext) ArrayInitializer() IArrayInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayInitializerContext)
}

func (s *ArrayCreatorRestContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserLBRACK)
}

func (s *ArrayCreatorRestContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACK, i)
}

func (s *ArrayCreatorRestContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserRBRACK)
}

func (s *ArrayCreatorRestContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACK, i)
}

func (s *ArrayCreatorRestContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArrayCreatorRestContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayCreatorRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayCreatorRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayCreatorRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterArrayCreatorRest(s)
	}
}

func (s *ArrayCreatorRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitArrayCreatorRest(s)
	}
}

func (s *ArrayCreatorRestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitArrayCreatorRest(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ArrayCreatorRest() (localctx IArrayCreatorRestContext) {
	localctx = NewArrayCreatorRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, JavaParserRULE_arrayCreatorRest)
	var _la int

	var _alt int

	p.SetState(1663)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 204, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1643)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == JavaParserLBRACK {
			{
				p.SetState(1641)
				p.Match(JavaParserLBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1642)
				p.Match(JavaParserRBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1645)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1647)
			p.ArrayInitializer()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1652)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1648)
					p.Match(JavaParserLBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1649)
					p.expression(0)
				}
				{
					p.SetState(1650)
					p.Match(JavaParserRBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(1654)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 202, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1660)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1656)
					p.Match(JavaParserLBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1657)
					p.Match(JavaParserRBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1662)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassCreatorRestContext is an interface to support dynamic dispatch.
type IClassCreatorRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Arguments() IArgumentsContext
	ClassBody() IClassBodyContext

	// IsClassCreatorRestContext differentiates from other interfaces.
	IsClassCreatorRestContext()
}

type ClassCreatorRestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassCreatorRestContext() *ClassCreatorRestContext {
	var p = new(ClassCreatorRestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_classCreatorRest
	return p
}

func InitEmptyClassCreatorRestContext(p *ClassCreatorRestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_classCreatorRest
}

func (*ClassCreatorRestContext) IsClassCreatorRestContext() {}

func NewClassCreatorRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassCreatorRestContext {
	var p = new(ClassCreatorRestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_classCreatorRest

	return p
}

func (s *ClassCreatorRestContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassCreatorRestContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ClassCreatorRestContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ClassCreatorRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassCreatorRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassCreatorRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterClassCreatorRest(s)
	}
}

func (s *ClassCreatorRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitClassCreatorRest(s)
	}
}

func (s *ClassCreatorRestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitClassCreatorRest(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ClassCreatorRest() (localctx IClassCreatorRestContext) {
	localctx = NewClassCreatorRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, JavaParserRULE_classCreatorRest)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1665)
		p.Arguments()
	}
	p.SetState(1667)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1666)
			p.ClassBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplicitGenericInvocationContext is an interface to support dynamic dispatch.
type IExplicitGenericInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NonWildcardTypeArguments() INonWildcardTypeArgumentsContext
	ExplicitGenericInvocationSuffix() IExplicitGenericInvocationSuffixContext

	// IsExplicitGenericInvocationContext differentiates from other interfaces.
	IsExplicitGenericInvocationContext()
}

type ExplicitGenericInvocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitGenericInvocationContext() *ExplicitGenericInvocationContext {
	var p = new(ExplicitGenericInvocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_explicitGenericInvocation
	return p
}

func InitEmptyExplicitGenericInvocationContext(p *ExplicitGenericInvocationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_explicitGenericInvocation
}

func (*ExplicitGenericInvocationContext) IsExplicitGenericInvocationContext() {}

func NewExplicitGenericInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitGenericInvocationContext {
	var p = new(ExplicitGenericInvocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_explicitGenericInvocation

	return p
}

func (s *ExplicitGenericInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitGenericInvocationContext) NonWildcardTypeArguments() INonWildcardTypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonWildcardTypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonWildcardTypeArgumentsContext)
}

func (s *ExplicitGenericInvocationContext) ExplicitGenericInvocationSuffix() IExplicitGenericInvocationSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplicitGenericInvocationSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplicitGenericInvocationSuffixContext)
}

func (s *ExplicitGenericInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitGenericInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplicitGenericInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterExplicitGenericInvocation(s)
	}
}

func (s *ExplicitGenericInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitExplicitGenericInvocation(s)
	}
}

func (s *ExplicitGenericInvocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitExplicitGenericInvocation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ExplicitGenericInvocation() (localctx IExplicitGenericInvocationContext) {
	localctx = NewExplicitGenericInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, JavaParserRULE_explicitGenericInvocation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1669)
		p.NonWildcardTypeArguments()
	}
	{
		p.SetState(1670)
		p.ExplicitGenericInvocationSuffix()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeArgumentsOrDiamondContext is an interface to support dynamic dispatch.
type ITypeArgumentsOrDiamondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	TypeArguments() ITypeArgumentsContext

	// IsTypeArgumentsOrDiamondContext differentiates from other interfaces.
	IsTypeArgumentsOrDiamondContext()
}

type TypeArgumentsOrDiamondContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsOrDiamondContext() *TypeArgumentsOrDiamondContext {
	var p = new(TypeArgumentsOrDiamondContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeArgumentsOrDiamond
	return p
}

func InitEmptyTypeArgumentsOrDiamondContext(p *TypeArgumentsOrDiamondContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeArgumentsOrDiamond
}

func (*TypeArgumentsOrDiamondContext) IsTypeArgumentsOrDiamondContext() {}

func NewTypeArgumentsOrDiamondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsOrDiamondContext {
	var p = new(TypeArgumentsOrDiamondContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeArgumentsOrDiamond

	return p
}

func (s *TypeArgumentsOrDiamondContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsOrDiamondContext) LT() antlr.TerminalNode {
	return s.GetToken(JavaParserLT, 0)
}

func (s *TypeArgumentsOrDiamondContext) GT() antlr.TerminalNode {
	return s.GetToken(JavaParserGT, 0)
}

func (s *TypeArgumentsOrDiamondContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *TypeArgumentsOrDiamondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsOrDiamondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsOrDiamondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeArgumentsOrDiamond(s)
	}
}

func (s *TypeArgumentsOrDiamondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeArgumentsOrDiamond(s)
	}
}

func (s *TypeArgumentsOrDiamondContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitTypeArgumentsOrDiamond(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) TypeArgumentsOrDiamond() (localctx ITypeArgumentsOrDiamondContext) {
	localctx = NewTypeArgumentsOrDiamondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, JavaParserRULE_typeArgumentsOrDiamond)
	p.SetState(1675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1672)
			p.Match(JavaParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1673)
			p.Match(JavaParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1674)
			p.TypeArguments()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonWildcardTypeArgumentsOrDiamondContext is an interface to support dynamic dispatch.
type INonWildcardTypeArgumentsOrDiamondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	NonWildcardTypeArguments() INonWildcardTypeArgumentsContext

	// IsNonWildcardTypeArgumentsOrDiamondContext differentiates from other interfaces.
	IsNonWildcardTypeArgumentsOrDiamondContext()
}

type NonWildcardTypeArgumentsOrDiamondContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonWildcardTypeArgumentsOrDiamondContext() *NonWildcardTypeArgumentsOrDiamondContext {
	var p = new(NonWildcardTypeArgumentsOrDiamondContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_nonWildcardTypeArgumentsOrDiamond
	return p
}

func InitEmptyNonWildcardTypeArgumentsOrDiamondContext(p *NonWildcardTypeArgumentsOrDiamondContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_nonWildcardTypeArgumentsOrDiamond
}

func (*NonWildcardTypeArgumentsOrDiamondContext) IsNonWildcardTypeArgumentsOrDiamondContext() {}

func NewNonWildcardTypeArgumentsOrDiamondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonWildcardTypeArgumentsOrDiamondContext {
	var p = new(NonWildcardTypeArgumentsOrDiamondContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_nonWildcardTypeArgumentsOrDiamond

	return p
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) GetParser() antlr.Parser { return s.parser }

func (s *NonWildcardTypeArgumentsOrDiamondContext) LT() antlr.TerminalNode {
	return s.GetToken(JavaParserLT, 0)
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) GT() antlr.TerminalNode {
	return s.GetToken(JavaParserGT, 0)
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) NonWildcardTypeArguments() INonWildcardTypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonWildcardTypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonWildcardTypeArgumentsContext)
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterNonWildcardTypeArgumentsOrDiamond(s)
	}
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitNonWildcardTypeArgumentsOrDiamond(s)
	}
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitNonWildcardTypeArgumentsOrDiamond(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) NonWildcardTypeArgumentsOrDiamond() (localctx INonWildcardTypeArgumentsOrDiamondContext) {
	localctx = NewNonWildcardTypeArgumentsOrDiamondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, JavaParserRULE_nonWildcardTypeArgumentsOrDiamond)
	p.SetState(1680)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1677)
			p.Match(JavaParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1678)
			p.Match(JavaParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1679)
			p.NonWildcardTypeArguments()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonWildcardTypeArgumentsContext is an interface to support dynamic dispatch.
type INonWildcardTypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	TypeList() ITypeListContext
	GT() antlr.TerminalNode

	// IsNonWildcardTypeArgumentsContext differentiates from other interfaces.
	IsNonWildcardTypeArgumentsContext()
}

type NonWildcardTypeArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonWildcardTypeArgumentsContext() *NonWildcardTypeArgumentsContext {
	var p = new(NonWildcardTypeArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_nonWildcardTypeArguments
	return p
}

func InitEmptyNonWildcardTypeArgumentsContext(p *NonWildcardTypeArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_nonWildcardTypeArguments
}

func (*NonWildcardTypeArgumentsContext) IsNonWildcardTypeArgumentsContext() {}

func NewNonWildcardTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonWildcardTypeArgumentsContext {
	var p = new(NonWildcardTypeArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_nonWildcardTypeArguments

	return p
}

func (s *NonWildcardTypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *NonWildcardTypeArgumentsContext) LT() antlr.TerminalNode {
	return s.GetToken(JavaParserLT, 0)
}

func (s *NonWildcardTypeArgumentsContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *NonWildcardTypeArgumentsContext) GT() antlr.TerminalNode {
	return s.GetToken(JavaParserGT, 0)
}

func (s *NonWildcardTypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonWildcardTypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonWildcardTypeArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterNonWildcardTypeArguments(s)
	}
}

func (s *NonWildcardTypeArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitNonWildcardTypeArguments(s)
	}
}

func (s *NonWildcardTypeArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitNonWildcardTypeArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) NonWildcardTypeArguments() (localctx INonWildcardTypeArgumentsContext) {
	localctx = NewNonWildcardTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, JavaParserRULE_nonWildcardTypeArguments)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1682)
		p.Match(JavaParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1683)
		p.TypeList()
	}
	{
		p.SetState(1684)
		p.Match(JavaParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeType() []ITypeTypeContext
	TypeType(i int) ITypeTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllTypeType() []ITypeTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeTypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeTypeContext); ok {
			tst[i] = t.(ITypeTypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) TypeType(i int) ITypeTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *TypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, JavaParserRULE_typeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1686)
		p.TypeType()
	}
	p.SetState(1691)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCOMMA {
		{
			p.SetState(1687)
			p.Match(JavaParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1688)
			p.TypeType()
		}

		p.SetState(1693)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeTypeContext is an interface to support dynamic dispatch.
type ITypeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassOrInterfaceType() IClassOrInterfaceTypeContext
	PrimitiveType() IPrimitiveTypeContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	AllLBRACK() []antlr.TerminalNode
	LBRACK(i int) antlr.TerminalNode
	AllRBRACK() []antlr.TerminalNode
	RBRACK(i int) antlr.TerminalNode

	// IsTypeTypeContext differentiates from other interfaces.
	IsTypeTypeContext()
}

type TypeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeTypeContext() *TypeTypeContext {
	var p = new(TypeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeType
	return p
}

func InitEmptyTypeTypeContext(p *TypeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeType
}

func (*TypeTypeContext) IsTypeTypeContext() {}

func NewTypeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeTypeContext {
	var p = new(TypeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeType

	return p
}

func (s *TypeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeTypeContext) ClassOrInterfaceType() IClassOrInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeContext)
}

func (s *TypeTypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *TypeTypeContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *TypeTypeContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeTypeContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserLBRACK)
}

func (s *TypeTypeContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserLBRACK, i)
}

func (s *TypeTypeContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(JavaParserRBRACK)
}

func (s *TypeTypeContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserRBRACK, i)
}

func (s *TypeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeType(s)
	}
}

func (s *TypeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeType(s)
	}
}

func (s *TypeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitTypeType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) TypeType() (localctx ITypeTypeContext) {
	localctx = NewTypeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, JavaParserRULE_typeType)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1697)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 209, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1694)
				p.Annotation()
			}

		}
		p.SetState(1699)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 209, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1702)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserIDENTIFIER:
		{
			p.SetState(1700)
			p.ClassOrInterfaceType()
		}

	case JavaParserBOOLEAN, JavaParserBYTE, JavaParserCHAR, JavaParserDOUBLE, JavaParserFLOAT, JavaParserINT, JavaParserLONG, JavaParserSHORT:
		{
			p.SetState(1701)
			p.PrimitiveType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1714)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1707)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ((int64((_la-51)) & ^0x3f) == 0 && ((int64(1)<<(_la-51))&32767) != 0) || _la == JavaParserAT || _la == JavaParserIDENTIFIER {
				{
					p.SetState(1704)
					p.Annotation()
				}

				p.SetState(1709)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1710)
				p.Match(JavaParserLBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1711)
				p.Match(JavaParserRBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1716)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimitiveTypeContext is an interface to support dynamic dispatch.
type IPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BOOLEAN() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	BYTE() antlr.TerminalNode
	SHORT() antlr.TerminalNode
	INT() antlr.TerminalNode
	LONG() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode

	// IsPrimitiveTypeContext differentiates from other interfaces.
	IsPrimitiveTypeContext()
}

type PrimitiveTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveTypeContext() *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_primitiveType
	return p
}

func InitEmptyPrimitiveTypeContext(p *PrimitiveTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_primitiveType
}

func (*PrimitiveTypeContext) IsPrimitiveTypeContext() {}

func NewPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_primitiveType

	return p
}

func (s *PrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(JavaParserBOOLEAN, 0)
}

func (s *PrimitiveTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(JavaParserCHAR, 0)
}

func (s *PrimitiveTypeContext) BYTE() antlr.TerminalNode {
	return s.GetToken(JavaParserBYTE, 0)
}

func (s *PrimitiveTypeContext) SHORT() antlr.TerminalNode {
	return s.GetToken(JavaParserSHORT, 0)
}

func (s *PrimitiveTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(JavaParserINT, 0)
}

func (s *PrimitiveTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(JavaParserLONG, 0)
}

func (s *PrimitiveTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(JavaParserFLOAT, 0)
}

func (s *PrimitiveTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(JavaParserDOUBLE, 0)
}

func (s *PrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitPrimitiveType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) PrimitiveType() (localctx IPrimitiveTypeContext) {
	localctx = NewPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, JavaParserRULE_primitiveType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1717)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&138111107368) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeArgumentsContext is an interface to support dynamic dispatch.
type ITypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	AllTypeArgument() []ITypeArgumentContext
	TypeArgument(i int) ITypeArgumentContext
	GT() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeArgumentsContext differentiates from other interfaces.
	IsTypeArgumentsContext()
}

type TypeArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsContext() *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeArguments
	return p
}

func InitEmptyTypeArgumentsContext(p *TypeArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_typeArguments
}

func (*TypeArgumentsContext) IsTypeArgumentsContext() {}

func NewTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_typeArguments

	return p
}

func (s *TypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsContext) LT() antlr.TerminalNode {
	return s.GetToken(JavaParserLT, 0)
}

func (s *TypeArgumentsContext) AllTypeArgument() []ITypeArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeArgumentContext); ok {
			len++
		}
	}

	tst := make([]ITypeArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeArgumentContext); ok {
			tst[i] = t.(ITypeArgumentContext)
			i++
		}
	}

	return tst
}

func (s *TypeArgumentsContext) TypeArgument(i int) ITypeArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentContext)
}

func (s *TypeArgumentsContext) GT() antlr.TerminalNode {
	return s.GetToken(JavaParserGT, 0)
}

func (s *TypeArgumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(JavaParserCOMMA)
}

func (s *TypeArgumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(JavaParserCOMMA, i)
}

func (s *TypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterTypeArguments(s)
	}
}

func (s *TypeArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitTypeArguments(s)
	}
}

func (s *TypeArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitTypeArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) TypeArguments() (localctx ITypeArgumentsContext) {
	localctx = NewTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, JavaParserRULE_typeArguments)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1719)
		p.Match(JavaParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1720)
		p.TypeArgument()
	}
	p.SetState(1725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JavaParserCOMMA {
		{
			p.SetState(1721)
			p.Match(JavaParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1722)
			p.TypeArgument()
		}

		p.SetState(1727)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1728)
		p.Match(JavaParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISuperSuffixContext is an interface to support dynamic dispatch.
type ISuperSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Arguments() IArgumentsContext
	DOT() antlr.TerminalNode
	Identifier() IIdentifierContext
	TypeArguments() ITypeArgumentsContext

	// IsSuperSuffixContext differentiates from other interfaces.
	IsSuperSuffixContext()
}

type SuperSuffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuperSuffixContext() *SuperSuffixContext {
	var p = new(SuperSuffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_superSuffix
	return p
}

func InitEmptySuperSuffixContext(p *SuperSuffixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_superSuffix
}

func (*SuperSuffixContext) IsSuperSuffixContext() {}

func NewSuperSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuperSuffixContext {
	var p = new(SuperSuffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_superSuffix

	return p
}

func (s *SuperSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *SuperSuffixContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *SuperSuffixContext) DOT() antlr.TerminalNode {
	return s.GetToken(JavaParserDOT, 0)
}

func (s *SuperSuffixContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SuperSuffixContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *SuperSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuperSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterSuperSuffix(s)
	}
}

func (s *SuperSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitSuperSuffix(s)
	}
}

func (s *SuperSuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitSuperSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) SuperSuffix() (localctx ISuperSuffixContext) {
	localctx = NewSuperSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, JavaParserRULE_superSuffix)
	var _la int

	p.SetState(1739)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1730)
			p.Arguments()
		}

	case JavaParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1731)
			p.Match(JavaParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1733)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JavaParserLT {
			{
				p.SetState(1732)
				p.TypeArguments()
			}

		}
		{
			p.SetState(1735)
			p.Identifier()
		}
		p.SetState(1737)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 215, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1736)
				p.Arguments()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplicitGenericInvocationSuffixContext is an interface to support dynamic dispatch.
type IExplicitGenericInvocationSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUPER() antlr.TerminalNode
	SuperSuffix() ISuperSuffixContext
	Identifier() IIdentifierContext
	Arguments() IArgumentsContext

	// IsExplicitGenericInvocationSuffixContext differentiates from other interfaces.
	IsExplicitGenericInvocationSuffixContext()
}

type ExplicitGenericInvocationSuffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitGenericInvocationSuffixContext() *ExplicitGenericInvocationSuffixContext {
	var p = new(ExplicitGenericInvocationSuffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_explicitGenericInvocationSuffix
	return p
}

func InitEmptyExplicitGenericInvocationSuffixContext(p *ExplicitGenericInvocationSuffixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_explicitGenericInvocationSuffix
}

func (*ExplicitGenericInvocationSuffixContext) IsExplicitGenericInvocationSuffixContext() {}

func NewExplicitGenericInvocationSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitGenericInvocationSuffixContext {
	var p = new(ExplicitGenericInvocationSuffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_explicitGenericInvocationSuffix

	return p
}

func (s *ExplicitGenericInvocationSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitGenericInvocationSuffixContext) SUPER() antlr.TerminalNode {
	return s.GetToken(JavaParserSUPER, 0)
}

func (s *ExplicitGenericInvocationSuffixContext) SuperSuffix() ISuperSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuperSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuperSuffixContext)
}

func (s *ExplicitGenericInvocationSuffixContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExplicitGenericInvocationSuffixContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ExplicitGenericInvocationSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitGenericInvocationSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplicitGenericInvocationSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterExplicitGenericInvocationSuffix(s)
	}
}

func (s *ExplicitGenericInvocationSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitExplicitGenericInvocationSuffix(s)
	}
}

func (s *ExplicitGenericInvocationSuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitExplicitGenericInvocationSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) ExplicitGenericInvocationSuffix() (localctx IExplicitGenericInvocationSuffixContext) {
	localctx = NewExplicitGenericInvocationSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, JavaParserRULE_explicitGenericInvocationSuffix)
	p.SetState(1746)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JavaParserSUPER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1741)
			p.Match(JavaParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1742)
			p.SuperSuffix()
		}

	case JavaParserMODULE, JavaParserOPEN, JavaParserREQUIRES, JavaParserEXPORTS, JavaParserOPENS, JavaParserTO, JavaParserUSES, JavaParserPROVIDES, JavaParserWITH, JavaParserTRANSITIVE, JavaParserVAR, JavaParserYIELD, JavaParserRECORD, JavaParserSEALED, JavaParserPERMITS, JavaParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1743)
			p.Identifier()
		}
		{
			p.SetState(1744)
			p.Arguments()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_arguments
	return p
}

func InitEmptyArgumentsContext(p *ArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JavaParserRULE_arguments
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserLPAREN, 0)
}

func (s *ArgumentsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(JavaParserRPAREN, 0)
}

func (s *ArgumentsContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaParserListener); ok {
		listenerT.ExitArguments(s)
	}
}

func (s *ArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaParserVisitor:
		return t.VisitArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaParser) Arguments() (localctx IArgumentsContext) {
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, JavaParserRULE_arguments)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1748)
		p.Match(JavaParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1750)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-3)) & ^0x3f) == 0 && ((int64(1)<<(_la-3))&9223127275610966053) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&2377900732130004991) != 0) {
		{
			p.SetState(1749)
			p.ExpressionList()
		}

	}
	{
		p.SetState(1752)
		p.Match(JavaParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *JavaParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 99:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 107:
		var t *GuardedPatternContext = nil
		if localctx != nil {
			t = localctx.(*GuardedPatternContext)
		}
		return p.GuardedPattern_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *JavaParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 25)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 24)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 22)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 10)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaParser) GuardedPattern_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 17:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
