AdvisorIndexTypeComposite = "Composite"
AdvisorIndexTypeSingle = "Single column"
AllCheckPrepareStatementPlaceholdersAnnotation = "Overusing bind variables can increase query complexity, which can reduce query performance. Overusing bind variables can also increase maintenance costs. Default threshold: 100"
AllCheckPrepareStatementPlaceholdersDesc = "The number of bound variables should not exceed the threshold"
AllCheckPrepareStatementPlaceholdersMessage = "The number of bound variables is %v, which should not exceed the set threshold %v"
AllCheckPrepareStatementPlaceholdersParams1 = "Maximum number of bind variables"
AnalysisDescCardinality = "Cardinality"
AnalysisDescCharacterSetName = "Character set"
AnalysisDescColumnComment = "Column comment"
AnalysisDescColumnDefault = "Default value"
AnalysisDescColumnKey = "Column index"
AnalysisDescColumnName = "Column name"
AnalysisDescColumnType = "Column type"
AnalysisDescComment = "Comment"
AnalysisDescExtra = "Extra information"
AnalysisDescIndexType = "Index type"
AnalysisDescIsNullable = "Nullable"
AnalysisDescKeyName = "Index name"
AnalysisDescSeqInIndex = "Column sequence"
AnalysisDescUnique = "Unique"
AnonymousMark = "(Anonymous)"
AuditResultMsgExcludedSQL = "Audit SQL exceptions"
AuditResultMsgWhiteList = "Whitelist"
CheckInvalidError = "Pre-check failed"
CheckInvalidErrorFormat = "Pre-check failed: %v"
ColumnExistMessage = "Column %s already exists"
ColumnIsAmbiguousMessage = "Column %s is ambiguous"
ColumnNotExistMessage = "Column %s does not exist"
ColumnsValuesNotMatchMessage = "The number of specified values does not match the number of columns"
ConfigDDLGhostMinSizeAnnotation = "Enabling this rule will automatically use the gh-ost tool to perform online table modification for large tables; Directly performing DDL changes on large tables may lead to long table locks, affecting business sustainability. The specific threshold for defining large tables can be adjusted according to business needs, default value: 1024"
ConfigDDLGhostMinSizeDesc = "Use gh-ost to execute SQL when table size (MB) exceeds the specified size"
ConfigDDLGhostMinSizeParams1 = "Table space size (MB)"
ConfigDDLOSCMinSizeAnnotation = "Enabling this rule will provide rewrite suggestions for large table DDL statements using the pt-osc tool 【Need to manually execute the command according to the suggestions, and automatic execution will be supported in the future】; Directly performing DDL changes on large tables may lead to long table locks, affecting business sustainability. The specific threshold for defining large tables can be adjusted according to business needs, default value: 1024"
ConfigDDLOSCMinSizeDesc = "Output osc rewrite suggestions during audit when table space (MB) exceeds the specified size"
ConfigDDLOSCMinSizeParams1 = "Table space size (MB)"
ConfigDMLExplainPreCheckEnableAnnotation = "Check if the DML to be executed is correct using EXPLAIN, and detect statement errors in advance to improve the success rate of execution"
ConfigDMLExplainPreCheckEnableDesc = "Use EXPLAIN to strengthen pre-check capabilities"
ConfigDMLRollbackMaxRowsAnnotation = "Large transaction rollback can easily affect database performance and cause business fluctuations; The specific rule threshold can be adjusted according to business needs, default value: 1000"
ConfigDMLRollbackMaxRowsDesc = "Do not rollback in DML statements if the estimated number of affected rows exceeds the specified value"
ConfigDMLRollbackMaxRowsParams1 = "Maximum number of affected rows"
ConfigOptimizeIndexEnabledAnnotation = "Enable index optimization suggestions through this rule, providing two configuration parameters to define the behavior of index optimization suggestions. 1. Minimum column distinctiveness threshold (percentage): Configure the minimum column distinctiveness in the current table below which the column will not be used as an index; 2. Maximum number of columns for combined index: Limit the maximum number of columns for combined index suggestions to prevent suggested combined indexes from violating other SQL standards"
ConfigOptimizeIndexEnabledDesc = "Index creation suggestions"
ConfigOptimizeIndexEnabledParams1 = "Minimum column distinctiveness threshold (percentage)"
ConfigOptimizeIndexEnabledParams2 = "Maximum number of columns for combined index"
ConfigSQLIsExecutedAnnotation = "Enable this rule to support the scenario of post-audit, and the DDL and DML statements collected afterwards will no longer be checked for execution. For example, the library table metadata scanning task can enable this rule"
ConfigSQLIsExecutedDesc = "Disable online audit mode"
DDLAvoidEventAnnotation = "Using events will increase database maintenance difficulty and dependence, and also cause security problems."
DDLAvoidEventDesc = "Do not use events"
DDLAvoidEventMessage = "Do not use events"
DDLAvoidFullTextAnnotation = "Using fulltext indexes will increase storage overhead and have a certain impact on write operation performance."
DDLAvoidFullTextDesc = "Do not use fulltext indexes"
DDLAvoidFullTextMessage = "Do not use fulltext indexes"
DDLAvoidGeometryAnnotation = "Using spatial fields and spatial indexes will increase storage requirements and have a certain impact on database performance"
DDLAvoidGeometryDesc = "Avoid using spatial fields and spatial indexes"
DDLAvoidGeometryMessage = "Avoid using spatial fields and spatial indexes"
DDLAvoidTextAnnotation = "Splitting TEXT type fields from the original table into another table can improve database performance and query speed, reducing unnecessary I/O operations."
DDLAvoidTextDesc = "It is recommended to split TEXT type fields from the original table and store them separately with the original table primary key"
DDLAvoidTextMessage = "Field: %v is of TEXT type, it is recommended to split from the original table and store separately with the original table primary key"
DDLCheckAllIndexNotNullConstraintAnnotation = "All index fields are not constrained as not null, please confirm the rationality of the table index planning."
DDLCheckAllIndexNotNullConstraintDesc = "Add a not null constraint to at least one index"
DDLCheckAllIndexNotNullConstraintMessage = "Add a not null constraint to at least one index"
DDLCheckAlterTableNeedMergeAnnotation = "Avoid the consumption and impact on online business brought by multiple TABLE REBUILD"
DDLCheckAlterTableNeedMergeDesc = "There are multiple modification statements for the same table, it is recommended to merge them into one ALTER statement"
DDLCheckAlterTableNeedMergeMessage = "There are already modification statements for this table, it is recommended to merge them into one ALTER statement"
DDLCheckAutoIncrementAnnotation = "If AUTO_INCREMENT is set to 0 when creating a table, auto-increment starts from 1, which can avoid data holes. For example, when exporting the table structure DDL, AUTO_INCREMENT in the table structure is usually the current auto-increment value. If AUTO_INCREMENT is not set to 0 when creating the table, creating the table through this DDL will cause the auto-increment value to start from a meaningless number."
DDLCheckAutoIncrementDesc = "The initial AUTO_INCREMENT value of the table is recommended to be 0"
DDLCheckAutoIncrementFieldNumAnnotation = "MySQL InnoDB, MyISAM engine does not allow multiple auto-increment fields, setting multiple auto-increment fields will result in deployment failure."
DDLCheckAutoIncrementFieldNumDesc = "When creating a table, only one auto-increment field can be set"
DDLCheckAutoIncrementFieldNumMessage = "When creating a table, only one auto-increment field can be set"
DDLCheckAutoIncrementMessage = "The initial AUTO_INCREMENT value of the table is recommended to be 0"
DDLCheckBigintInsteadOfDecimalAnnotation = "Because CPU does not support direct operations on DECIMAL, it is only MySQL itself that implements high-precision calculations of DECIMAL, but the calculation cost is high, and the space occupied is also more when storing values of the same range; using BIGINT instead of DECIMAL, you can multiply by the corresponding multiple according to the number of decimal places, so as to achieve precise floating-point storage and calculation, avoiding the high cost of DECIMAL calculation"
DDLCheckBigintInsteadOfDecimalDesc = "Use BIGINT type instead of DECIMAL"
DDLCheckBigintInsteadOfDecimalMessage = "It is recommended to use BIGINT type instead of DECIMAL for column %s"
DDLCheckCharLengthAnnotation = "Using too long or too many varchar, char fields may increase the complexity of business logic; if the average length of the field is too large, it will occupy more storage space."
DDLCheckCharLengthDesc = "Prohibit the total character length of char, varchar type fields from exceeding the threshold"
DDLCheckCharLengthMessage = "Prohibit the total character length of char, varchar type fields from exceeding the threshold %v"
DDLCheckCharLengthParams1 = "Character length"
DDLCheckColumnBlobDefaultIsNotNullAnnotation = "In strict SQL_MODE mode, BLOB and TEXT types cannot set default values. If data is inserted without specifying a value, the field will be set to NULL"
DDLCheckColumnBlobDefaultIsNotNullDesc = "The default value of BLOB and TEXT type fields can only be NULL"
DDLCheckColumnBlobDefaultIsNotNullMessage = "The default value of BLOB and TEXT type fields can only be NULL"
DDLCheckColumnBlobNoticeAnnotation = "BLOB or TEXT type consumes a lot of network and IO bandwidth, and DML operations on this table will become very slow"
DDLCheckColumnBlobNoticeDesc = "It is not recommended to use BLOB or TEXT type"
DDLCheckColumnBlobNoticeMessage = "It is not recommended to use BLOB or TEXT type"
DDLCheckColumnBlobWithNotNullAnnotation = "BLOB and TEXT type fields cannot specify default values. If data is inserted without specifying a field, the default is NULL. If a NOT NULL constraint is added, writing data without specifying a value for the field will result in writing failure"
DDLCheckColumnBlobWithNotNullDesc = "It is not recommended to set BLOB and TEXT type fields to NOT NULL"
DDLCheckColumnBlobWithNotNullMessage = "It is not recommended to set BLOB and TEXT type fields to NOT NULL"
DDLCheckColumnCharLengthAnnotation = "VARCHAR is a variable-length field, which saves storage space and has higher retrieval efficiency for relatively small fields"
DDLCheckColumnCharLengthDesc = "When the length of CHAR is greater than 20, the VARCHAR type must be used"
DDLCheckColumnCharLengthMessage = "When the length of CHAR is greater than 20, the VARCHAR type must be used"
DDLCheckColumnEnumNoticeAnnotation = "ENUM type is not a SQL standard, it is less portable. If you modify or add enum values later, you need to rebuild the entire table, which is costly and cannot be sorted by literal values"
DDLCheckColumnEnumNoticeDesc = "It is not recommended to use ENUM type"
DDLCheckColumnEnumNoticeMessage = "It is not recommended to use ENUM type"
DDLCheckColumnNotNULLAnnotation = "Table fields are recommended to have NOT NULL constraints, which can ensure data integrity, prevent inserting null values, and improve query accuracy."
DDLCheckColumnNotNULLDesc = "Table fields are recommended to have NOT NULL constraints"
DDLCheckColumnNotNULLMessage = "It is recommended to set NOT NULL constraint for field %v"
DDLCheckColumnQuantityAnnotation = "Avoid wide table design on OLTP systems, which will greatly affect performance later; specific rule thresholds can be adjusted according to business needs, the default value is: 40"
DDLCheckColumnQuantityDesc = "The number of columns in a table is not recommended to exceed the threshold"
DDLCheckColumnQuantityInPKAnnotation = "Too many columns in the primary key will cause the secondary index to occupy more space and increase the cost of index maintenance; specific rule thresholds can be adjusted according to business needs, the default value is: 2"
DDLCheckColumnQuantityInPKDesc = "The number of columns included in the primary key is not recommended to exceed the threshold"
DDLCheckColumnQuantityInPKMessage = "The number of columns included in the primary key is not recommended to exceed the threshold"
DDLCheckColumnQuantityInPKParams1 = "Maximum column quantity"
DDLCheckColumnQuantityMessage = "The number of columns in the table is not recommended to exceed the threshold"
DDLCheckColumnQuantityParams1 = "Maximum column quantity"
DDLCheckColumnSetNoticeAnnotation = "Modification of the set requires redefinition of the column, which is expensive to modify later. It is recommended to implement it in the business layer"
DDLCheckColumnSetNoticeDesc = "It is not recommended to use the SET type"
DDLCheckColumnSetNoticeMessage = "It is not recommended to use the SET type"
DDLCheckColumnTimestampWithoutDefaultAnnotation = "Add default value to TIMESTAMP to avoid the situation that all 0 date format does not match business expectation"
DDLCheckColumnTimestampWithoutDefaultDesc = "The column of TIMESTAMP type must add default value"
DDLCheckColumnTimestampWithoutDefaultMessage = "The column of TIMESTAMP type must add default value"
DDLCheckColumnTypeIntegerAnnotation = "INT(M) or BIGINT(M), M represents the maximum display width, the maximum value storage width is 10, 20 respectively, using INT(10) or BIGINT(20) can avoid possible display truncation"
DDLCheckColumnTypeIntegerDesc = "It is recommended to use INT(10) or BIGINT(20) for integer definition"
DDLCheckColumnTypeIntegerMessage = "It is recommended to use INT(10) or BIGINT(20) for integer definition"
DDLCheckColumnWithoutCommentAnnotation = "Adding comments to columns can make the meaning of columns more clear and facilitate future maintenance"
DDLCheckColumnWithoutCommentDesc = "It is recommended to add comments to columns"
DDLCheckColumnWithoutCommentMessage = "It is recommended to add comments to columns"
DDLCheckColumnWithoutDefaultAnnotation = "Adding default value to column can avoid the impact of query when column is NULL"
DDLCheckColumnWithoutDefaultDesc = "Except for auto-increment column and large field column, each column must add default value"
DDLCheckColumnWithoutDefaultMessage = "Except for auto-increment column and large field column, each column must add default value"
DDLCheckCompositeIndexDistinctionAnnotation = "Putting fields with high distinction degree in the front of the composite index can help improve the query performance of the index, because it can reduce the data range faster and improve the retrieval efficiency."
DDLCheckCompositeIndexDistinctionDesc = "It is recommended to put the fields with high distinction degree in the front of the composite index"
DDLCheckCompositeIndexDistinctionMessage = "It is recommended to put the fields with high distinction degree in the front of the composite index, %v"
DDLCheckCompositeIndexMaxAnnotation = "Composite index will create corresponding combination indexes according to the number of index columns. The more columns, the more indexes created, each index will increase disk space overhead and also increase index maintenance overhead; the specific rule threshold can be adjusted according to business needs, default value: 3"
DDLCheckCompositeIndexMaxDesc = "The number of columns in the composite index is not recommended to exceed the threshold"
DDLCheckCompositeIndexMaxMessage = "The number of columns in the composite index is not recommended to exceed %v"
DDLCheckCompositeIndexMaxParams1 = "Maximum number of index columns"
DDLCheckCreateFunctionAnnotation = "Custom functions, poor maintenance, and high dependence will lead to SQL being unable to be used across databases"
DDLCheckCreateFunctionDesc = "Prohibit the use of custom functions"
DDLCheckCreateFunctionMessage = "Prohibit the use of custom functions"
DDLCheckCreateProcedureAnnotation = "Stored procedures can make the program difficult to debug and expand to some extent. The syntax of stored procedures in various databases is very different, which brings great difficulties to future database migration and greatly increases the probability of bugs"
DDLCheckCreateProcedureDesc = "Prohibit the use of stored procedures"
DDLCheckCreateProcedureMessage = "Prohibit the use of stored procedures"
DDLCheckCreateTimeColumnAnnotation = "Using CREATE_TIME field is helpful for problem tracking and data retrieval, and avoids inconvenient data lifecycle management in the future. The default value CURRENT_TIMESTAMP can ensure the accuracy of time"
DDLCheckCreateTimeColumnDesc = "It is recommended that the table DDL include the creation time field and the default value is CURRENT_TIMESTAMP"
DDLCheckCreateTimeColumnMessage = "It is recommended that the table DDL include %v field and the default value is CURRENT_TIMESTAMP"
DDLCheckCreateTimeColumnParams1 = "Creation time field name"
DDLCheckCreateTriggerAnnotation = "Triggers are difficult to develop and maintain, cannot be transplanted efficiently, and are prone to deadlocks affecting business in complex logic and high concurrency"
DDLCheckCreateTriggerDesc = "Prohibit the use of triggers"
DDLCheckCreateTriggerMessage = "Prohibit the use of triggers"
DDLCheckCreateViewAnnotation = "The query performance of view is poor, and the base table structure changes, the view needs to be maintained. If the view is poor in readability and contains complex logic, it will increase the maintenance cost"
DDLCheckCreateViewDesc = "Prohibit the use of views"
DDLCheckCreateViewMessage = "Prohibit the use of views"
DDLCheckDatabaseCollationAnnotation = "By constraining the global database collation through this rule, it is possible to avoid creating unexpected database collation and prevent unexpected sorting results on the business side. It is recommended that the database tables in the project use unified character set and character set collation. In some cases of table join query, inconsistent character set or collation of fields may cause index failure and are difficult to find"
DDLCheckDatabaseCollationDesc = "It is recommended to use the specified database collation"
DDLCheckDatabaseCollationMessage = "It is recommended to use the specified database collation as %s"
DDLCheckDatabaseCollationParams1 = "Database collation"
DDLCheckDatabaseSuffixAnnotation = "By configuring this rule, you can standardize the database naming rules for a specific business. The specific naming convention can be customized. The default prompt value: _DB"
DDLCheckDatabaseSuffixDesc = "It is recommended to use a fixed suffix for the database name"
DDLCheckDatabaseSuffixMessage = "It is recommended that the database name ends with \"%v\""
DDLCheckDatabaseSuffixParams1 = "Database name suffix"
DDLCheckDecimalTypeColumnAnnotation = "For floating point operations, DECIMAL has higher accuracy"
DDLCheckDecimalTypeColumnDesc = "Use DECIMAL for precise floating-point numbers"
DDLCheckDecimalTypeColumnMessage = "Use DECIMAL for precise floating-point numbers"
DDLCheckFieldNotNUllMustContainDefaultValueAnnotation = "If there are NOT NULL fields without default values, inserting records without these fields will cause errors"
DDLCheckFieldNotNUllMustContainDefaultValueDesc = "Set a default value for fields with NOT NULL constraints"
DDLCheckFieldNotNUllMustContainDefaultValueMessage = "Set a default value for fields with NOT NULL constraints. The following fields are not compliant: %v"
DDLCheckFullWidthQuotationMarksAnnotation = "Enable this rule to avoid MySQL treating Chinese full-width quotation marks as part of the name, resulting in unexpected execution results"
DDLCheckFullWidthQuotationMarksDesc = "Avoid using Chinese full-width quotation marks in DDL statements"
DDLCheckFullWidthQuotationMarksMessage = "Avoid using Chinese full-width quotation marks in DDL statements. This might be a typo"
DDLCheckIndexCountAnnotation = "Each index created on a table increases storage overhead. Indexes also increase processing overhead for insert, delete, and update operations. Too many, insufficient, or incorrect indexes are useless for performance. The specific rule threshold can be adjusted according to business needs. Default value: 5"
DDLCheckIndexCountDesc = "The number of indexes should not exceed the threshold"
DDLCheckIndexCountMessage = "The number of indexes should not exceed %v"
DDLCheckIndexCountParams1 = "Maximum number of indexes"
DDLCheckIndexNotNullConstraintAnnotation = "If there are no NOT NULL constraints on the indexed field, table records and index records will not be completely mapped."
DDLCheckIndexNotNullConstraintDesc = "Indexed fields should have NOT NULL constraints"
DDLCheckIndexNotNullConstraintMessage = "These indexed fields (%v) need NOT NULL constraints"
DDLCheckIndexOptionAnnotation = "Choose fields with high selectivity as indexes for fast data localization. Low selectivity cannot effectively utilize indexes and may even require scanning a large number of data pages, slowing down SQL. The specific rule threshold can be adjusted according to business needs. Default value: 70"
DDLCheckIndexOptionDesc = "Index fields should have selectivity greater than the threshold"
DDLCheckIndexOptionMessage = "Index %v does not exceed the selectivity threshold of %v percent. It is not recommended to select as an index"
DDLCheckIndexOptionParams1 = "Selectivity (percentage)"
DDLCheckIndexPrefixAnnotation = "Configure this rule to standardize the index naming rules for specific businesses. The specific naming rules can be customized. Default prompt value: idx_"
DDLCheckIndexPrefixDesc = "Use a fixed prefix for ordinary indexes"
DDLCheckIndexPrefixMessage = "Use \"%v\" as the prefix for ordinary indexes"
DDLCheckIndexPrefixParams1 = "Index prefix"
DDLCheckIndexTooManyAnnotation = "Too many indexes on a single field. Generally, these indexes have no value. Conversely, it will reduce the performance of adding and deleting data, especially for tables with frequent updates. The specific rule threshold can be adjusted according to business needs. Default value: 2"
DDLCheckIndexTooManyDesc = "The number of indexes on a single field should not exceed the threshold"
DDLCheckIndexTooManyMessage = "The number of indexes on field %v should not exceed %v"
DDLCheckIndexTooManyParams1 = "Maximum number of indexes for a single field"
DDLCheckIndexedColumnWithBlobAnnotation = "BLOB type belongs to large field type, using it as an index will occupy a large amount of storage space"
DDLCheckIndexedColumnWithBlobDesc = "Do not include BLOB columns in indexes"
DDLCheckIndexedColumnWithBlobMessage = "Do not include BLOB columns in indexes"
DDLCheckIndexesExistBeforeCreateConstraintsAnnotation = "Create indexes before creating constraints. Constraints can be applied to secondary indexes to avoid full table scans and improve performance"
DDLCheckIndexesExistBeforeCreateConstraintsDesc = "Create indexes before creating constraints on fields"
DDLCheckIndexesExistBeforeCreateConstraintsMessage = "Create indexes before creating constraints on fields"
DDLCheckIsExistLimitOffsetAnnotation = "For example: LIMIT N OFFSET M or LIMIT M,N. When the offset m is too large, the query efficiency will be very low because MySQL first retrieves m+n data and then discards the first m data. For MySQL tables with large amounts of data, using LIMIT pagination has serious performance problems"
DDLCheckIsExistLimitOffsetDesc = "Avoid using offsets in pagination queries"
DDLCheckIsExistLimitOffsetMessage = "Avoid using offsets in pagination queries"
DDLCheckObjectNameIsUpperAndLowerLetterMixedAnnotation = "Database object naming convention. It is not recommended to use a mixed case format. It is recommended to connect words with underscores to improve code readability"
DDLCheckObjectNameIsUpperAndLowerLetterMixedDesc = "Database object names should not be mixed case"
DDLCheckObjectNameIsUpperAndLowerLetterMixedMessage = "Database object names should not be mixed case. The following object names are not compliant: %v"
DDLCheckObjectNameLengthAnnotation = "Configure this rule to standardize the object naming length of specific businesses. The specific length can be customized. Default maximum length: 64. This is the maximum length of identifiers allowed by MySQL"
DDLCheckObjectNameLengthDesc = "The length of table names, column names, and index names should not exceed the threshold"
DDLCheckObjectNameLengthMessage = "The length of table names, column names, and index names should not exceed %v bytes"
DDLCheckObjectNameLengthParams1 = "Maximum length (bytes)"
DDLCheckObjectNameUseCNAnnotation = "Configure this rule to standardize the data object naming rules of specific businesses"
DDLCheckObjectNameUseCNDesc = "Database object names can only use English characters, underscores, or numbers. The first letter must be English"
DDLCheckObjectNameUseCNMessage = "Database object names can only use English characters, underscores, or numbers. The first letter must be English"
DDLCheckObjectNameUsingKeywordAnnotation = "Configure this rule to standardize the data object naming rules of specific businesses to avoid conflicts and confusion"
DDLCheckObjectNameUsingKeywordDesc = "Database object names are forbidden to use reserved words"
DDLCheckObjectNameUsingKeywordMessage = "Database object names are forbidden to use reserved words %s"
DDLCheckPKNameAnnotation = "Configure this rule to standardize the primary key naming rules of specific businesses"
DDLCheckPKNameDesc = "Suggest using \"PK_table_name\" as primary key name"
DDLCheckPKNameMessage = "Suggest using \"PK_table_name\" as primary key name"
DDLCheckPKNotExistAnnotation = "Primary key ensures global uniqueness of data, which can improve data retrieval efficiency"
DDLCheckPKNotExistDesc = "Table must have a primary key"
DDLCheckPKNotExistMessage = "Table must have a primary key"
DDLCheckPKProhibitAutoIncrementAnnotation = "It is relatively inconvenient to maintain later, overly relying on database auto-increment mechanism to achieve global uniqueness, difficult to split, and easy to cause primary key conflicts"
DDLCheckPKProhibitAutoIncrementDesc = "Do not recommend using auto-increment for primary key"
DDLCheckPKProhibitAutoIncrementMessage = "Do not recommend using auto-increment for primary key"
DDLCheckPKWithoutAutoIncrementAnnotation = "Auto-increment primary key, numeric type is fast, and it is incremental growth, occupies less space, faster data insertion operations, avoiding increasing the cost of maintaining indexes"
DDLCheckPKWithoutAutoIncrementDesc = "Suggest using auto-increment for primary key"
DDLCheckPKWithoutAutoIncrementMessage = "Suggest using auto-increment for primary key"
DDLCheckPKWithoutBigintUnsignedAnnotation = "BIGINT UNSIGNED has a larger range of values. It is recommended to enable this rule to avoid overflow"
DDLCheckPKWithoutBigintUnsignedDesc = "Suggest using BIGINT unsigned type for primary key, i.e. BIGINT UNSIGNED"
DDLCheckPKWithoutBigintUnsignedMessage = "Suggest using BIGINT unsigned type for primary key, i.e. BIGINT UNSIGNED"
DDLCheckPKWithoutIfNotExistsAnnotation = "If the table already exists when creating a new table, adding CREATE without IF NOT EXISTS will cause an error in executing SQL. It is recommended to enable this rule to avoid errors in actual execution of SQL"
DDLCheckPKWithoutIfNotExistsDesc = "Suggest adding IF NOT EXISTS when creating a new table to ensure that repeated execution does not cause errors"
DDLCheckPKWithoutIfNotExistsMessage = "Suggest adding IF NOT EXISTS when creating a new table to ensure that repeated execution does not cause errors"
DDLCheckRedundantIndexAnnotation = "MySQL needs to maintain duplicate indexes separately. Redundant indexes increase maintenance costs, and the optimizer needs to calculate the cost one by one when optimizing queries, which affects query performance"
DDLCheckRedundantIndexDesc = "Do not recommend creating redundant indexes"
DDLCheckRedundantIndexMessage = "%v"
DDLCheckTableCharacterSetAnnotation = "This rule constrains the global database character set, avoiding the creation of unexpected character sets and preventing “garbled code” problems on the business side. It is recommended that the library tables in the project use a unified character set and character set sorting. In some cases of join queries, inconsistent character sets or sorting rules of fields may lead to index failure and be difficult to detect"
DDLCheckTableCharacterSetDesc = "Suggest using the specified database character set"
DDLCheckTableCharacterSetMessage = "Suggest using %v database character set"
DDLCheckTableCharacterSetParams1 = "Database character set"
DDLCheckTableDBEngineAnnotation = "By configuring this rule, you can standardize the database engine specified by the business. Specific rules can be customized. The default value is INNODB. INNODB supports transactions, row-level locks, better recoverability, and better performance under high concurrency"
DDLCheckTableDBEngineDesc = "Suggest using the specified database engine"
DDLCheckTableDBEngineMessage = "Suggest using %v database engine"
DDLCheckTableDBEngineParams1 = "Database engine"
DDLCheckTablePartitionAnnotation = "A partitioned table is physically a collection of files, and logically it is one table. Cross-partition queries may be less efficient. It is recommended to use physical table splitting to manage large amounts of data"
DDLCheckTablePartitionDesc = "Do not recommend using partitioned table features"
DDLCheckTablePartitionMessage = "Do not recommend using partitioned table features"
DDLCheckTableRowsAnnotation = "When the number of rows in a table exceeds the threshold, splitting the table can help improve database performance and query speed."
DDLCheckTableRowsDesc = "When the number of rows in a table exceeds the threshold, it is recommended to split the table"
DDLCheckTableRowsMessage = "When the number of rows in a table exceeds the threshold, it is recommended to split the table"
DDLCheckTableRowsParams1 = "Number of rows (ten thousands)"
DDLCheckTableSizeAnnotation = "Executing DDL on large tables takes a long time and has a high load, occupying lock resources for a long time, which will affect database performance; the specific rule threshold can be adjusted according to business needs. The default value is 1024"
DDLCheckTableSizeDesc = "Do not recommend executing DDL on tables with large amounts of data"
DDLCheckTableSizeMessage = "Table %v space should not exceed %vMB for DDL execution"
DDLCheckTableSizeParams1 = "Table space size (MB)"
DDLCheckTableWithoutCommentAnnotation = "Adding comments to the table can make the meaning of the table more clear and facilitate future maintenance"
DDLCheckTableWithoutCommentDesc = "Suggest adding comments to the table"
DDLCheckTableWithoutCommentMessage = "Suggest adding comments to the table"
DDLCheckTransactionIsolationLevelAnnotation = "RC avoids dirty reads but does not solve the problem of phantom reads. Using RR can avoid phantom reads, but the introduction of gap locks can lead to an expansion of the locking range, which can affect concurrency and easily lead to deadlocks. Therefore, in most business scenarios, the probability of phantom reads is low, and RC can basically meet business needs"
DDLCheckTransactionIsolationLevelDesc = "Suggest setting transaction isolation level to RC"
DDLCheckTransactionIsolationLevelMessage = "Suggest setting transaction isolation level to RC"
DDLCheckUniqueIndexAnnotation = "By configuring this rule, you can standardize the naming rules for UNIQUE indexes specified by the business"
DDLCheckUniqueIndexDesc = "Suggest using IDX_UK_table_name_field_name for UNIQUE index name"
DDLCheckUniqueIndexMessage = "Suggest using IDX_UK_table_name_field_name for UNIQUE index name"
DDLCheckUniqueIndexPrefixAnnotation = "By configuring this rule, you can standardize the naming rules for UNIQUE indexes specified by the business. Specific naming conventions can be customized. The default hint is: uniq_"
DDLCheckUniqueIndexPrefixDesc = "Suggest using a fixed prefix for UNIQUE indexes"
DDLCheckUniqueIndexPrefixMessage = "Suggest using \"%v\" as the prefix for UNIQUE index"
DDLCheckUniqueIndexPrefixParams1 = "Index prefix"
DDLCheckUpdateTimeColumnAnnotation = "Using an update time field is helpful for problem tracking, data retrieval, and data lifecycle management. The default value UPDATE_TIME ensures time accuracy."
DDLCheckUpdateTimeColumnDesc = "Table DDL should include an update time field with the default value CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"
DDLCheckUpdateTimeColumnMessage = "Table DDL should include %v field with the default value CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"
DDLCheckUpdateTimeColumnParams1 = "Update time field name"
DDLCheckVarcharSizeAnnotation = "MySQL does not limit the size of indexed columns, the index length will default to the length of the field. A longer VARCHAR definition will result in a larger index storage size. Adjust the threshold according to your business needs, default value: 1024."
DDLCheckVarcharSizeDesc = "Defining a VARCHAR length greater than the threshold is not recommended"
DDLCheckVarcharSizeMessage = "Defining a VARCHAR length greater than the threshold is not recommended. The threshold is %d"
DDLCheckVarcharSizeParams1 = "Maximum VARCHAR length"
DDLDisableAlterFieldUseFirstAndAfterAnnotation = "FIRST and AFTER ALTER operations are completed using COPY TABLE, which can have a significant impact on your business."
DDLDisableAlterFieldUseFirstAndAfterDesc = "Do not use FIRST or AFTER for ALTER table fields"
DDLDisableAlterFieldUseFirstAndAfterMessage = "Do not use FIRST or AFTER for ALTER table fields"
DDLDisableDropStatementAnnotation = "DROP is a DDL operation, data changes are not written to the log and cannot be rolled back. It's recommended to enable this rule to avoid accidental deletions."
DDLDisableDropStatementDesc = "Do not use DROP operations except for indexes"
DDLDisableDropStatementMessage = "Do not use DROP operations except for indexes"
DDLDisableFKAnnotation = "Foreign keys can be a performance bottleneck in high concurrency scenarios, leading to deadlocks. They also make maintenance (splitting, migration) more difficult."
DDLDisableFKDesc = "Do not use foreign keys"
DDLDisableFKMessage = "Do not use foreign keys"
DDLDisableTypeTimestampAnnotation = "TIMESTAMP has a maximum value limit ('2038-01-19 03:14:07' UTC) and can lead to time zone conversion issues."
DDLDisableTypeTimestampDesc = "Do not use TIMESTAMP fields"
DDLDisableTypeTimestampMessage = "Do not use TIMESTAMP fields"
DDLHintDropColumnAnnotation = "Business logic and dependencies on the deleted column have not been completely eliminated. Deleting the column may lead to abnormal program behavior (inability to read or write normally). Enabling this rule will remind you that deleting a column is a high-risk operation."
DDLHintDropColumnDesc = "Do not delete columns"
DDLHintDropColumnMessage = "Do not delete columns"
DDLHintDropForeignKeyAnnotation = "Deleting existing constraints will affect existing business logic. Enabling this rule will remind you that deleting foreign keys is a high-risk operation."
DDLHintDropForeignKeyDesc = "Do not delete foreign keys"
DDLHintDropForeignKeyMessage = "Do not delete foreign keys"
DDLHintDropPrimaryKeyAnnotation = "Deleting existing constraints will affect existing business logic. Enabling this rule will remind you that deleting primary keys is a high-risk operation."
DDLHintDropPrimaryKeyDesc = "Do not delete primary keys"
DDLHintDropPrimaryKeyMessage = "Do not delete primary keys"
DDLHintUpdateTableCharsetWillNotUpdateFieldCharsetAnnotation = "Modifying the table's default character set only affects subsequently added fields, not existing fields. If you need to change the character set of all fields in the table, it is recommended to enable this rule."
DDLHintUpdateTableCharsetWillNotUpdateFieldCharsetDesc = "Do not modify the table's default character set"
DDLHintUpdateTableCharsetWillNotUpdateFieldCharsetMessage = "Do not modify the table's default character set"
DDLNotAllowRenamingAnnotation = "RENAME/CHANGE table name/column name will impact online business non-stop deployment. If you need this operation, it should be manually intervened by DBA."
DDLNotAllowRenamingDesc = "Do not use RENAME or CHANGE to modify table or field names"
DDLNotAllowRenamingMessage = "Do not use RENAME or CHANGE to modify table or field names"
DDLRecommendTableColumnCharsetSameAnnotation = "Unified character set can avoid garbled characters caused by character set conversion. Comparing different character sets requires conversion, which can cause index failure."
DDLRecommendTableColumnCharsetSameDesc = "It is recommended to use the same character set for columns and tables"
DDLRecommendTableColumnCharsetSameMessage = "It is recommended to use the same character set for columns and tables"
DMLAvoidWhereEqualNullAnnotation = "NULL is a special value in SQL and cannot be compared with ordinary values. For example: column = NULL is always false. Even if there are null values in column, it will not be queried, so column = NULL should be written as column is NULL."
DMLAvoidWhereEqualNullDesc = "Do not compare NULL values with other fields or values in the WHERE clause"
DMLAvoidWhereEqualNullMessage = "Do not compare NULL values with other fields or values in the WHERE clause"
DMLCheckAffectedRowsAnnotation = "If a DML operation affects too many rows, it can lead to query performance degradation because it needs to scan more data."
DMLCheckAffectedRowsDesc = "UPDATE/DELETE operations are not recommended to affect more than the threshold number of rows"
DMLCheckAffectedRowsMessage = "UPDATE/DELETE operations are not recommended to affect more than the threshold number of rows. Affected rows are %v, exceeding the set threshold %v"
DMLCheckAffectedRowsParams1 = "Maximum affected rows"
DMLCheckAggregateAnnotation = "It is not recommended to use SQL aggregate functions to ensure query simplicity, high performance, and data consistency."
DMLCheckAggregateDesc = "Do not use aggregate functions"
DMLCheckAggregateMessage = "Do not use aggregate functions for calculation"
DMLCheckAliasAnnotation = "The alias of a table or column is the same as its real name, which makes the query harder to distinguish"
DMLCheckAliasDesc = "Do not recommend using the same alias as the table or column name"
DMLCheckAliasMessage = "These aliases (%v) are the same as the column or table names"
DMLCheckBatchInsertListsMaxAnnotation = "Avoid large transactions and reduce the impact of rollbacks on business; The specific rule threshold can be adjusted according to business needs, default value: 100"
DMLCheckBatchInsertListsMaxDesc = "For a single INSERT statement, it is recommended to insert no more than the threshold"
DMLCheckBatchInsertListsMaxMessage = "For a single INSERT statement, it is recommended to insert no more than %v rows"
DMLCheckBatchInsertListsMaxParams1 = "Maximum number of rows to insert"
DMLCheckExplainAccessTypeAllAnnotation = "When full table scan, the number of scanned rows should not exceed the specified number to avoid performance issues; The specific rule threshold can be adjusted according to business needs, default value: 10000; If set to 0, full table scan will trigger the rule"
DMLCheckExplainAccessTypeAllDesc = "When full table scan, the number of scanned rows should not exceed the specified number (default value: 10000)"
DMLCheckExplainAccessTypeAllMessage = "This query uses a full table scan and scans %v rows"
DMLCheckExplainAccessTypeAllParams1 = "Maximum number of rows scanned"
DMLCheckExplainExtraUsingFilesortAnnotation = "In case of large data volume, file sorting means low SQL performance, which will increase the OS overhead and affect database performance"
DMLCheckExplainExtraUsingFilesortDesc = "Do not recommend using file sorting"
DMLCheckExplainExtraUsingFilesortMessage = "Do not recommend using file sorting"
DMLCheckExplainExtraUsingIndexForSkipScanAnnotation = "Index scan is jump scan, not following the leftmost matching principle, which may reduce the efficiency of index usage and affect query performance"
DMLCheckExplainExtraUsingIndexForSkipScanDesc = "Do not recommend index jump scan on the table"
DMLCheckExplainExtraUsingIndexForSkipScanMessage = "Do not recommend index jump scan on the table"
DMLCheckExplainExtraUsingTemporaryAnnotation = "In case of large data volume, temporary table means low SQL performance, which will increase the OS overhead and affect database performance"
DMLCheckExplainExtraUsingTemporaryDesc = "Do not recommend using temporary tables"
DMLCheckExplainExtraUsingTemporaryMessage = "Do not recommend using temporary tables"
DMLCheckExplainFullIndexScanAnnotation = "In case of large data volume, full index scan seriously affects SQL performance."
DMLCheckExplainFullIndexScanDesc = "Do not recommend full index scan on the table"
DMLCheckExplainFullIndexScanMessage = "Do not recommend full index scan on the table"
DMLCheckExplainUsingIndexAnnotation = "Using index can significantly improve the performance of SQL query."
DMLCheckExplainUsingIndexDesc = "SQL query conditions need to use index"
DMLCheckExplainUsingIndexMessage = "It is recommended to use index to optimize SQL query performance"
DMLCheckFuzzySearchAnnotation = "Using full fuzzy search or left fuzzy search will lead to the query unable to use index, resulting in full table scan"
DMLCheckFuzzySearchDesc = "Prohibit full fuzzy search or left fuzzy search"
DMLCheckFuzzySearchMessage = "Prohibit full fuzzy search or left fuzzy search"
DMLCheckHasJoinConditionAnnotation = "Specifying join conditions can ensure the correctness and reliability of join operations. If no join conditions are specified, it may lead to join failure or incorrect join."
DMLCheckHasJoinConditionDesc = "It is recommended to specify join conditions for join operations"
DMLCheckHasJoinConditionMessage = "It is recommended to specify join conditions for join operations, JOIN fields must have ON conditions"
DMLCheckIfAfterUnionDistinctAnnotation = "UNION sorts and dedupes according to the order of fields, UNION ALL simply merges the two results and returns them. In terms of efficiency, UNION ALL is much faster than UNION; If the two merged results can contain duplicate data and do not need sorting, it is recommended to enable this rule and use UNION ALL instead of UNION"
DMLCheckIfAfterUnionDistinctDesc = "It is recommended to use UNION ALL instead of UNION"
DMLCheckIfAfterUnionDistinctMessage = "It is recommended to use UNION ALL instead of UNION"
DMLCheckInQueryNumberAnnotation = "When there are too many IN values, it may cause the query to perform a full table scan, which will cause MySQL performance to drop sharply; The specific rule threshold can be adjusted according to business needs, default value: 50"
DMLCheckInQueryNumberDesc = "The number of parameters in the IN statement within the WHERE condition cannot exceed the threshold"
DMLCheckInQueryNumberMessage = "There are already %v parameters in the IN statement within the WHERE condition, it is not recommended to exceed the threshold %v"
DMLCheckInQueryNumberParams1 = "Maximum number of parameters in the in statement"
DMLCheckIndexSelectivityAnnotation = "Ensure the high index selectivity used in the SQL execution plan, which can help improve query performance and optimize query efficiency."
DMLCheckIndexSelectivityDesc = "It is recommended that when querying the database, ensure that the index selectivity used in the SQL execution plan is greater than the threshold"
DMLCheckIndexSelectivityMessage = "Index: %v, not exceeding the selectivity threshold: %v, it is recommended to use index exceeding the threshold."
DMLCheckIndexSelectivityParams1 = "Selectivity (percentage)"
DMLCheckInsertColumnsExistAnnotation = "When the table structure changes, and the INSERT request does not explicitly specify the column name, data insertion mismatch may occur; It is recommended to enable this rule to avoid the inserted result being inconsistent with business expectations"
DMLCheckInsertColumnsExistDesc = "INSERT statement needs to specify COLUMN"
DMLCheckInsertColumnsExistMessage = "INSERT statement needs to specify COLUMN"
DMLCheckInsertSelectAnnotation = "Using INSERT ... SELECT may cause a table-level lock on the queried table under the default transaction isolation level."
DMLCheckInsertSelectDesc = "Do not recommend using INSERT ... SELECT"
DMLCheckInsertSelectMessage = "Do not recommend using INSERT ... SELECT"
DMLCheckJoinFieldCharacterSetAndCollationAnnotation = "Consistent character set and collation of connected table fields can avoid data inconsistency and query errors, ensuring that the connection operation is executed correctly."
DMLCheckJoinFieldCharacterSetAndCollationDesc = "Character set and collation of joined table fields must be consistent"
DMLCheckJoinFieldCharacterSetAndCollationMessage = "Character set and collation of joined table fields must be consistent"
DMLCheckJoinFieldTypeAnnotation = "Inconsistent JOIN field types can lead to type mismatch and implicit type conversion, which may cause index failure. It is recommended to enable this rule to avoid index failure."
DMLCheckJoinFieldTypeDesc = "It is recommended to keep JOIN field types consistent"
DMLCheckJoinFieldTypeMessage = "It is recommended to keep JOIN field types consistent, otherwise implicit conversion may occur"
DMLCheckJoinFieldUseIndexAnnotation = "JOIN fields with indexes can improve the performance and query speed of join operations."
DMLCheckJoinFieldUseIndexDesc = "JOIN fields must contain indexes"
DMLCheckJoinFieldUseIndexMessage = "JOIN fields must contain indexes"
DMLCheckLimitMustExistAnnotation = "The LIMIT condition can reduce the cost of writing wrong SQL (deleting wrong data), and at the same time avoid long transactions from affecting business"
DMLCheckLimitMustExistDesc = "It is recommended to have LIMIT conditions for DELETE/UPDATE statements"
DMLCheckLimitMustExistMessage = "It is recommended to have LIMIT conditions for DELETE/UPDATE statements"
DMLCheckLimitOffsetNumAnnotation = "Because OFFSET specifies the starting position of the result set, if the starting position is too large, MySQL needs to process more data to return the result set, which may lead to a decline in query performance."
DMLCheckLimitOffsetNumDesc = "It is not recommended to have an offset larger than the threshold for LIMIT"
DMLCheckLimitOffsetNumMessage = "It is not recommended to have an offset larger than the threshold for LIMIT, OFFSET=%v (threshold is %v)"
DMLCheckLimitOffsetNumParams1 = "offset size"
DMLCheckMathComputationOrFuncOnIndexAnnotation = "Performing mathematical operations and using functions on indexed columns will cause index failure, resulting in full table scans and impacting query performance."
DMLCheckMathComputationOrFuncOnIndexDesc = "Prohibit mathematical operations and functions on indexed columns"
DMLCheckMathComputationOrFuncOnIndexMessage = "Prohibit mathematical operations and functions on indexed columns"
DMLCheckNeedlessFuncAnnotation = "By configuring this rule, you can specify the built-in functions that need to be prohibited in the business. Using built-in functions may cause SQL to not use indexes or produce unexpected results. The actual functions that need to be disabled can be configured through the rule settings."
DMLCheckNeedlessFuncDesc = "Avoid using unnecessary built-in functions"
DMLCheckNeedlessFuncMessage = "Avoid using unnecessary built-in functions %v"
DMLCheckNeedlessFuncParams1 = "The set of specified functions (comma-separated)"
DMLCheckNotEqualSymbolAnnotation = "'!=' is a non-standard operator, '<>' is the standard not-equals operator in SQL"
DMLCheckNotEqualSymbolDesc = "It is recommended to use '<>' instead of '!=' "
DMLCheckNotEqualSymbolMessage = "It is recommended to use '<>' instead of '!=' "
DMLCheckNumberOfJoinTablesAnnotation = "The more tables are joined, the more driver relationship combinations there are, and the higher the cost of comparing the execution cost of various result sets, which will significantly reduce SQL query performance; the specific rule threshold can be adjusted according to business needs, default value: 3"
DMLCheckNumberOfJoinTablesDesc = "It is recommended not to exceed the threshold when using JOIN to connect tables for query"
DMLCheckNumberOfJoinTablesMessage = "It is recommended not to exceed %v tables when using JOIN to connect tables for query"
DMLCheckNumberOfJoinTablesParams1 = "Maximum number of joined tables"
DMLCheckSQLInjectionFuncAnnotation = "Attackers can access data in the database without authorization through SQL injection, which poses security vulnerabilities such as stealing user information and causing user data leaks."
DMLCheckSQLInjectionFuncDesc = "It is not recommended to use common SQL injection functions"
DMLCheckSQLInjectionFuncMessage = "It is not recommended to use common SQL injection functions"
DMLCheckSQLLengthAnnotation = "Long SQL has poor readability, is difficult to maintain, and is prone to performance problems; the specific rule threshold can be adjusted according to business needs, default value: 1024"
DMLCheckSQLLengthDesc = "It is recommended to break down long SQL into several simple SQLs"
DMLCheckSQLLengthMessage = "It is recommended to break down long SQL into several simple SQLs"
DMLCheckSQLLengthParams1 = "Maximum SQL length"
DMLCheckSameTableJoinedMultipleTimesAnnotation = "If a single table is queried multiple times, it will cause a decrease in query performance."
DMLCheckSameTableJoinedMultipleTimesDesc = "It is not recommended to join the same table multiple times"
DMLCheckSameTableJoinedMultipleTimesMessage = "Table %v is joined multiple times"
DMLCheckScanRowsAnnotation = "The filter condition must include the primary key or index to reduce the time complexity of the database query and improve query efficiency."
DMLCheckScanRowsDesc = "The number of rows scanned exceeds the threshold, the filter condition must include the primary key or index"
DMLCheckScanRowsMessage = "The number of rows scanned exceeds the threshold, the filter condition must include the primary key or index"
DMLCheckScanRowsParams1 = "Number of rows scanned (ten thousand)"
DMLCheckSelectForUpdateAnnotation = "SELECT FOR UPDATE will add an exclusive lock to each row of data in the query result set. Other threads will be blocked from updating and deleting the record, which can easily lead to a large number of lock waits in the database under high concurrency, affecting database query performance."
DMLCheckSelectForUpdateDesc = "It is not recommended to use SELECT FOR UPDATE"
DMLCheckSelectForUpdateMessage = "It is not recommended to use SELECT FOR UPDATE"
DMLCheckSelectLimitAnnotation = "If the number of rows scanned by the query is large, it may cause the optimizer to choose the wrong index or even not use the index; the specific rule threshold can be adjusted according to business needs, default value: 1000"
DMLCheckSelectLimitDesc = "SELECT statement needs to have LIMIT"
DMLCheckSelectLimitMessage = "SELECT statement needs to have LIMIT, and the limit number cannot exceed %v"
DMLCheckSelectLimitParams1 = "Maximum number of rows to query"
DMLCheckSelectRowsAnnotation = "Adding primary key or index to the filter condition can improve query performance and reduce the cost of full table scan."
DMLCheckSelectRowsDesc = "Query data volume exceeds the threshold, filter conditions must include primary key or index"
DMLCheckSelectRowsMessage = "Query data volume exceeds the threshold, filter conditions must include primary key or index"
DMLCheckSelectRowsParams1 = "Query data volume (ten thousand)"
DMLCheckSelectWithOrderByAnnotation = "ORDER BY has a significant impact on query performance and is not conducive to optimization and maintenance. It is recommended to put the sorting part into business processing."
DMLCheckSelectWithOrderByDesc = "SELECT statement cannot have ORDER BY"
DMLCheckSelectWithOrderByMessage = "SELECT statement cannot have ORDER BY"
DMLCheckSortColumnLengthAnnotation = "Sorting operations such as ORDER BY, DISTINCT, GROUP BY, UNION on long fields like VARCHAR(2000) will cause sorting and have performance risks."
DMLCheckSortColumnLengthDesc = "Prohibit sorting long fields"
DMLCheckSortColumnLengthMessage = "It is not recommended to use fields longer than the threshold for ORDER BY, DISTINCT, GROUP BY, UNION. These fields are: %v"
DMLCheckSortColumnLengthParams1 = "Maximum length of sortable fields"
DMLCheckSortDirectionAnnotation = "Before MySQL 8.0, when the sorting directions specified by multiple columns in ORDER BY are different, the established index cannot be used. After MySQL 8.0, you can establish a corresponding joint index in sorting order to optimize"
DMLCheckSortDirectionDesc = "It is not recommended to use different sorting directions for multiple different conditions in the ORDER BY statement"
DMLCheckSortDirectionMessage = "It is not recommended to use different sorting directions for multiple different conditions in the ORDER BY statement"
DMLCheckSpacesAroundTheStringAnnotation = "Spaces before and after the string may cause the query judgment logic to be incorrect, such as in MySQL 5.5, 'a' and 'a ' are considered the same value in the query"
DMLCheckSpacesAroundTheStringDesc = "It is not recommended to include spaces at the beginning or end of a string in quotes"
DMLCheckSpacesAroundTheStringMessage = "It is not recommended to include spaces at the beginning or end of a string in quotes"
DMLCheckSubQueryNestNumAnnotation = "The nesting level of subqueries exceeds the threshold. In some cases, subqueries cannot use indexes. At the same time, for subqueries with a large result set, a large number of temporary tables will be generated, consuming too much CPU and IO resources, resulting in a large number of slow queries."
DMLCheckSubQueryNestNumDesc = "It is not recommended to exceed the threshold for the nesting level of subqueries"
DMLCheckSubQueryNestNumMessage = "The nesting level of subqueries exceeds the threshold %v"
DMLCheckSubQueryNestNumParams1 = "It is not recommended to exceed the threshold for the nesting level of subqueries"
DMLCheckSubqueryLimitAnnotation = "Some MySQL versions do not support 'LIMIT & IN/ALL/ANY/SOME' in subqueries."
DMLCheckSubqueryLimitDesc = "It is not recommended to use LIMIT in subqueries"
DMLCheckSubqueryLimitMessage = "It is not recommended to use LIMIT in subqueries"
DMLCheckTableSizeAnnotation = "DML operations on large tables take a long time and have a high load, which can affect database performance. The specific rule threshold can be adjusted according to business needs. Default value: 1024"
DMLCheckTableSizeDesc = "It is not recommended to perform DML operations on tables with too much data"
DMLCheckTableSizeMessage = "The table %v space for executing DML is not recommended to exceed %vMB"
DMLCheckTableSizeParams1 = "Table space size (MB)"
DMLCheckUpdateOrDeleteHasWhereAnnotation = "Because the purpose of these statements is to modify the data in the database, it is necessary to use WHERE conditions to filter the records to be updated or deleted to ensure the correctness of the data. In addition, using WHERE conditions can also improve query performance."
DMLCheckUpdateOrDeleteHasWhereDesc = "It is recommended to use WHERE conditions for UPDATE/DELETE operations"
DMLCheckUpdateOrDeleteHasWhereMessage = "It is recommended to use WHERE conditions for UPDATE/DELETE operations"
DMLCheckWhereExistFuncAnnotation = "Performing function operations on condition fields may destroy the order of index values, causing the optimizer to choose to abandon using the index, which greatly reduces query performance."
DMLCheckWhereExistFuncDesc = "Avoid using function operations on condition fields"
DMLCheckWhereExistFuncMessage = "Avoid using function operations on condition fields"
DMLCheckWhereExistImplicitConversionAnnotation = "Using data types that are inconsistent with the filter field in the WHERE condition will cause implicit data type conversion, which may lead to the risk of the query not hitting the index. In the case of high concurrency and large data volume, not using the index will significantly degrade the query performance of the database."
DMLCheckWhereExistImplicitConversionDesc = "It is not recommended to use data types that are inconsistent with the filter field in the WHERE condition"
DMLCheckWhereExistImplicitConversionMessage = "It is not recommended to use data types that are inconsistent with the filter field in the WHERE condition"
DMLCheckWhereExistNotAnnotation = "Using negative queries will lead to full table scans, resulting in slow SQL"
DMLCheckWhereExistNotDesc = "It is not recommended to use negative queries on condition fields"
DMLCheckWhereExistNotMessage = "It is not recommended to use negative queries on condition fields"
DMLCheckWhereExistScalarSubqueryAnnotation = "Scalar subqueries have the problem of multiple accesses to the same table, which has high execution overhead and low efficiency. You can use LEFT JOIN to replace scalar subqueries"
DMLCheckWhereExistScalarSubqueryDesc = "It is not recommended to use scalar subqueries"
DMLCheckWhereExistScalarSubqueryMessage = "It is not recommended to use scalar subqueries"
DMLCheckWhereIsInvalidAnnotation = "SQL without WHERE condition will perform full table scan during execution, resulting in extra overhead. It is recommended to enable it in a high-concurrency environment with large data volume to avoid affecting database query performance."
DMLCheckWhereIsInvalidDesc = "Prohibit SQL without WHERE condition or WHERE condition that is always TRUE"
DMLCheckWhereIsInvalidMessage = "Prohibit SQL without WHERE condition or WHERE condition that is always TRUE"
DMLCheckWithLimitAnnotation = "DELETE/UPDATE statement using LIMIT condition will randomly select data for deletion or update, the business cannot expect"
DMLCheckWithLimitDesc = "DELETE/UPDATE statement cannot have LIMIT condition"
DMLCheckWithLimitMessage = "DELETE/UPDATE statement cannot have LIMIT condition"
DMLCheckWithOrderByAnnotation = "DELETE/UPDATE has ORDER BY will use sorting, bringing unnecessary overhead"
DMLCheckWithOrderByDesc = "DELETE/UPDATE statements cannot have ORDER BY"
DMLCheckWithOrderByMessage = "DELETE/UPDATE statements cannot have ORDER BY"
DMLDisableSelectAllColumnAnnotation = "Using the * wildcard to select all columns when table structure changes will cause changes in query behavior, which is inconsistent with business expectations; at the same time, useless fields in SELECT * will bring unnecessary disk I/O and network overhead, and cannot cover the index, which will lead to table scan and greatly reduce query efficiency"
DMLDisableSelectAllColumnDesc = "Do not use SELECT *"
DMLDisableSelectAllColumnMessage = "Do not use SELECT *"
DMLHintCountFuncWithColAnnotation = "It is recommended to use COUNT(*), because using COUNT(COL) requires a full table scan, which may lead to performance degradation."
DMLHintCountFuncWithColDesc = "Avoid using COUNT(COL)"
DMLHintCountFuncWithColMessage = "Avoid using COUNT(COL)"
DMLHintDeleteTipsAnnotation = "DROP/TRUNCATE is DDL, the operation takes effect immediately, and will not be written to the log, so it cannot be rolled back. It is necessary to back up the data before performing high-risk operations"
DMLHintDeleteTipsDesc = "It is recommended to backup before performing DELETE/DROP/TRUNCATE operations"
DMLHintDeleteTipsMessage = "It is recommended to backup before performing DELETE/DROP/TRUNCATE operations"
DMLHintGroupByRequiresConditionsAnnotation = "In 5.7, MySQL implicitly sorts 'GROUP BY col1, …' in the following order 'ORDER BY col1,…' by default, resulting in unnecessary sorting and extra overhead. In 8.0, this will not happen. If no sorting is required, it is recommended to explicitly add 'ORDER BY NULL'"
DMLHintGroupByRequiresConditionsDesc = "It is recommended to add ORDER BY conditions to the GROUP BY statement"
DMLHintGroupByRequiresConditionsMessage = "It is recommended to add ORDER BY conditions to the GROUP BY statement"
DMLHintInNullOnlyFalseAnnotation = "The query condition is always false, which will result in no matching results in the query"
DMLHintInNullOnlyFalseDesc = "Avoid using IN (NULL) or NOT IN (NULL)"
DMLHintInNullOnlyFalseMessage = "Avoid using IN (NULL)/NOT IN (NULL), this usage is always false and will cause the condition to be invalid"
DMLHintLimitMustBeCombinedWithOrderByAnnotation = "LIMIT without ORDER BY will result in non-deterministic results, which may not meet business requirements, depending on the execution plan"
DMLHintLimitMustBeCombinedWithOrderByDesc = "It is recommended to use ORDER BY for LIMIT queries"
DMLHintLimitMustBeCombinedWithOrderByMessage = "It is recommended to use ORDER BY for LIMIT queries"
DMLHintSumFuncTipsAnnotation = "When the values of a column are all NULL, the return value of COUNT(COL) is 0, but the return value of SUM(COL) is NULL, so you need to pay attention to the NPE problem (referring to data returning NULL) when using SUM(); If the business needs to avoid the NPE problem, it is recommended to enable this rule"
DMLHintSumFuncTipsDesc = "Avoid using SUM(COL)"
DMLHintSumFuncTipsMessage = "Avoid using SUM(COL), this usage has the risk of returning NULL values and causing program null pointers"
DMLHintTruncateTipsAnnotation = "TRUNCATE is DLL, data cannot be rolled back, use TRUNCATE with caution without backup"
DMLHintTruncateTipsDesc = "Do not use TRUNCATE operation"
DMLHintTruncateTipsMessage = "Do not use TRUNCATE operation"
DMLHintUseTruncateInsteadOfDeleteAnnotation = "TRUNCATE TABLE is faster than DELETE and uses less system and transaction log resources. At the same time, the space occupied by the table after TRUNCATE will be released, while after DELETE, you need to manually execute OPTIMIZE to release the table space"
DMLHintUseTruncateInsteadOfDeleteDesc = "It is recommended to use TRUNCATE instead of DELETE when deleting the entire table"
DMLHintUseTruncateInsteadOfDeleteMessage = "It is recommended to use TRUNCATE instead of DELETE when deleting the entire table"
DMLMustMatchLeftMostPrefixAnnotation = "Using IN, OR, etc. non-equal queries on the leftmost field of a combined index will cause the combined index to become invalid"
DMLMustMatchLeftMostPrefixDesc = "Prohibit using IN, OR, etc. non-equal queries on the leftmost field of a combined index"
DMLMustMatchLeftMostPrefixMessage = "Using IN, OR, etc. non-equal queries on the leftmost field of a combined index will cause the combined index to become invalid"
DMLMustUseLeftMostPrefixAnnotation = "When using a combined index, not including the first field will cause the combined index to become invalid"
DMLMustUseLeftMostPrefixDesc = "When using a combined index, you must use the first field of the combined index"
DMLMustUseLeftMostPrefixMessage = "When using a combined index, you must use the first field of the combined index"
DMLNotAllowInsertAutoincrementAnnotation = "Manual assignment may cause data gaps and primary key conflicts"
DMLNotAllowInsertAutoincrementDesc = "Prohibit manually setting auto-increment field values"
DMLNotAllowInsertAutoincrementMessage = "Prohibit manually setting auto-increment field values"
DMLNotRecommendFuncInWhereAnnotation = "Functions or operators will cause the query to be unable to use the index in the table, and this query will perform a full table scan, with poor performance"
DMLNotRecommendFuncInWhereDesc = "Functions or other operators should be avoided in the WHERE condition"
DMLNotRecommendFuncInWhereMessage = "Functions or other operators should be avoided in the WHERE condition"
DMLNotRecommendGroupByConstantAnnotation = "GROUP BY 1 means grouping by the first column. Using numbers instead of expressions or column names in the GROUP BY clause will cause problems with query logic when the query column order changes"
DMLNotRecommendGroupByConstantDesc = "Do not perform GROUP BY on constants"
DMLNotRecommendGroupByConstantMessage = "Do not perform GROUP BY on constants"
DMLNotRecommendGroupByExpressionAnnotation = "When the ORDER BY condition is an expression or function, it will use a temporary table. If WHERE is not specified or the result set returned by the WHERE condition is large, the performance will be very poor"
DMLNotRecommendGroupByExpressionDesc = "Do not use expressions as ORDER BY conditions"
DMLNotRecommendGroupByExpressionMessage = "Do not use expressions as ORDER BY conditions"
DMLNotRecommendHavingAnnotation = "For indexed fields, when placed in the HAVING clause, they will not use the index. It is recommended to rewrite the HAVING clause as the query condition in WHERE, which can use the index during query processing and improve the execution efficiency of SQL"
DMLNotRecommendHavingDesc = "Do not use the HAVING clause"
DMLNotRecommendHavingMessage = "Do not use the HAVING clause"
DMLNotRecommendInAnnotation = "When the number of IN values is too large, it may cause the query to perform a full table scan, resulting in a significant drop in MySQL performance."
DMLNotRecommendInDesc = "Do not recommend using IN"
DMLNotRecommendInMessage = "Do not recommend using IN"
DMLNotRecommendNotWildcardLikeAnnotation = "LIKE queries that do not contain wildcards are logically equivalent to equality queries. It is recommended to use equality queries instead."
DMLNotRecommendNotWildcardLikeDesc = "Do not recommend using LIKE queries without wildcards"
DMLNotRecommendNotWildcardLikeMessage = "Do not recommend using LIKE queries without wildcards"
DMLNotRecommendOrderByRandAnnotation = "ORDER BY RAND() uses a temporary table and then sorts it. In the case of large amounts of data, this will increase server load and query time."
DMLNotRecommendOrderByRandDesc = "Do not recommend using ORDER BY RAND()"
DMLNotRecommendOrderByRandMessage = "Do not recommend using ORDER BY RAND()"
DMLNotRecommendSubqueryAnnotation = "In some cases, subqueries cannot use indexes. Also, for subqueries that return a large result set, a large number of temporary tables will be generated, consuming too much CPU and IO resources, resulting in many slow queries."
DMLNotRecommendSubqueryDesc = "Do not recommend using subqueries"
DMLNotRecommendSubqueryMessage = "Do not recommend using subqueries"
DMLNotRecommendSysdateAnnotation = "When the SYSDATE() function is used in a STATEMENT-based master-slave environment, it may cause data inconsistency, because there is a time difference between when the statement is executed on the master and when the log is transferred to the slave. When it is executed on the slave, it will become a different time value. It is recommended to adopt a ROW-based replication environment."
DMLNotRecommendSysdateDesc = "Do not recommend using the SYSDATE() function"
DMLNotRecommendSysdateMessage = "Do not recommend using the SYSDATE() function"
DMLNotRecommendUpdatePKAnnotation = "The order of the primary key index data columns is the physical storage order of the table records. Frequent updates to the primary key will cause the order of the entire table records to be adjusted, which will consume a considerable amount of resources."
DMLNotRecommendUpdatePKDesc = "Do not recommend UPDATE primary key"
DMLNotRecommendUpdatePKMessage = "Do not recommend UPDATE primary key"
DMLSQLExplainLowestLevelAnnotation = "Verify the type field in the SQL execution plan to ensure that it meets the required level to guarantee query performance."
DMLSQLExplainLowestLevelDesc = "The type field in the SQL execution plan should meet the specified level"
DMLSQLExplainLowestLevelMessage = "It is recommended to modify the SQL to ensure that the type field in the execution plan meets any of the levels specified: %v"
DMLSQLExplainLowestLevelParams1 = "Query plan type level, separated by commas"
DMLWhereExistNullAnnotation = "Using IS NULL or IS NOT NULL may cause the query to abandon the use of indexes and perform a full table scan."
DMLWhereExistNullDesc = "Do not recommend using NULL value judgments for conditional fields"
DMLWhereExistNullMessage = "Do not recommend using NULL value judgments for conditional fields"
DuplicateColumnsMessage = "Column name %s is duplicated"
DuplicateIndexedColumnMessage = "Index %s column %s is duplicated"
DuplicateIndexesMessage = "Index name %s is duplicated"
DuplicatePrimaryKeyedColumnMessage = "Primary key column %s is duplicated"
ExtremalIndexAdviceFormat = "Index suggestion | SQL used the extreme value function, you can use the ordered nature of the index to quickly find the extreme value. It is recommended to add a single-column index to table %s. Refer to the column: %s"
FunctionIndexAdviceFormatAll = "Index suggestion | SQL used the function as the query condition. In MySQL 5.7 and later versions, you can create an index on the virtual column. In MySQL 8.0.13 and later versions, you can create a function index. It is recommended to add an appropriate index to the table %s based on the MySQL version. Refer to the column: %s"
FunctionIndexAdviceFormatV57 = "Index suggestion | SQL used the function as the query condition. In MySQL 5.7 and later versions, you can create an index on the virtual column. It is recommended to add a virtual column index to table %s. Refer to the column: %s"
FunctionIndexAdviceFormatV80 = "Index suggestion | SQL used the function as the query condition. In MySQL 8.0.13 and later versions, you can create a function index. It is recommended to add a function index to table %s. Refer to the column: %s"
GhostDryRunError = "The table space size exceeds %vMB. gh-ost will be used to go online, but the dry-run throws the following error: %v"
GhostDryRunNotice = "The table space size exceeds %vMB. gh-ost will be used to go online"
IndexExistMessage = "Index %s already exists"
IndexNotExistMessage = "Index %s does not exist"
JoinIndexAdviceFormat = "Index suggestion | The field %s in the SQL is the join field on the driven table %s. It is recommended to add a single-column index to the table %s. Refer to the column: %s"
KeyedColumnNotExistMessage = "Index column %s does not exist"
MultiPrimaryKeyMessage = "Only one primary key can be set"
NotSupportExceedMaxRowsRollback = "The expected number of rows affected exceeds the configured maximum value. Rollback statements are not generated."
NotSupportHasVariableRollback = "Rollback DML statements that contain variables is not supported"
NotSupportInsertWithoutPrimaryKeyRollback = "Rollback INSERT statements that do not specify a primary key is not supported"
NotSupportMultiTableStatementRollback = "Rollback of DML statements for multiple tables is not yet supported"
NotSupportNoPrimaryKeyTableRollback = "Rollback of DML statements for tables without primary keys is not supported"
NotSupportOnDuplicatStatementRollback = "Rollback ON DUPLICATE statements is not yet supported"
NotSupportParamMarkerStatementRollback = "Rollback of statements that contain fingerprints is not supported"
NotSupportStatementRollback = "Rollback of this type of statement is not yet supported"
NotSupportSubQueryStatementRollback = "Rollback of statements with subqueries is not yet supported"
OptDMLCheckLimitOffsetNumAnnotation = "LIMIT and OFFSET clauses can be used to control the number of query results and specify the starting row from which to return data, respectively. However, when the OFFSET value is large, query efficiency will decrease because the system must scan more data to find the starting row. This can lead to performance issues and resource consumption in large datasets."
OptDMLCheckLimitOffsetNumDesc = "OFFSET value exceeds threshold"
OptDMLCheckMathComputationOrFuncOnIndexAnnotation = "Math operations on indexed columns will invalidate the index, which can easily lead to full table scans and serious performance issues. Therefore, try to convert the operations on indexed columns to the constant side."
OptDMLCheckMathComputationOrFuncOnIndexDesc = "Index invalidation due to operations on indexed columns"
OptDMLCheckNotEqualSymbolAnnotation = "'!=' is a non-standard operator, '<>' is the standard not equal operator in SQL"
OptDMLCheckNotEqualSymbolDesc = "Use '<>' instead of '!='"
OptDMLCheckWhereExistImplicitConversionAnnotation = "Using data types inconsistent with the filtering field in the WHERE condition will trigger implicit data type conversion, resulting in a risk of the query not being able to hit the index. Under high concurrency and large data volumes, not using the index will significantly degrade the query performance of the database"
OptDMLCheckWhereExistImplicitConversionDesc = "Index invalidation due to implicit type conversion"
OptDMLCheckWhereExistScalarSubqueryAnnotation = "For using a COUNT scalar subquery to judge existence, it can be rewritten as an EXISTS subquery, thus avoiding a cluster operation."
OptDMLCheckWhereExistScalarSubqueryDesc = "Rewrite COUNT scalar subquery"
OptDMLHintGroupByRequiresConditionsAnnotation = "In earlier versions of MySQL, GROUP BY defaults to sorting, which can be canceled by adding ORDER BY NULL to improve query efficiency."
OptDMLHintGroupByRequiresConditionsDesc = "Add ORDER BY condition explicitly for GROUP BY (< MYSQL 5.7)"
OptDMLHintInNullOnlyFalseAnnotation = "The query condition is always false, which will result in no matches in the query"
OptDMLHintInNullOnlyFalseDesc = "IN nullable subquery may result in unexpected result set"
OptDMLHintUseTruncateInsteadOfDeleteAnnotation = "TRUNCATE TABLE is faster than DELETE, uses less system and transaction log resources, and the space occupied by the table after TRUNCATE is released, while after DELETE, OPTIMIZE needs to be executed manually to release table space"
OptDMLHintUseTruncateInsteadOfDeleteDesc = "Unconditional DELETE should be rewritten as Truncate"
OptDMLNotRecommendHavingAnnotation = "Logically, the HAVING condition is executed after grouping, while the conditions on the WHERE clause can be executed during table access (index access) or after table access but before grouping. These two conditions are less expensive than executing after grouping."
OptDMLNotRecommendHavingDesc = "Push down HAVING condition"
OptDMLNotRecommendInAnnotation = "An IN subquery refers to a subquery that conforms to the following form. An IN subquery can be rewritten as an equivalent correlated EXISTS subquery or an inner join, thus generating a new filtering condition."
OptDMLNotRecommendInDesc = "IN subquery optimization"
OptDMLNotRecommendNotWildcardLikeAnnotation = "LIKE queries without wildcards are logically the same as equality queries. It is recommended to use equality queries instead. Moreover, LIKE queries without wildcards are usually caused by developer errors and may not meet their expected business logic implementation"
OptDMLNotRecommendNotWildcardLikeDesc = "Avoid using LIKE queries without wildcards"
OptDMLRuleAllSubqueryRewriteAnnotation = "If there is a NULL in the result of the ALL subquery, this SQL will always return empty. The correct way should be to add a non-null constraint in the subquery or use max/min notation."
OptDMLRuleAllSubqueryRewriteDesc = "Rewrite ALL qualified subquery"
OptDMLRuleDiffOrderingSpecTypeWarningAnnotation = "All expressions in the ORDER BY clause need to be sorted in the same ASC or DESC direction in order to utilize the index to avoid sorting; if the ORDER BY statement uses different directions of sorting for multiple different conditions, the index cannot be used"
OptDMLRuleDiffOrderingSpecTypeWarningDesc = "Index invalidation due to different sorting field directions"
OptDMLRuleDistinctEliminationRewriteAnnotation = "For subqueries that only perform existence testing, the DISTINCT can usually be removed if the subquery contains DISTINCT to avoid a deduplication operation."
OptDMLRuleDistinctEliminationRewriteDesc = "DISTINCT elimination in subquery"
OptDMLRuleExists2JoinRewriteAnnotation = "EXISTS subqueries can be converted to JOIN to optimize queries and improve database processing efficiency and performance under appropriate conditions."
OptDMLRuleExists2JoinRewriteDesc = "Convert EXISTS query to table join"
OptDMLRuleFilterPredicatePushDownRewriteAnnotation = "Filter condition pushdown (FPPD) is a technique to reduce data processing volume and improve SQL execution efficiency by applying filter conditions earlier to inner query blocks."
OptDMLRuleFilterPredicatePushDownRewriteDesc = "Push down filter predicates"
OptDMLRuleGroupingFromDiffTablesRewriteAnnotation = "If the grouping fields come from different tables, the database optimizer will not be able to utilize the order of the index to avoid a sort. If there are equality conditions, these fields can be replaced by fields from the same table to utilize the index to optimize sorting and improve query efficiency."
OptDMLRuleGroupingFromDiffTablesRewriteDesc = "GROUPBY fields from different tables"
OptDMLRuleJoinEliminationRewriteAnnotation = "Simplify queries and improve performance by removing unnecessary table joins without affecting the results, applicable to scenarios where the query only involves the primary key columns of the main table."
OptDMLRuleJoinEliminationRewriteDesc = "Table join elimination"
OptDMLRuleLimitClausePushDownRewriteAnnotation = "Limit clause pushdown optimization improves query performance by pushing down the Limit clause as far as possible to filter out some data in advance, reducing the size of the intermediate result set and reducing the amount of data that needs to be processed in subsequent calculations."
OptDMLRuleLimitClausePushDownRewriteDesc = "Push down LIMIT to UNION branch"
OptDMLRuleLimitClausePushDownRewriteParams1 = "OFFSET maximum threshold"
OptDMLRuleMaxMinAggRewriteAnnotation = "For subqueries using MAX/MIN, the index order can be utilized to avoid a cluster operation by rewriting it."
OptDMLRuleMaxMinAggRewriteDesc = "Rewrite MAX/MIN subquery"
OptDMLRuleMoveOrder2LeadingRewriteAnnotation = "If a query contains both sorting fields and grouping fields from the same table, but the field order is different, the grouping field order can be adjusted to be consistent with the sorting field order, so that the database can avoid a sorting operation."
OptDMLRuleMoveOrder2LeadingRewriteDesc = "ORDER clause reorder optimization"
OptDMLRuleNPERewriteAnnotation = "The NPE (Null Pointer Exception) problem of SQL refers to the fact that in SQL queries, when aggregate columns are all NULL, aggregate functions such as SUM and AVG will return NULL, which may lead to null pointer exceptions in subsequent programs."
OptDMLRuleNPERewriteDesc = "NPE rewrite"
OptDMLRuleOrCond4SelectRewriteAnnotation = "If the query statement uses OR conditions, the database optimizer may not be able to use the index to complete the query. The query statement can be rewritten as a UNION or UNION ALL query to use the index to improve query performance."
OptDMLRuleOrCond4SelectRewriteDesc = "Rewrite SELECT with OR condition"
OptDMLRuleOrCond4UpDeleteRewriteAnnotation = "If there are UPDATE or DELETE statements using OR conditions, the database optimizer may not be able to use the index to complete the operation. It can be rewritten as multiple DELETE statements to use the index to improve query performance."
OptDMLRuleOrCond4UpDeleteRewriteDesc = "Rewrite UPDELETE with OR condition"
OptDMLRuleOrderEliminationInSubqueryRewriteAnnotation = "If the subquery does not have a LIMIT clause, then the sorting operation of the subquery is meaningless and can be removed without affecting the final result."
OptDMLRuleOrderEliminationInSubqueryRewriteDesc = "Elimination of sorting without LIMIT in IN subquery"
OptDMLRuleOrderingFromDiffTablesRewriteAnnotation = "If the sort fields are from different tables and there are equivalent conditions, you can replace these fields with fields from the same table, using index to avoid extra sorting and improve efficiency."
OptDMLRuleOrderingFromDiffTablesRewriteDesc = "Avoid ORDERBY fields from different tables"
OptDMLRuleOuter2InnerConversionRewriteAnnotation = "Outer join optimization refers to the conversion of outer joins that meet certain conditions (the outer table has NULL rejection conditions) to inner joins, which allows the database optimizer to choose a better execution plan and improve SQL query performance."
OptDMLRuleOuter2InnerConversionRewriteDesc = "Outer join optimization"
OptDMLRuleProjectionPushdownRewriteAnnotation = "Projection pushdown refers to deleting meaningless columns (not used in the outer query) in the DT subquery to reduce the cost of IO and network, and at the same time increase the probability that the optimizer will use the optimization option of not needing to return the table when planning table access."
OptDMLRuleProjectionPushdownRewriteDesc = "Projection pushdown"
OptDMLRuleQualifierSubQueryRewriteAnnotation = "Subqueries qualified by ANY/SOME/ALL are used to compare value relationships, but they are inefficient because they process comparisons row by row. Query rewriting can improve the execution efficiency of such subqueries."
OptDMLRuleQualifierSubQueryRewriteDesc = "Qualifier subquery rewriting optimization"
OptDMLRuleQueryFoldingRewriteAnnotation = "Query folding refers to expanding views, CTEs or DT subqueries and merging them with the queries that reference them, in order to reduce the serialization of intermediate result sets or trigger better optimization techniques for table join planning."
OptDMLRuleQueryFoldingRewriteDesc = "Query folding"
OptDMLRuleSATTCRewriteAnnotation = "SAT-TC rewriting optimization analyzes and processes the logical relationship of query conditions to discover contradictions, simplify conditions, or infer new conditions, which helps the database optimizer develop more efficient execution plans and improve SQL performance."
OptDMLRuleSATTCRewriteDesc = "SATTC rewriting optimization"
OptDMLWhereExistNullAnnotation = "= null cannot determine if an expression is empty, = null is always judged to be false.  Use is null to determine if an expression is empty."
OptDMLWhereExistNullDesc = "Do not use =NULL to judge null value"
OptOracle500Annotation = "The SQL NPE (Null Pointer Exception) problem refers to the fact that when all aggregated columns are NULL in SQL queries, aggregate functions such as SUM and AVG return NULL, which may cause null pointer exceptions in subsequent programs."
OptOracle500Desc = "NPE rewriting"
OptOracle501Annotation = "If the result of the ALL subquery contains NULL, this SQL will always return empty. The correct way is to add a non-null restriction in the subquery or use the max/min method."
OptOracle501Desc = "ALL qualified subquery rewriting"
OptOracle502Annotation = "For using a COUNT scalar subquery to judge whether it exists, it can be rewritten as an EXISTS subquery to avoid an aggregation operation."
OptOracle502Desc = "COUNT scalar subquery rewriting"
OptOracle503Annotation = "TRUNCATE TABLE is faster than DELETE, uses less system and transaction log resources, and the space occupied by the table after TRUNCATE will be released, while DELETE needs to manually execute OPTIMIZE to release the table space"
OptOracle503Desc = "Unconditional DELETE should be rewritten as Truncate"
OptOracle504Annotation = "Using data types that are inconsistent with the filter field in the WHERE condition will cause implicit data type conversion, which may lead to the risk that the query cannot hit the index. In the case of high concurrency and large data volumes, not using the index will severely degrade the query performance of the database."
OptOracle504Desc = "Implicit type conversion causes index invalidation"
OptOracle505Annotation = "All expressions in the ORDER BY clause need to be sorted in the same ASC or DESC direction to use the index to avoid sorting; if the ORDER BY statement uses different directions for sorting on multiple different conditions, the index cannot be used."
OptOracle505Desc = "Index invalidation due to different sorting field directions"
OptOracle506Annotation = "Operations on indexed columns will cause index invalidation, which can easily cause full table scans, resulting in serious performance problems. So it is necessary to convert operations on indexed columns to the constant side as much as possible."
OptOracle506Desc = "Index invalidation due to operations on indexed columns"
OptOracle507Annotation = "Logically, the HAVING condition is executed after grouping, while the conditions on the WHERE clause can be executed either during table access (index access) or after table access and before grouping. Both of these conditions are less expensive than executing after grouping."
OptOracle507Desc = "HAVING condition pushdown"
OptOracle508Annotation = "= null cannot determine if an expression is empty, = null is always judged to be false.  Use is null to determine if an expression is empty."
OptOracle508Desc = "Do not use =NULL to judge null value"
OptOracle509Annotation = "IN subqueries refer to subqueries that meet the following form. IN subqueries can be rewritten as equivalent related EXISTS subqueries or inner joins, which can generate a new filter condition."
OptOracle509Desc = "IN subquery optimization"
OptOracle510Annotation = "The query condition is never true, which will result in no matching results for the query."
OptOracle510Desc = "IN nullable subquery may cause the result set to be inconsistent with expectations"
OptOracle511Annotation = "LIKE queries without wildcards are logically the same as equality queries, it is recommended to use equality queries instead. Also, LIKE queries without wildcards are usually caused by developer errors and may not meet their expected business logic implementation."
OptOracle511Desc = "Avoid using LIKE queries without wildcards"
OptOracle512Annotation = "'!=' is a non-standard operator, '<>' is the standard not equal operator in SQL."
OptOracle512Desc = "It is recommended to use '<>' instead of '!='"
OptOracle513Annotation = "For subqueries that only perform existence tests, DISTINCT can usually be removed if the subquery contains DISTINCT, to avoid a deduplication operation."
OptOracle513Desc = "Elimination of DISTINCT in subqueries"
OptOracle514Annotation = "EXISTS subqueries can be converted to JOINs in appropriate cases to optimize queries and improve database processing efficiency and performance."
OptOracle514Desc = "Convert EXISTS queries to table joins"
OptOracle515Annotation = "Filter predicate pushdown (FPPD) is a technique that improves SQL execution efficiency by applying filter conditions early to inner query blocks to reduce data processing."
OptOracle515Desc = "Filter predicate pushdown"
OptOracle516Annotation = "If the grouping fields are from different tables, the database optimizer will not be able to use the order of the index to avoid a sorting operation. If there are equivalent conditions, you can replace these fields with fields from the same table to use the index to optimize sorting and improve query efficiency."
OptOracle516Desc = "GROUPBY fields from different tables"
OptOracle517Annotation = "Simplify queries and improve performance by removing unnecessary table joins without affecting the results.  This is suitable for scenarios where the query only involves the primary key column of the main table."
OptOracle517Desc = "Table join elimination"
OptOracle518Annotation = "For subqueries using MAX/MIN, rewrite to utilize index order to avoid aggregation operation."
OptOracle518Desc = "MAX/MIN subquery rewrite"
OptOracle519Annotation = "If a query contains both sorting fields and grouping fields from the same table, but with different orders, adjust the grouping field order to be consistent with the sorting field order, avoiding a sort operation."
OptOracle519Desc = "ORDER clause reorder optimization"
OptOracle520Annotation = "If using OR conditions in a query statement, the database optimizer may not be able to use an index to complete the query. Rewrite the query statement as UNION or UNION ALL query to use an index and improve query performance."
OptOracle520Desc = "Rewrite SELECT with OR conditions"
OptOracle521Annotation = "If using OR conditions in UPDATE or DELETE statements, the database optimizer may not be able to use an index to complete the operation. Rewrite it as multiple DELETE statements to use an index and improve query performance."
OptOracle521Desc = "Rewrite UPDELETE with OR conditions"
OptOracle522Annotation = "When sorting fields are from different tables, if there are equality conditions, replace these fields with fields from the same table, using an index to avoid extra sorting and improve efficiency."
OptOracle522Desc = "Avoid ORDERBY fields from different tables"
OptOracle523Annotation = "Outer join optimization refers to the fact that outer joins that meet certain conditions (outer tables have NULL rejection conditions) can be converted to inner joins, allowing the database optimizer to choose a better execution plan and improve the performance of SQL queries."
OptOracle523Desc = "Outer join optimization"
OptOracle524Annotation = "Projection pushdown refers to removing meaningless columns (not used in outer queries) in DT subqueries to reduce IO and network costs, while increasing the likelihood that the optimizer will choose optimization options that do not require table scans when planning table access."
OptOracle524Desc = "Projection Pushdown (PROJECTION PUSHDOWN)"
OptOracle525Annotation = "ANY/SOME/ALL-modified subqueries are used to compare value relationships, but they are inefficient because they process comparisons row by row. Rewriting queries can improve the execution efficiency of such subqueries."
OptOracle525Desc = "Modified subquery rewrite optimization"
OptOracle526Annotation = "Query folding refers to expanding views, CTEs, or DT subqueries and merging them with the queries that reference them to reduce serialization of intermediate result sets or trigger better optimization techniques for table join planning."
OptOracle526Desc = "Query folding (QUERY FOLDING)"
OptOracle527Annotation = "SAT-TC rewrite optimization analyzes and processes the logical relationships of query conditions to discover contradictions, simplify conditions, or infer new conditions, thereby helping the database optimizer develop a more efficient execution plan and improve SQL performance."
OptOracle527Desc = "SATTC rewrite optimization"
PTOSCAvoidNoDefaultValueOnNotNullColumn = "[osc]Non-empty fields must have default values, otherwise pt-online-schema-change will fail."
PTOSCAvoidRenameTable = "[osc]pt-online-schema-change does not support renaming tables using rename table."
PTOSCAvoidUniqueIndex = "[osc]Adding unique keys using pt-online-schema-change may lead to data loss. insert ignore was used when migrating data to the new table."
PTOSCNoUniqueIndexOrPrimaryKey = "[osc]Must contain at least one primary key or unique key index to use pt-online-schema-change."
ParseDDLError = "Failed to parse the table creation statement. Some online audit rules may be invalid. Please confirm manually."
PrefixIndexAdviceFormat = "Index suggestion | SQL uses prefix fuzzy matching. When data volume is large, reverse function index can be built."
PrimaryKeyExistMessage = "Primary key already exists, cannot add it again."
PrimaryKeyNotExistMessage = "There is no primary key currently, cannot execute deletion."
RuleTypeDDLConvention = "DDL convention"
RuleTypeDMLConvention = "DML convention"
RuleTypeGlobalConfig = "Global configuration"
RuleTypeIndexInvalidation = "Index invalidation"
RuleTypeIndexOptimization = "Index optimization"
RuleTypeIndexingConvention = "Index convention"
RuleTypeNamingConvention = "Naming convention"
RuleTypeUsageSuggestion = "Usage suggestion"
SchemaExistMessage = "Schema %s already exists."
SchemaNotExistMessage = "Schema %s does not exist."
TableExistMessage = "Table %s already exists."
TableNotExistMessage = "Table %s does not exist."
ThreeStarIndexAdviceFormat = "Index suggestion | According to the three-star index design specification, it is recommended to add %s index to table %s: [%s]"
UnsupportedSyntaxError = "Syntax error or parser does not support it. Please manually confirm the correctness of SQL."