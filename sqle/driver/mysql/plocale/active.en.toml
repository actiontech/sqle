AdvisorIndexTypeComposite = "Composite"
AdvisorIndexTypeSingle = "Single column"
AllCheckPrepareStatementPlaceholdersAnnotation = "Because overuse of bind variables will increase the complexity of the query, thus reducing the query performance. Overuse of bind variables will also increase maintenance costs. Default threshold: 100"
AllCheckPrepareStatementPlaceholdersDesc = "The number of bound variables should not exceed the threshold"
AllCheckPrepareStatementPlaceholdersMessage = "The number of bind variables is %v, it is not recommended to exceed the set threshold %v"
AllCheckPrepareStatementPlaceholdersParams1 = "Maximum number of bind variables"
AnalysisDescCardinality = "Cardinality"
AnalysisDescCharacterSetName = "Character set"
AnalysisDescColumnComment = "Column comment"
AnalysisDescColumnDefault = "Default value"
AnalysisDescColumnKey = "Column index"
AnalysisDescColumnName = "Column name"
AnalysisDescColumnType = "Column type"
AnalysisDescComment = "Comment"
AnalysisDescExtra = "Extra info"
AnalysisDescIndexType = "Index type"
AnalysisDescIsNullable = "Nullable"
AnalysisDescKeyName = "Index name"
AnalysisDescSeqInIndex = "Column sequence"
AnalysisDescUnique = "Unique"
AnonymousMark = "(anonymous)"
AuditResultMsgExcludedSQL = "Excluded SQLs"
AuditResultMsgWhiteList = "White list"
CheckInvalidError = "Pre-check failed"
CheckInvalidErrorFormat = "Pre-check failed: %v"
ColumnExistMessage = "Column %s already exists"
ColumnIsAmbiguousMessage = "Column %s is ambiguous"
ColumnNotExistMessage = "Column %s does not exist"
ColumnsValuesNotMatchMessage = "The number of specified values does not match the number of columns"
ConfigDDLGhostMinSizeAnnotation = "After enabling this rule, the gh-ost tool will be used automatically for online table modification for large tables; direct DDL changes to large tables may lead to long-term table locking issues, affecting business sustainability. The specific threshold for defining large tables can be adjusted according to business needs. Default value: 1024"
ConfigDDLGhostMinSizeDesc = "When modifying tables, use gh-ost online when table space exceeds the specified size (MB)"
ConfigDDLGhostMinSizeParams1 = "Table space size (MB)"
ConfigDDLOSCMinSizeAnnotation = "After enabling this rule, pt-osc rewrite suggestions will be given for DDL statements of large tables 【need to refer to the command for manual execution, automatic execution will be supported in the future】; direct DDL changes to large tables may lead to long-term table locking issues, affecting business sustainability. The specific threshold for defining large tables can be adjusted according to business needs. Default value: 1024"
ConfigDDLOSCMinSizeDesc = "When modifying tables, output osc rewrite suggestions when the table space exceeds the specified size (MB) for audit"
ConfigDDLOSCMinSizeParams1 = "Table space size (MB)"
ConfigDMLExplainPreCheckEnableAnnotation = "Check if the DML to be launched can be executed correctly in the form of EXPLAIN, and find errors in the statement in advance to improve the success rate of launching"
ConfigDMLExplainPreCheckEnableDesc = "Use EXPLAIN to enhance pre-check capability"
ConfigDMLRollbackMaxRowsAnnotation = "Large transaction rollback, easy to affect database performance, causing business fluctuations; the specific rule threshold can be adjusted according to business needs. Default value: 1000"
ConfigDMLRollbackMaxRowsDesc = "Do not roll back if the expected number of affected rows in the DML statement exceeds the specified value"
ConfigDMLRollbackMaxRowsParams1 = "Maximum number of affected rows"
ConfigOptimizeIndexEnabledAnnotation = "Enable index optimization suggestions through this rule, providing two parameters to configure the behavior of index optimization suggestions. 1. Minimum column distinguishability threshold (percentage): configure the distinguishability of columns in the current table less than how much, not as the column of the index; 2. Maximum number of columns in the combined index: limit the maximum number of columns given by the combined index to prevent the recommended combined index from not conforming to other SQL standards"
ConfigOptimizeIndexEnabledDesc = "Index creation suggestion"
ConfigOptimizeIndexEnabledParams1 = "Minimum column distinguishability threshold (percentage)"
ConfigOptimizeIndexEnabledParams2 = "Maximum number of columns in the combined index"
ConfigSQLIsExecutedAnnotation = "Enable this rule to be compatible with post-audit scenarios. DDL and DML statements collected after the event will no longer be checked for launch. For example, the library table metadata scan task can enable this rule"
ConfigSQLIsExecutedDesc = "Disable online audit mode"
DDLAvoidEventAnnotation = "Using event will increase the maintenance difficulty and dependency of the database, and will also cause security problems."
DDLAvoidEventDesc = "Prohibit using event"
DDLAvoidEventMessage = "Prohibit using event"
DDLAvoidFullTextAnnotation = "Using fulltext index will increase storage overhead and have some impact on write operation performance."
DDLAvoidFullTextDesc = "Prohibit using fulltext index"
DDLAvoidFullTextMessage = "Prohibit using fulltext index"
DDLAvoidGeometryAnnotation = "Using spatial fields and spatial indexes will increase storage requirements and have a certain impact on database performance"
DDLAvoidGeometryDesc = "Prohibit the use of spatial fields and spatial indexes"
DDLAvoidGeometryMessage = "Prohibit the use of spatial fields and spatial indexes"
DDLAvoidTextAnnotation = "Splitting text type fields from the original table's primary key into another table can improve database performance and query speed, reducing unnecessary i/o operations."
DDLAvoidTextDesc = "It is recommended to split text type fields from the original table and store them in a separate table with the primary key of the original table"
DDLAvoidTextMessage = "Field: %v is of text type, it is recommended to split it from the original table and store it in a separate table with the primary key of the original table"
DDLCheckAllIndexNotNullConstraintAnnotation = "All index fields are not constrained to be not null, please confirm the rationality of the index planning of the table."
DDLCheckAllIndexNotNullConstraintDesc = "It is recommended to add a not null constraint to at least one index"
DDLCheckAllIndexNotNullConstraintMessage = "It is recommended to add a not null constraint to at least one index"
DDLCheckAlterTableNeedMergeAnnotation = "Avoid the consumption and impact on online business caused by multiple table rebuilds"
DDLCheckAlterTableNeedMergeDesc = "There are multiple modification statements for the same table, it is recommended to merge them into one alter statement"
DDLCheckAlterTableNeedMergeMessage = "There are already modification statements for this table, it is recommended to merge them into one alter statement"
DDLCheckAutoIncrementAnnotation = "If auto_increment is set to 0 when creating a table, auto-increment will start from 1, which can avoid data holes. for example, when exporting table structure ddl, the auto_increment in the table structure is usually the current auto-increment value. if auto_increment is not set to 0 when creating a table, creating a table through this DDL will result in the auto-increment value starting from a meaningless number."
DDLCheckAutoIncrementDesc = "The initial auto_increment value of the table is recommended to be 0"
DDLCheckAutoIncrementFieldNumAnnotation = "Mysql innodb, myisam engine does not allow multiple auto-increment fields, setting multiple auto-increment fields will lead to deployment failure."
DDLCheckAutoIncrementFieldNumDesc = "When creating a table, only one auto-increment field can be set"
DDLCheckAutoIncrementFieldNumMessage = "When creating a table, only one auto-increment field can be set"
DDLCheckAutoIncrementMessage = "The initial auto_increment value of the table is recommended to be 0"
DDLCheckBigintInsteadOfDecimalAnnotation = "Because the cpu does not support direct operations on decimal, mysql itself implements high-precision calculations for decimal, but the calculation cost is high, and the space occupied is also more when storing the same range of values; using bigint instead of decimal, you can multiply by the corresponding multiplier according to the number of decimal places, so as to achieve precise floating-point storage calculation, avoiding the high calculation cost of decimal"
DDLCheckBigintInsteadOfDecimalDesc = "It is recommended to use bigint type instead of decimal"
DDLCheckBigintInsteadOfDecimalMessage = "It is recommended to use bigint type instead of decimal for column %s"
DDLCheckCharLengthAnnotation = "Using too long or too many varchar, char fields may increase the complexity of business logic; if the average length of the field is too large, it will occupy more storage space."
DDLCheckCharLengthDesc = "Prohibit the total character length of char, varchar type fields from exceeding the threshold"
DDLCheckCharLengthMessage = "Prohibit the total character length of char, varchar type fields from exceeding the threshold %v"
DDLCheckCharLengthParams1 = "Character length"
DDLCheckColumnBlobDefaultIsNotNullAnnotation = "In strict sql_mode, blob and text types cannot set default values, if data is inserted without specifying a value, the field will be set to null"
DDLCheckColumnBlobDefaultIsNotNullDesc = "The default value of blob and text type fields can only be null"
DDLCheckColumnBlobDefaultIsNotNullMessage = "The default value of blob and text type fields can only be null"
DDLCheckColumnBlobNoticeAnnotation = "Blob or text type consumes a lot of network and io bandwidth, and DML operations on this table will become very slow"
DDLCheckColumnBlobNoticeDesc = "It is not recommended to use blob or text type"
DDLCheckColumnBlobNoticeMessage = "It is not recommended to use blob or text type"
DDLCheckColumnBlobWithNotNullAnnotation = "Blob and text type fields cannot specify default values, if data is inserted without specifying a value, the field defaults to null. if a not null constraint is added, inserting data without specifying a value for this field will result in insertion failure"
DDLCheckColumnBlobWithNotNullDesc = "It is not recommended to set blob and text type fields to not null"
DDLCheckColumnBlobWithNotNullMessage = "It is not recommended to set blob and text type fields to not null"
DDLCheckColumnCharLengthAnnotation = "Varchar is a variable-length field, which takes up less storage space and can save storage space. at the same time, the retrieval efficiency of relatively small fields is obviously higher"
DDLCheckColumnCharLengthDesc = "Char length greater than 20 must use varchar type"
DDLCheckColumnCharLengthMessage = "Char length greater than 20 must use varchar type"
DDLCheckColumnEnumNoticeAnnotation = "Enum type is not sql standard, portability is poor, later modification or addition of enum values requires rebuilding the entire table, which is costly and cannot be sorted by literal values"
DDLCheckColumnEnumNoticeDesc = "It is not recommended to use enum type"
DDLCheckColumnEnumNoticeMessage = "It is not recommended to use enum type"
DDLCheckColumnNotNULLAnnotation = "Table fields are recommended to have not null constraints, which can ensure data integrity, prevent the insertion of null values, and improve query accuracy."
DDLCheckColumnNotNULLDesc = "Table fields are recommended to have not null constraints"
DDLCheckColumnNotNULLMessage = "It is recommended to set the not null constraint for field %v"
DDLCheckColumnQuantityAnnotation = "Avoid wide table design on oltp systems, which will have a great impact on performance in the future; the specific rule threshold can be adjusted according to business needs, the default value is 40"
DDLCheckColumnQuantityDesc = "The number of columns in a table is not recommended to exceed the threshold"
DDLCheckColumnQuantityInPKAnnotation = "Too many columns in the primary key will result in secondary indexes taking up more space and increasing the cost of index maintenance; the specific rule threshold can be adjusted according to business needs, the default value is 2"
DDLCheckColumnQuantityInPKDesc = "The number of columns included in the primary key is not recommended to exceed the threshold"
DDLCheckColumnQuantityInPKMessage = "The number of columns included in the primary key is not recommended to exceed the threshold"
DDLCheckColumnQuantityInPKParams1 = "Maximum number of columns"
DDLCheckColumnQuantityMessage = "The number of columns in a table is not recommended to exceed the threshold"
DDLCheckColumnQuantityParams1 = "Max column quantity"
DDLCheckColumnSetNoticeAnnotation = "Modifying a set requires redefining the column, which is expensive to modify later. it is recommended to implement it in the business layer"
DDLCheckColumnSetNoticeDesc = "It is not recommended to use set type"
DDLCheckColumnSetNoticeMessage = "It is not recommended to use set type"
DDLCheckColumnTimestampWithoutDefaultAnnotation = "Adding a default value to timestamp can avoid the occurrence of all 0 date formats that do not meet business expectations"
DDLCheckColumnTimestampWithoutDefaultDesc = "Timestamp columns must add default values"
DDLCheckColumnTimestampWithoutDefaultMessage = "Timestamp columns must add default values"
DDLCheckColumnTypeIntegerAnnotation = "Int(m) or bigint(m), where m represents the maximum display width, the width of the maximum value that can be stored is 10 and 20 respectively. using int(10) or bigint(20) can avoid the possibility of display truncation"
DDLCheckColumnTypeIntegerDesc = "It is recommended to use int(10) or bigint(20) for integer definition"
DDLCheckColumnTypeIntegerMessage = "It is recommended to use int(10) or bigint(20) for integer definition"
DDLCheckColumnWithoutCommentAnnotation = "Adding comments to columns can make the meaning of columns clearer and facilitate future maintenance"
DDLCheckColumnWithoutCommentDesc = "It is recommended to add comments to columns"
DDLCheckColumnWithoutCommentMessage = "It is recommended to add comments to columns"
DDLCheckColumnWithoutDefaultAnnotation = "Adding a default value to a column can avoid the impact of null values on queries"
DDLCheckColumnWithoutDefaultDesc = "Except for auto-increment columns and large field columns, every column must add a default value"
DDLCheckColumnWithoutDefaultMessage = "Except for auto-increment columns and large field columns, every column must add a default value"
DDLCheckCompositeIndexDistinctionAnnotation = "Placing fields with high distinction at the front in composite indexes helps improve query performance of indexes, because it can reduce the data range faster and improve retrieval efficiency."
DDLCheckCompositeIndexDistinctionDesc = "It is recommended to place fields with high distinction at the front in composite indexes"
DDLCheckCompositeIndexDistinctionMessage = "It is recommended to place fields with high distinction at the front in composite indexes, %v"
DDLCheckCompositeIndexMaxAnnotation = "Composite indexes create corresponding combination indexes according to the number of index columns. the more columns, the more indexes created, and each index will increase disk space overhead and increase index maintenance overhead; the specific rule threshold can be adjusted according to business needs, the default value: 3"
DDLCheckCompositeIndexMaxDesc = "The number of columns in composite indexes is not recommended to exceed the threshold"
DDLCheckCompositeIndexMaxMessage = "The number of columns in composite indexes is not recommended to exceed %v"
DDLCheckCompositeIndexMaxParams1 = "Max index column quantity"
DDLCheckCreateFunctionAnnotation = "User-defined functions are poorly maintained and highly dependent, which can lead to sql unable to use across databases"
DDLCheckCreateFunctionDesc = "Prohibit the use of user-defined functions"
DDLCheckCreateFunctionMessage = "Prohibit the use of user-defined functions"
DDLCheckCreateProcedureAnnotation = "Stored procedures make programs difficult to debug and extend to some extent. the syntax of stored procedures in various databases is very different, which brings great difficulty to future database migration, and greatly increases the probability of bugs"
DDLCheckCreateProcedureDesc = "Prohibit the use of stored procedures"
DDLCheckCreateProcedureMessage = "Prohibit the use of stored procedures"
DDLCheckCreateTimeColumnAnnotation = "Using the create_time field is beneficial to problem tracking and data retrieval, and it also avoids the inconvenience of managing the data lifecycle later. the default value is current_timestamp, which can ensure the accuracy of the time"
DDLCheckCreateTimeColumnDesc = "It is recommended that the table DDL includes a creation time field with a default value of current_timestamp"
DDLCheckCreateTimeColumnMessage = "It is recommended that the table DDL includes %v field with a default value of current_timestamp"
DDLCheckCreateTimeColumnParams1 = "Create time field name"
DDLCheckCreateTriggerAnnotation = "Triggers are difficult to develop and maintain, cannot be efficiently migrated, and are prone to deadlocks that affect business under complex logic and high concurrency"
DDLCheckCreateTriggerDesc = "Prohibit the use of triggers"
DDLCheckCreateTriggerMessage = "Prohibit the use of triggers"
DDLCheckCreateViewAnnotation = "The query performance of views is poor, and the base table structure changes need to be maintained for views. if the view readability is poor and contains complex logic, it will increase the maintenance cost"
DDLCheckCreateViewDesc = "Prohibit the use of views"
DDLCheckCreateViewMessage = "Prohibit the use of views"
DDLCheckDatabaseCollationAnnotation = "This rule constrains the global database collation to avoid creating unexpected database collations, preventing unexpected sorting results from the business side. it is recommended that the database tables in the project use unified character sets and collation. in some cases of joining tables, inconsistent character sets or collation of fields may cause index failure and are difficult to find"
DDLCheckDatabaseCollationDesc = "It is recommended to use the specified database collation"
DDLCheckDatabaseCollationMessage = "It is recommended to use the specified database collation as %s"
DDLCheckDatabaseCollationParams1 = "Database collation"
DDLCheckDatabaseSuffixAnnotation = "By configuring this rule, you can standardize the database naming rules of the specified business. specific naming rules can be customized. default prompt value: _db"
DDLCheckDatabaseSuffixDesc = "It is recommended to use a fixed suffix for the database name"
DDLCheckDatabaseSuffixMessage = "It is recommended that the database name ends with \"%v\""
DDLCheckDatabaseSuffixParams1 = "Database name suffix"
DDLCheckDecimalTypeColumnAnnotation = "For floating point operations, decimal has higher accuracy"
DDLCheckDecimalTypeColumnDesc = "It is recommended to use decimal for precise floating point numbers"
DDLCheckDecimalTypeColumnMessage = "It is recommended to use decimal for precise floating point numbers"
DDLCheckFieldNotNUllMustContainDefaultValueAnnotation = "If there is a field with not null and without default value, insert without this field will cause an error"
DDLCheckFieldNotNUllMustContainDefaultValueDesc = "It is recommended to set default value for the field with not null constraint"
DDLCheckFieldNotNUllMustContainDefaultValueMessage = "It is recommended to set default value for the field with not null constraint, the following fields are not compliant: %v"
DDLCheckFullWidthQuotationMarksAnnotation = "It is recommended to enable this rule to avoid mysql identifying chinese full-width quotes as part of the name, which may lead to different execution results from business expectations"
DDLCheckFullWidthQuotationMarksDesc = "It is not recommended to use chinese full-width quotes in DDL statements"
DDLCheckFullWidthQuotationMarksMessage = "It is not recommended to use chinese full-width quotes in DDL statements, this may be a typo"
DDLCheckIndexCountAnnotation = "Each index created on a table will increase storage overhead, and index will also increase processing overhead for insert, delete and update operations. too many, insufficient and incorrect indexes will be of no benefit to performance; the specific rule threshold can be adjusted according to business needs, default value: 5"
DDLCheckIndexCountDesc = "The number of indexes is recommended not to exceed the threshold"
DDLCheckIndexCountMessage = "The number of indexes is recommended not to exceed %v"
DDLCheckIndexCountParams1 = "Max index count"
DDLCheckIndexNotNullConstraintAnnotation = "If there is no not null constraint on the indexed field, the table record and the index record will not be completely mapped."
DDLCheckIndexNotNullConstraintDesc = "The indexed field needs to have a not null constraint"
DDLCheckIndexNotNullConstraintMessage = "These indexed fields (%v) need to have a not null constraint"
DDLCheckIndexOptionAnnotation = "Choose fields with high selectivity as indexes, which can quickly locate data; if the selectivity is too low, it cannot be used effectively, and even may need to scan a large number of data pages, slowing down sql; the specific rule threshold can be adjusted according to business needs, default value: 70"
DDLCheckIndexOptionDesc = "It is recommended that the indexed field has a selectivity greater than the threshold"
DDLCheckIndexOptionMessage = "Index %v does not exceed the selectivity threshold of %v, it is not recommended to select it as an index"
DDLCheckIndexOptionParams1 = "Selectivity (percentage)"
DDLCheckIndexPrefixAnnotation = "By configuring this rule, you can standardize the index naming rules of the specified business, the specific naming rules can be customized, default prompt value: idx_"
DDLCheckIndexPrefixDesc = "It is recommended to use a fixed prefix for ordinary indexes"
DDLCheckIndexPrefixMessage = "It is recommended that ordinary indexes should be prefixed with \"%v\""
DDLCheckIndexPrefixParams1 = "Index prefix"
DDLCheckIndexTooManyAnnotation = "There are too many indexes on a single field. in most cases, these indexes have no value. on the contrary, they will reduce the performance of data insertion and deletion, especially for tables that are frequently updated, the negative impact is even greater. the specific rule threshold can be adjusted according to business needs, default value: 2"
DDLCheckIndexTooManyDesc = "The number of indexes on a single field is recommended not to exceed the threshold"
DDLCheckIndexTooManyMessage = "The number of indexes on field %v is recommended not to exceed %v"
DDLCheckIndexTooManyParams1 = "Max index count for a single field"
DDLCheckIndexedColumnWithBlobAnnotation = "Blob type belongs to large field type, and indexing will take up a lot of storage space"
DDLCheckIndexedColumnWithBlobDesc = "Do not include blob type columns in indexes"
DDLCheckIndexedColumnWithBlobMessage = "Do not include blob type columns in indexes"
DDLCheckIndexesExistBeforeCreateConstraintsAnnotation = "Create index before creating constraint, constraint can act on secondary index to avoid full table scan and improve performance"
DDLCheckIndexesExistBeforeCreateConstraintsDesc = "It is recommended to create index before creating constraint for field"
DDLCheckIndexesExistBeforeCreateConstraintsMessage = "It is recommended to create index before creating constraint for field"
DDLCheckIsExistLimitOffsetAnnotation = "For example: limit n offset m or limit m, n. when the offset m is too large, the query efficiency will be very low, because mysql first retrieves m+n data, and then discards the first m data. for mysql tables with large data volume, using limit pagination has very serious performance problems"
DDLCheckIsExistLimitOffsetDesc = "Avoid using offset when using pagination query"
DDLCheckIsExistLimitOffsetMessage = "Avoid using offset when using pagination query"
DDLCheckObjectNameIsUpperAndLowerLetterMixedAnnotation = "Database object naming convention, it is not recommended to use a mixed case form, it is recommended to connect words with underscores, which improves code readability"
DDLCheckObjectNameIsUpperAndLowerLetterMixedDesc = "It is not recommended to mix uppercase and lowercase letters in database object names"
DDLCheckObjectNameIsUpperAndLowerLetterMixedMessage = "It is not recommended to mix uppercase and lowercase letters in database object names, the following object names are not compliant: %v"
DDLCheckObjectNameLengthAnnotation = "By configuring this rule, you can standardize the object naming length of the specified business, the specific length can be customized, default maximum length: 64. it is the maximum length of the identifier name specified by mysql, 64 bytes"
DDLCheckObjectNameLengthDesc = "The length of table name, column name and index name is recommended not to exceed the threshold"
DDLCheckObjectNameLengthMessage = "The length of table name, column name and index name is recommended not to exceed %v bytes"
DDLCheckObjectNameLengthParams1 = "Max length (bytes)"
DDLCheckObjectNameUseCNAnnotation = "By configuring this rule, you can standardize the data object naming rules of the specified business"
DDLCheckObjectNameUseCNDesc = "Database object names can only use english, underscores or numbers, and the first letter must be english"
DDLCheckObjectNameUseCNMessage = "Database object names can only use english, underscores or numbers, and the first letter must be english"
DDLCheckObjectNameUsingKeywordAnnotation = "By configuring this rule, you can standardize the data object naming rules of the specified business, avoid conflicts, and avoid confusion"
DDLCheckObjectNameUsingKeywordDesc = "Database object names are prohibited from using reserved words"
DDLCheckObjectNameUsingKeywordMessage = "Database object names are prohibited from using reserved words %s"
DDLCheckPKNameAnnotation = "By configuring this rule, you can standardize the primary key naming rules of the specified business"
DDLCheckPKNameDesc = "It is recommended to name the primary key \"pk_tablename\""
DDLCheckPKNameMessage = "It is recommended to name the primary key \"pk_tablename\""
DDLCheckPKNotExistAnnotation = "Primary key ensures data is globally unique, which can improve data retrieval efficiency"
DDLCheckPKNotExistDesc = "Table must have a primary key"
DDLCheckPKNotExistMessage = "Table must have a primary key"
DDLCheckPKProhibitAutoIncrementAnnotation = "Later maintenance is relatively inconvenient. It is too dependent on the database auto-increment mechanism to achieve global uniqueness. It is not easy to split and it is easy to cause primary key conflicts"
DDLCheckPKProhibitAutoIncrementDesc = "It is not recommended to use auto-increment for primary key"
DDLCheckPKProhibitAutoIncrementMessage = "It is not recommended to use auto-increment for primary key"
DDLCheckPKWithoutAutoIncrementAnnotation = "Auto-increment primary key, numerical type is fast, and it is incremental growth, occupies less space, and faster data insertion operations, avoiding increasing the cost of maintaining indexes"
DDLCheckPKWithoutAutoIncrementDesc = "It is recommended to use auto-increment for primary key"
DDLCheckPKWithoutAutoIncrementMessage = "It is recommended to use auto-increment for primary key"
DDLCheckPKWithoutBigintUnsignedAnnotation = "Bigint unsigned has a larger value range. It is recommended to enable this rule to avoid overflow"
DDLCheckPKWithoutBigintUnsignedDesc = "It is recommended to use bigint unsigned type for primary key, which is bigint unsigned"
DDLCheckPKWithoutBigintUnsignedMessage = "It is recommended to use bigint unsigned type for primary key, which is bigint unsigned"
DDLCheckPKWithoutIfNotExistsAnnotation = "When creating a new table, if the table already exists, adding if not exists create will cause an error in the execution of sql. It is recommended to enable this rule to avoid sql errors in actual execution"
DDLCheckPKWithoutIfNotExistsDesc = "It is recommended to add if not exists when creating a new table to ensure that repeated execution does not cause errors"
DDLCheckPKWithoutIfNotExistsMessage = "It is recommended to add if not exists when creating a new table to ensure that repeated execution does not cause errors"
DDLCheckRedundantIndexAnnotation = "Mysql needs to maintain redundant indexes separately, redundant indexes increase maintenance costs, and the optimizer needs to calculate costs one by one when optimizing queries, affecting query performance"
DDLCheckRedundantIndexDesc = "It is not recommended to create redundant indexes"
DDLCheckRedundantIndexMessage = "%v"
DDLCheckTableCharacterSetAnnotation = "This rule constrains the global database character set, avoiding the creation of unexpected character sets and preventing problems such as garbled characters on the business side. It is recommended that tables in the project use the same character set and character set collation. In some cases of join queries, inconsistent character sets or collation rules of fields may lead to index failure and are difficult to detect"
DDLCheckTableCharacterSetDesc = "It is recommended to use the specified database character set"
DDLCheckTableCharacterSetMessage = "It is recommended to use %v database character set"
DDLCheckTableCharacterSetParams1 = "Database character set"
DDLCheckTableDBEngineAnnotation = "By configuring this rule, you can standardize the database engine specified for the business. The specific rule can be customized. The default value is innodb. Innodb supports transactions, supports row-level locks, has better recovery, and has better performance under high concurrency"
DDLCheckTableDBEngineDesc = "It is recommended to use the specified database engine"
DDLCheckTableDBEngineMessage = "It is recommended to use %v database engine"
DDLCheckTableDBEngineParams1 = "Database engine"
DDLCheckTablePartitionAnnotation = "Partitioned tables appear as multiple files physically and as one table logically. Cross-partition queries may be less efficient. It is recommended to use physical table splitting to manage large data"
DDLCheckTablePartitionDesc = "It is not recommended to use partitioned table related functions"
DDLCheckTablePartitionMessage = "It is not recommended to use partitioned table related functions"
DDLCheckTableRowsAnnotation = "When the number of rows in the table exceeds the threshold, splitting the table can help improve database performance and query speed."
DDLCheckTableRowsDesc = "If the number of rows in the table exceeds the threshold, it is recommended to split the table"
DDLCheckTableRowsMessage = "If the number of rows in the table exceeds the threshold, it is recommended to split the table"
DDLCheckTableRowsParams1 = "Number of table rows (ten thousand)"
DDLCheckTableSizeAnnotation = "It takes a long time for a large table to execute ddl, and the load is high. It takes up lock resources for a long time, which will affect database performance. The specific rule threshold can be adjusted according to business needs. Default value: 1024"
DDLCheckTableSizeDesc = "It is not recommended to perform DDL operations on tables with large data volume"
DDLCheckTableSizeMessage = "The space of the table %v executing DDL is not recommended to exceed %vmb"
DDLCheckTableSizeParams1 = "Table space size (mb)"
DDLCheckTableWithoutCommentAnnotation = "Adding comments to the table can make the meaning of the table more clear, which is convenient for later maintenance"
DDLCheckTableWithoutCommentDesc = "It is recommended to add comments to the table"
DDLCheckTableWithoutCommentMessage = "It is recommended to add comments to the table"
DDLCheckTransactionIsolationLevelAnnotation = "Rc avoids dirty reads, but does not solve the problem of phantom reads. Using rr can avoid phantom reads, but the introduction of gap locks can lead to a larger locking scope, which can affect concurrency and is prone to deadlocks. Therefore, in most business scenarios, the probability of phantom reads is relatively low, and rc can basically meet business needs"
DDLCheckTransactionIsolationLevelDesc = "It is recommended to set the transaction isolation level to rc"
DDLCheckTransactionIsolationLevelMessage = "It is recommended to set the transaction isolation level to rc"
DDLCheckUniqueIndexAnnotation = "By configuring this rule, you can standardize the naming rules of unique indexes specified for the business"
DDLCheckUniqueIndexDesc = "It is recommended to use idx_uk_table name_field name for unique index name"
DDLCheckUniqueIndexMessage = "It is recommended to use idx_uk_table name_field name for unique index name"
DDLCheckUniqueIndexPrefixAnnotation = "By configuring this rule, you can standardize the naming rules of unique indexes specified for the business. The specific naming convention can be customized. The default prompt value: uniq_"
DDLCheckUniqueIndexPrefixDesc = "It is recommended to use a fixed prefix for unique index"
DDLCheckUniqueIndexPrefixMessage = "It is recommended that unique index should start with \"%v\""
DDLCheckUniqueIndexPrefixParams1 = "Index prefix"
DDLCheckUpdateTimeColumnAnnotation = "Using the update time field is beneficial for problem tracking and data retrieval, and avoids the inconvenience of data lifecycle management in the later stage. the default value is update_time, which can ensure the accuracy of the time"
DDLCheckUpdateTimeColumnDesc = "The table DDL needs to include the update time field and the default value is current_timestamp on update current_timestamp"
DDLCheckUpdateTimeColumnMessage = "The table DDL needs to include %v field and the default value is current_timestamp on update current_timestamp"
DDLCheckUpdateTimeColumnParams1 = "Update time field name"
DDLCheckVarcharSizeAnnotation = "Mysql does not limit the size of the index when building the index. the index length will default to the length of the field. the longer the varchar definition length is, the larger the index storage size will be. the specific rule threshold can be adjusted according to business needs. default value: 1024"
DDLCheckVarcharSizeDesc = "It is not recommended to define the length of varchar greater than the threshold"
DDLCheckVarcharSizeMessage = "It is not recommended to define the length of varchar greater than the threshold, the threshold is %d"
DDLCheckVarcharSizeParams1 = "Maximum length of varchar"
DDLDisableAlterFieldUseFirstAndAfterAnnotation = "The alter operation of first, after is completed by copying the table, which has a great impact on the business"
DDLDisableAlterFieldUseFirstAndAfterDesc = "It is forbidden to use first, after for alter table fields"
DDLDisableAlterFieldUseFirstAndAfterMessage = "It is forbidden to use first, after for alter table fields"
DDLDisableDropStatementAnnotation = "Drop is a ddl, data changes will not be written to the log, and cannot be rolled back. it is recommended to enable this rule to avoid accidental deletion operations"
DDLDisableDropStatementDesc = "Prohibit drop operations except for indexes"
DDLDisableDropStatementMessage = "Prohibit drop operations except for indexes"
DDLDisableFKAnnotation = "Foreign keys have poor performance in high concurrency scenarios, are prone to deadlocks, and are not conducive to later maintenance (splitting, migration)"
DDLDisableFKDesc = "It is forbidden to use foreign keys"
DDLDisableFKMessage = "It is forbidden to use foreign keys"
DDLDisableTypeTimestampAnnotation = "Timestamp has a maximum value limit ('2038-01-19 03:14:07' utc), and there are problems with time zone conversion"
DDLDisableTypeTimestampDesc = "It is not recommended to use timestamp fields"
DDLDisableTypeTimestampMessage = "It is not recommended to use timestamp fields"
DDLHintDropColumnAnnotation = "The business logic and the deleted column dependencies are not completely eliminated. after the column is deleted, it may lead to program exceptions (unable to read and write normally). enabling this rule will remind sqle that deleting columns is a high-risk operation"
DDLHintDropColumnDesc = "It is forbidden to delete columns"
DDLHintDropColumnMessage = "It is forbidden to delete columns"
DDLHintDropForeignKeyAnnotation = "Deleting existing constraints will affect existing business logic. enabling this rule will remind sqle that deleting foreign keys is a high-risk operation"
DDLHintDropForeignKeyDesc = "It is forbidden to delete foreign keys"
DDLHintDropForeignKeyMessage = "It is forbidden to delete foreign keys"
DDLHintDropPrimaryKeyAnnotation = "Deleting existing constraints will affect existing business logic. enabling this rule will remind sqle that deleting primary keys is a high-risk operation"
DDLHintDropPrimaryKeyDesc = "It is forbidden to delete primary keys"
DDLHintDropPrimaryKeyMessage = "It is forbidden to delete primary keys"
DDLHintUpdateTableCharsetWillNotUpdateFieldCharsetAnnotation = "Modifying the default character set of the table will only affect the subsequently added fields, not the character set of the existing fields in the table. if you need to modify the character set of all fields in the whole table, it is recommended to enable this rule"
DDLHintUpdateTableCharsetWillNotUpdateFieldCharsetDesc = "It is not recommended to modify the default character set of the table"
DDLHintUpdateTableCharsetWillNotUpdateFieldCharsetMessage = "It is not recommended to modify the default character set of the table"
DDLNotAllowRenamingAnnotation = "Rename/change table name/column name will affect online business non-stop release. if this operation is required, it should be manually intervened by dba"
DDLNotAllowRenamingDesc = "It is forbidden to use rename or change to modify the table name or column name"
DDLNotAllowRenamingMessage = "It is forbidden to use rename or change to modify the table name or column name"
DDLRecommendTableColumnCharsetSameAnnotation = "Unified character set can avoid garbled characters caused by character set conversion. different character sets need to be converted before comparison, which will cause index failure"
DDLRecommendTableColumnCharsetSameDesc = "It is recommended that columns and tables use the same character set"
DDLRecommendTableColumnCharsetSameMessage = "It is recommended that columns and tables use the same character set"
DMLAvoidWhereEqualNullAnnotation = "Null is a special value in sql, and cannot be compared with ordinary values. for example: column = null is always false. even if column has null value, it will not be queried out, so column = null should be written as column is null"
DMLAvoidWhereEqualNullDesc = "It is forbidden to compare null values with other fields or values in the where clause"
DMLAvoidWhereEqualNullMessage = "It is forbidden to compare null values with other fields or values in the where clause"
DMLCheckAffectedRowsAnnotation = "If the number of rows affected by the DML operation is too large, it will lead to a decline in query performance, because it needs to scan more data."
DMLCheckAffectedRowsDesc = "It is not recommended that the number of rows affected by update/delete operations exceed the threshold"
DMLCheckAffectedRowsMessage = "It is not recommended that the number of rows affected by update/delete operations exceed the threshold. the number of rows affected is %v, which exceeds the set threshold %v"
DMLCheckAffectedRowsParams1 = "Maximum number of rows affected"
DMLCheckAggregateAnnotation = "It is not recommended to use sql aggregate functions to ensure the simplicity, high performance and data consistency of the query."
DMLCheckAggregateDesc = "It is not recommended to use aggregate functions"
DMLCheckAggregateMessage = "It is not recommended to use aggregate functions to calculate"
DMLCheckAliasAnnotation = "The alias of the table or column is the same as its real name, which makes the query more difficult to distinguish"
DMLCheckAliasDesc = "It is not recommended to use the same name for the alias and the table or column"
DMLCheckAliasMessage = "These aliases (%v) are the same as the column or table names"
DMLCheckBatchInsertListsMaxAnnotation = "Avoid large transactions and reduce the impact of rollback on business; the specific rule threshold can be adjusted according to business needs, the default value: 100"
DMLCheckBatchInsertListsMaxDesc = "For a single insert statement, it is recommended to insert no more than the threshold in batches"
DMLCheckBatchInsertListsMaxMessage = "For a single insert statement, it is recommended to insert no more than %v rows in batches"
DMLCheckBatchInsertListsMaxParams1 = "Maximum number of inserted rows"
DMLCheckExplainAccessTypeAllAnnotation = "When scanning the entire table, scanning rows beyond the specified number is not recommended to avoid performance issues; the specific rule threshold can be adjusted according to business needs, the default value: 10000; if set to 0, all full table scans will trigger the rule"
DMLCheckExplainAccessTypeAllDesc = "When scanning the entire table, the number of scanned rows is not recommended to exceed the specified number (default value: 10000)"
DMLCheckExplainAccessTypeAllMessage = "This query uses a full table scan and the number of scanned rows is %v"
DMLCheckExplainAccessTypeAllParams1 = "Maximum number of scanned rows"
DMLCheckExplainExtraUsingFilesortAnnotation = "In the case of large amounts of data, file sorting means that SQL performance is relatively low, which will increase the overhead of the OS and affect database performance"
DMLCheckExplainExtraUsingFilesortDesc = "File sorting is not recommended"
DMLCheckExplainExtraUsingFilesortMessage = "File sorting is not recommended"
DMLCheckExplainExtraUsingIndexForSkipScanAnnotation = "Index scanning is a skip scan, does not follow the leftmost match rule, which may reduce the efficiency of index use and affect query performance"
DMLCheckExplainExtraUsingIndexForSkipScanDesc = "It is not recommended to perform index skip scanning on tables"
DMLCheckExplainExtraUsingIndexForSkipScanMessage = "It is not recommended to perform index skip scanning on tables"
DMLCheckExplainExtraUsingTemporaryAnnotation = "In the case of large amounts of data, temporary tables mean that SQL performance is relatively low, which will increase the overhead of the OS and affect database performance"
DMLCheckExplainExtraUsingTemporaryDesc = "It is not recommended to use temporary tables"
DMLCheckExplainExtraUsingTemporaryMessage = "It is not recommended to use temporary tables"
DMLCheckExplainFullIndexScanAnnotation = "In the case of large amounts of data, full index scanning seriously affects SQL performance."
DMLCheckExplainFullIndexScanDesc = "It is not recommended to perform full index scanning on tables"
DMLCheckExplainFullIndexScanMessage = "It is not recommended to perform full index scanning on tables"
DMLCheckExplainUsingIndexAnnotation = "Using indexes can significantly improve the performance of SQL queries."
DMLCheckExplainUsingIndexDesc = "SQL query conditions need to use indexes"
DMLCheckExplainUsingIndexMessage = "It is recommended to use indexes to optimize SQL query performance"
DMLCheckFuzzySearchAnnotation = "Using full fuzzy search or left fuzzy search will cause the query to be unable to use indexes, resulting in a full table scan"
DMLCheckFuzzySearchDesc = "Prohibit full fuzzy search or left fuzzy search"
DMLCheckFuzzySearchMessage = "Prohibit full fuzzy search or left fuzzy search"
DMLCheckHasJoinConditionAnnotation = "Specifying join conditions can ensure the correctness and reliability of join operations. If join conditions are not specified, it may lead to join failures or incorrect joins."
DMLCheckHasJoinConditionDesc = "It is recommended to specify join conditions for join operations"
DMLCheckHasJoinConditionMessage = "It is recommended to specify join conditions for join operations, there must be ON conditions after JOIN fields"
DMLCheckIfAfterUnionDistinctAnnotation = "UNION will sort and deduplicate according to the order of the fields, UNION ALL simply merges the two results and then returns them. In terms of efficiency, UNION ALL is much faster than UNION; if the two merged results are allowed to contain duplicate data and no sorting is required, it is recommended to enable this rule, use UNION ALL to replace UNION"
DMLCheckIfAfterUnionDistinctDesc = "It is recommended to use UNION ALL instead of UNION"
DMLCheckIfAfterUnionDistinctMessage = "It is recommended to use UNION ALL instead of UNION"
DMLCheckInQueryNumberAnnotation = "When there are too many IN values, it may lead to full table scans for the query, causing MySQL performance to drop sharply; the specific rule threshold can be adjusted according to business needs, the default value: 50"
DMLCheckInQueryNumberDesc = "The number of parameters in the IN statement in the WHERE condition cannot exceed the threshold"
DMLCheckInQueryNumberMessage = "The number of parameters in the IN statement in the WHERE condition is already %v, it is not recommended to exceed the threshold %v"
DMLCheckInQueryNumberParams1 = "Maximum number of in statement parameters"
DMLCheckIndexSelectivityAnnotation = "Ensure the selectivity of the high index used in the SQL execution plan, which helps to improve query performance and optimize query efficiency."
DMLCheckIndexSelectivityDesc = "It is recommended to ensure that the selectivity of the index used in the SQL execution plan is greater than the threshold when querying the database"
DMLCheckIndexSelectivityMessage = "Index: %v, not exceeding the selectivity threshold: %v, it is recommended to use an index that exceeds the threshold."
DMLCheckIndexSelectivityParams1 = "Selectivity (percentage)"
DMLCheckInsertColumnsExistAnnotation = "When the table structure changes, and the INSERT request does not explicitly specify the column name, there will be a mismatch in the inserted data; it is recommended to enable this rule to avoid the insertion result being inconsistent with business expectations"
DMLCheckInsertColumnsExistDesc = "INSERT statement needs to specify COLUMN"
DMLCheckInsertColumnsExistMessage = "INSERT statement needs to specify COLUMN"
DMLCheckInsertSelectAnnotation = "Using INSERT ... SELECT under the default transaction isolation level may cause table-level locks to be applied to the queried table."
DMLCheckInsertSelectDesc = "It is not recommended to use INSERT ... SELECT"
DMLCheckInsertSelectMessage = "It is not recommended to use INSERT ... SELECT"
DMLCheckJoinFieldCharacterSetAndCollationAnnotation = "Consistent character sets and collations of the joined table fields can avoid data inconsistency and query errors, ensuring that the join operation executes correctly."
DMLCheckJoinFieldCharacterSetAndCollationDesc = "The character set and collation of the joined table fields must be consistent"
DMLCheckJoinFieldCharacterSetAndCollationMessage = "The character set and collation of the joined table fields must be consistent"
DMLCheckJoinFieldTypeAnnotation = "Join field type mismatch will cause implicit conversion, which may lead to index invalidation. it is recommended to enable this rule to avoid index invalidation."
DMLCheckJoinFieldTypeDesc = "It is recommended to keep the join field types consistent"
DMLCheckJoinFieldTypeMessage = "It is recommended to keep the join field types consistent, otherwise it will cause implicit conversion"
DMLCheckJoinFieldUseIndexAnnotation = "Join fields containing indexes can improve the performance and query speed of join operations."
DMLCheckJoinFieldUseIndexDesc = "Join fields must contain indexes"
DMLCheckJoinFieldUseIndexMessage = "Join fields must contain indexes"
DMLCheckLimitMustExistAnnotation = "Limit condition can reduce the cost of writing wrong sql (deleting wrong data) and avoid long transactions from affecting business"
DMLCheckLimitMustExistDesc = "It is recommended that delete/update statements have limit conditions"
DMLCheckLimitMustExistMessage = "It is recommended that delete/update statements have limit conditions"
DMLCheckLimitOffsetNumAnnotation = "Because offset specifies the starting position of the result set, if the starting position is too large, mysql needs to process more data to return the result set, which may lead to a decline in query performance."
DMLCheckLimitOffsetNumDesc = "It is not recommended that the limit offset is greater than the threshold"
DMLCheckLimitOffsetNumMessage = "It is not recommended that the limit offset is greater than the threshold, offset=%v (threshold is %v)"
DMLCheckLimitOffsetNumParams1 = "Offset size"
DMLCheckMathComputationOrFuncOnIndexAnnotation = "Performing mathematical operations and using functions on index columns will cause index invalidation, leading to full table scans and affecting query performance."
DMLCheckMathComputationOrFuncOnIndexDesc = "It is forbidden to perform mathematical operations and use functions on index columns"
DMLCheckMathComputationOrFuncOnIndexMessage = "It is forbidden to perform mathematical operations and use functions on index columns"
DMLCheckNeedlessFuncAnnotation = "By configuring this rule, you can specify built-in functions that need to be prohibited in the business. using built-in functions may cause sql to not use indexes or produce some unexpected results. the actual functions that need to be disabled can be configured through the rules"
DMLCheckNeedlessFuncDesc = "Avoid using unnecessary built-in functions"
DMLCheckNeedlessFuncMessage = "Avoid using unnecessary built-in functions %v"
DMLCheckNeedlessFuncParams1 = "Set of specified functions (comma-separated)"
DMLCheckNotEqualSymbolAnnotation = "'!=' is a non-standard operator, '<>' is the standard not equal operator in sql"
DMLCheckNotEqualSymbolDesc = "It is recommended to use '<>' instead of '!=' "
DMLCheckNotEqualSymbolMessage = "It is recommended to use '<>' instead of '!=' "
DMLCheckNumberOfJoinTablesAnnotation = "The more tables are joined, the more driver relationship combinations there are, the higher the cost of comparing the execution cost of various result sets, and the sql query performance will be greatly reduced. the specific rule threshold can be adjusted according to business needs, default value: 3"
DMLCheckNumberOfJoinTablesDesc = "It is recommended that the number of tables joined using join does not exceed the threshold"
DMLCheckNumberOfJoinTablesMessage = "It is recommended that the number of tables joined using join does not exceed %v tables"
DMLCheckNumberOfJoinTablesParams1 = "Maximum number of joined tables"
DMLCheckSQLInjectionFuncAnnotation = "Attackers can access data in the database without authorization through sql injection, which poses security vulnerabilities such as theft of user information and data leakage"
DMLCheckSQLInjectionFuncDesc = "It is not recommended to use common sql injection functions"
DMLCheckSQLInjectionFuncMessage = "It is not recommended to use common sql injection functions"
DMLCheckSQLLengthAnnotation = "Too long sql is less readable, difficult to maintain, and prone to performance problems. the specific rule threshold can be adjusted according to business needs, default value: 1024"
DMLCheckSQLLengthDesc = "It is recommended to decompose long sql into several simple sqls"
DMLCheckSQLLengthMessage = "It is recommended to decompose long sql into several simple sqls"
DMLCheckSQLLengthParams1 = "Maximum sql length"
DMLCheckSameTableJoinedMultipleTimesAnnotation = "If a single table is queried multiple times, query performance will be reduced."
DMLCheckSameTableJoinedMultipleTimesDesc = "It is not recommended to join the same table multiple times"
DMLCheckSameTableJoinedMultipleTimesMessage = "Table %v is joined multiple times"
DMLCheckScanRowsAnnotation = "The filter condition must include the primary key or index to reduce the time complexity of the database query and improve the query efficiency."
DMLCheckScanRowsDesc = "The number of scanned rows exceeds the threshold, the filter condition must include the primary key or index"
DMLCheckScanRowsMessage = "The number of scanned rows exceeds the threshold, the filter condition must include the primary key or index"
DMLCheckScanRowsParams1 = "Number of scanned rows (ten thousand)"
DMLCheckSelectForUpdateAnnotation = "Select for update will add an exclusive lock to each row of data in the query result set. other threads' updates and deletions to the record will be blocked. under high concurrency, it is easy to cause a large number of lock waits in the database, affecting database query performance"
DMLCheckSelectForUpdateDesc = "It is not recommended to use select for update"
DMLCheckSelectForUpdateMessage = "It is not recommended to use select for update"
DMLCheckSelectLimitAnnotation = "If the number of scanned rows is very large, it may cause the optimizer to choose the wrong index or even not use the index. the specific rule threshold can be adjusted according to business needs, default value: 1000"
DMLCheckSelectLimitDesc = "Select statements need to have limit"
DMLCheckSelectLimitMessage = "Select statements need to have limit, and the limit number cannot exceed %v"
DMLCheckSelectLimitParams1 = "Maximum number of query rows"
DMLCheckSelectRowsAnnotation = "The filter condition must include the primary key or index to improve query performance and reduce the cost of full table scans."
DMLCheckSelectRowsDesc = "The amount of data queried exceeds the threshold, the filter condition must include the primary key or index"
DMLCheckSelectRowsMessage = "Query data volume exceeds the threshold, filter conditions must include primary key or index"
DMLCheckSelectRowsParams1 = "Query data volume (ten thousand)"
DMLCheckSelectWithOrderByAnnotation = "Order by has a significant impact on query performance, and it is not conducive to optimization and maintenance. it is recommended to put the sorting part into business processing"
DMLCheckSelectWithOrderByDesc = "Select statement cannot have order by"
DMLCheckSelectWithOrderByMessage = "Select statement cannot have order by"
DMLCheckSortColumnLengthAnnotation = "Sorting operations such as order by, distinct, group by, and union on long fields like varchar(2000) will cause sorting, which poses a performance risk"
DMLCheckSortColumnLengthDesc = "Prohibit sorting on long fields"
DMLCheckSortColumnLengthMessage = "Fields with lengths exceeding the threshold are not recommended for order by, distinct, group by, union. these fields are: %v"
DMLCheckSortColumnLengthParams1 = "Maximum length of sortable fields"
DMLCheckSortDirectionAnnotation = "Before mysql 8.0, when multiple columns specified in order by have different sorting directions, the established index cannot be used. after mysql 8.0, a corresponding combined index for the sorting order can be established to optimize"
DMLCheckSortDirectionDesc = "It is not recommended to use different directions for sorting on multiple different conditions in order by statement"
DMLCheckSortDirectionMessage = "It is not recommended to use different directions for sorting on multiple different conditions in order by statement"
DMLCheckSpacesAroundTheStringAnnotation = "Spaces before and after the string may cause the query judgment logic to be wrong. for example, in mysql 5.5, 'a' and 'a ' are considered the same value in the query"
DMLCheckSpacesAroundTheStringDesc = "It is not recommended to include spaces at the beginning or end of strings in quotation marks"
DMLCheckSpacesAroundTheStringMessage = "It is not recommended to include spaces at the beginning or end of strings in quotation marks"
DMLCheckSubQueryNestNumAnnotation = "The nesting level of subqueries exceeds the threshold. in some cases, subqueries cannot use indexes. also, for subqueries that return a large result set, a large number of temporary tables will be generated, consuming excessive cpu and io resources and generating a large number of slow queries"
DMLCheckSubQueryNestNumDesc = "The nesting level of subqueries is not recommended to exceed the threshold"
DMLCheckSubQueryNestNumMessage = "The nesting level of subqueries exceeds the threshold %v"
DMLCheckSubQueryNestNumParams1 = "The nesting level of subqueries is not recommended to exceed the threshold"
DMLCheckSubqueryLimitAnnotation = "Some mysql versions do not support 'limit & in/all/any/some' in subqueries"
DMLCheckSubqueryLimitDesc = "It is not recommended to use limit in subqueries"
DMLCheckSubqueryLimitMessage = "It is not recommended to use limit in subqueries"
DMLCheckTableSizeAnnotation = "DML operations on large tables take a long time and have a high load, which can easily affect database performance; the specific rule threshold can be adjusted according to business needs, the default value is: 1024"
DMLCheckTableSizeDesc = "It is not recommended to perform DML operations on tables with a large amount of data"
DMLCheckTableSizeMessage = "The space of the table %v for executing DML is not recommended to exceed %vmb"
DMLCheckTableSizeParams1 = "Table space size (mb)"
DMLCheckUpdateOrDeleteHasWhereAnnotation = "Because the purpose of these statements is to modify the data in the database, it is necessary to use the where condition to filter the records to be updated or deleted to ensure the correctness of the data. in addition, using the where condition can also improve query performance."
DMLCheckUpdateOrDeleteHasWhereDesc = "It is recommended to use where conditions for update/delete operations"
DMLCheckUpdateOrDeleteHasWhereMessage = "It is recommended to use where conditions for update/delete operations"
DMLCheckWhereExistFuncAnnotation = "Performing function operations on condition fields may break the order of index values, causing the optimizer to choose to abandon index traversal, resulting in a significant decrease in query performance"
DMLCheckWhereExistFuncDesc = "Avoid using function operations on condition fields"
DMLCheckWhereExistFuncMessage = "Avoid using function operations on condition fields"
DMLCheckWhereExistImplicitConversionAnnotation = "Using data types that are inconsistent with the filtering field in the where condition will cause implicit data type conversion, leading to the risk of the query not hitting the index. in high concurrency and large data volume scenarios, not using the index will severely degrade the query performance of the database"
DMLCheckWhereExistImplicitConversionDesc = "It is not recommended to use data types that are inconsistent with the filtering field in the where condition"
DMLCheckWhereExistImplicitConversionMessage = "It is not recommended to use data types that are inconsistent with the filtering field in the where condition"
DMLCheckWhereExistNotAnnotation = "Using negative queries will cause full table scans, resulting in slow sql"
DMLCheckWhereExistNotDesc = "It is not recommended to use negative queries for condition fields"
DMLCheckWhereExistNotMessage = "It is not recommended to use negative queries for condition fields"
DMLCheckWhereExistScalarSubqueryAnnotation = "Scalar subqueries have the problem of accessing the same table multiple times, which has a high execution overhead and low efficiency. left join can be used to replace scalar subqueries"
DMLCheckWhereExistScalarSubqueryDesc = "It is not recommended to use scalar subqueries"
DMLCheckWhereExistScalarSubqueryMessage = "It is not recommended to use scalar subqueries"
DMLCheckWhereIsInvalidAnnotation = "Sql lacks where condition, which will perform full table scan during execution and generate extra overhead. it is recommended to enable it in high data volume and high concurrency environments to avoid affecting database query performance"
DMLCheckWhereIsInvalidDesc = "Prohibit the use of sql without where condition or where condition is always true"
DMLCheckWhereIsInvalidMessage = "Prohibit the use of sql without where condition or where condition is always true"
DMLCheckWithLimitAnnotation = "Delete/update statements using limit conditions will randomly select data for deletion or update, which is unpredictable for business"
DMLCheckWithLimitDesc = "Delete/update statements cannot have limit conditions"
DMLCheckWithLimitMessage = "Delete/update statements cannot have limit conditions"
DMLCheckWithOrderByAnnotation = "Delete/update exists order by will use sorting, bringing unnecessary overhead"
DMLCheckWithOrderByDesc = "Delete/update statements cannot have order by"
DMLCheckWithOrderByMessage = "Delete/update statements cannot have order by"
DMLDisableSelectAllColumnAnnotation = "Using a * wildcard to select all columns when the table structure changes will cause the query behavior to change, which is not in line with business expectations; at the same time, useless fields in select * will bring unnecessary disk i/o and network overhead, and cannot cover the index, thus causing a full table scan, which greatly reduces the query efficiency"
DMLDisableSelectAllColumnDesc = "It is not recommended to use select *"
DMLDisableSelectAllColumnMessage = "It is not recommended to use select *"
DMLHintCountFuncWithColAnnotation = "It is recommended to use count(*), because using count(col) requires a full table scan, which may lead to performance degradation."
DMLHintCountFuncWithColDesc = "Avoid using count(col)"
DMLHintCountFuncWithColMessage = "Avoid using count(col)"
DMLHintDeleteTipsAnnotation = "Drop/truncate is ddl, the operation takes effect immediately, it will not be written to the log, so it cannot be rolled back. it is necessary to back up the data before performing high-risk operations."
DMLHintDeleteTipsDesc = "It is recommended to back up before performing delete/drop/truncate operations"
DMLHintDeleteTipsMessage = "It is recommended to back up before performing delete/drop/truncate operations"
DMLHintGroupByRequiresConditionsAnnotation = "In 5.7, mysql defaults to implicitly sorting 'group by col1, ...' in the following order 'order by col1, ...', which results in unnecessary sorting and brings extra overhead; in 8.0, this will not happen. if no sorting is required, it is recommended to explicitly add 'order by null'"
DMLHintGroupByRequiresConditionsDesc = "It is recommended to add order by condition to group by statement"
DMLHintGroupByRequiresConditionsMessage = "It is recommended to add order by condition to group by statement"
DMLHintInNullOnlyFalseAnnotation = "The query condition is never true, which will result in no matching results"
DMLHintInNullOnlyFalseDesc = "Avoid using in (null) or not in (null)"
DMLHintInNullOnlyFalseMessage = "Avoid using in (null)/not in (null), this usage will never be true, resulting in the condition being invalid"
DMLHintLimitMustBeCombinedWithOrderByAnnotation = "Limit without order by will result in non-deterministic results that may not be consistent with business requirements, depending on the execution plan"
DMLHintLimitMustBeCombinedWithOrderByDesc = "It is recommended to use order by for limit queries"
DMLHintLimitMustBeCombinedWithOrderByMessage = "It is recommended to use order by for limit queries"
DMLHintSumFuncTipsAnnotation = "When all values in a column are null, count(col) returns 0, but sum(col) returns null. therefore, when using sum(), it is necessary to pay attention to the npe problem (referring to data returning null); if the business needs to avoid npe problems, it is recommended to enable this rule"
DMLHintSumFuncTipsDesc = "Avoid using sum(col)"
DMLHintSumFuncTipsMessage = "Avoid using sum(col), this usage has the risk of returning null values, resulting in program null pointer"
DMLHintTruncateTipsAnnotation = "Truncate is dll, data cannot be rolled back. use truncate with caution without backup"
DMLHintTruncateTipsDesc = "It is not recommended to use truncate operation"
DMLHintTruncateTipsMessage = "It is not recommended to use truncate operation"
DMLHintUseTruncateInsteadOfDeleteAnnotation = "Truncate table is faster than delete, and uses fewer system and transaction log resources. at the same time, the space occupied by the table after truncate will be released, while delete needs to manually execute optimize to release the table space"
DMLHintUseTruncateInsteadOfDeleteDesc = "It is recommended to use truncate instead of delete when deleting the entire table"
DMLHintUseTruncateInsteadOfDeleteMessage = "It is recommended to use truncate instead of delete when deleting the entire table"
DMLMustMatchLeftMostPrefixAnnotation = "Non-equivalence queries such as in and or on the leftmost field of a combined index will cause the combined index to be invalid"
DMLMustMatchLeftMostPrefixDesc = "Prohibit non-equivalence queries such as in and or on the leftmost field of a combined index"
DMLMustMatchLeftMostPrefixMessage = "Non-equivalence queries such as in and or on the leftmost field of a combined index will cause the combined index to be invalid"
DMLMustUseLeftMostPrefixAnnotation = "Using a combined index without the first field will cause the combined index to be invalid"
DMLMustUseLeftMostPrefixDesc = "When using a combined index, the first field of the combined index must be used"
DMLMustUseLeftMostPrefixMessage = "When using a combined index, the first field of the combined index must be used"
DMLNotAllowInsertAutoincrementAnnotation = "Manual assignment may cause data gaps and primary key conflicts"
DMLNotAllowInsertAutoincrementDesc = "Prohibit manual setting of auto-increment field values"
DMLNotAllowInsertAutoincrementMessage = "Prohibit manual setting of auto-increment field values"
DMLNotRecommendFuncInWhereAnnotation = "Functions or operators will cause the query to be unable to use the index in the table. the query will perform a full table scan, which has poor performance"
DMLNotRecommendFuncInWhereDesc = "Functions or other operators should be avoided in the where condition"
DMLNotRecommendFuncInWhereMessage = "Functions or other operators should be avoided in the where condition"
DMLNotRecommendGroupByConstantAnnotation = "Group by 1 means group by the first column; using numbers instead of expressions or column names in the group by clause will cause query logic problems when the query column order changes"
DMLNotRecommendGroupByConstantDesc = "It is not recommended to group by constants"
DMLNotRecommendGroupByConstantMessage = "It is not recommended to group by constants"
DMLNotRecommendGroupByExpressionAnnotation = "When the order by condition is an expression or function, a temporary table will be used. if no where clause is specified or the result set returned by the where clause is too large, the performance will be very poor"
DMLNotRecommendGroupByExpressionDesc = "It is not recommended to use expressions as order by conditions"
DMLNotRecommendGroupByExpressionMessage = "It is not recommended to use expressions as order by conditions"
DMLNotRecommendHavingAnnotation = "For indexed fields, they will not be indexed when placed in the having clause; it is recommended to rewrite the having clause as the query condition in the where clause, so that the index can be used during query processing, improving the execution efficiency of the sql"
DMLNotRecommendHavingDesc = "It is not recommended to use the having clause"
DMLNotRecommendHavingMessage = "It is not recommended to use the having clause"
DMLNotRecommendInAnnotation = "When there are too many in values, it may cause the query to perform a full table scan, causing a sharp decline in mysql performance"
DMLNotRecommendInDesc = "It is not recommended to use in"
DMLNotRecommendInMessage = "Do not recommend using in"
DMLNotRecommendNotWildcardLikeAnnotation = "Like queries without wildcard are logically the same as equality queries, it is recommended to use equality queries instead"
DMLNotRecommendNotWildcardLikeDesc = "Do not recommend using like queries without wildcard"
DMLNotRecommendNotWildcardLikeMessage = "Do not recommend using like queries without wildcard"
DMLNotRecommendOrderByRandAnnotation = "Order by rand() uses temporary tables, and also needs to sort them. when the amount of data is large, it will increase the server load and increase the query time"
DMLNotRecommendOrderByRandDesc = "Do not recommend using order by rand()"
DMLNotRecommendOrderByRandMessage = "Do not recommend using order by rand()"
DMLNotRecommendSubqueryAnnotation = "In some cases, subqueries cannot use indexes. at the same time, for subqueries with larger result sets, a large number of temporary tables will be generated, consuming too much cpu and io resources and generating a large number of slow queries"
DMLNotRecommendSubqueryDesc = "Do not recommend using subqueries"
DMLNotRecommendSubqueryMessage = "Do not recommend using subqueries"
DMLNotRecommendSysdateAnnotation = "When the sysdate() function is in a statement-based master-slave environment, it may cause data inconsistency, because the statement is executed in the master library until the log is transmitted to the slave library, there is a time difference, and it will become a different time value when it is executed in the slave library, it is recommended to adopt row-based replication environment"
DMLNotRecommendSysdateDesc = "Do not recommend using the sysdate() function"
DMLNotRecommendSysdateMessage = "Do not recommend using the sysdate() function"
DMLNotRecommendUpdatePKAnnotation = "The order of the data columns of the primary key index is the physical storage order of the table records. frequent updates to the primary key will lead to the adjustment of the order of the entire table records, which will consume a lot of resources"
DMLNotRecommendUpdatePKDesc = "Do not recommend updating the primary key"
DMLNotRecommendUpdatePKMessage = "Do not recommend updating the primary key"
DMLSQLExplainLowestLevelAnnotation = "Verify the type field in the sql execution plan to ensure that it meets the required level to ensure query performance."
DMLSQLExplainLowestLevelDesc = "The type field in the sql execution plan is recommended to meet the specified level"
DMLSQLExplainLowestLevelMessage = "It is recommended to modify the sql to ensure that the type field in the execution plan can meet any level in the regulations: %v"
DMLSQLExplainLowestLevelParams1 = "Query plan type level, separated by english commas"
DMLWhereExistNullAnnotation = "Using is null or is not null may cause the query to abandon using the index and perform a full table scan"
DMLWhereExistNullDesc = "Do not recommend using null value judgment for conditional fields"
DMLWhereExistNullMessage = "Do not recommend using null value judgment for conditional fields"
DuplicateColumnsMessage = "Column name %s duplicated"
DuplicateIndexedColumnMessage = "Index %s column %s duplicated"
DuplicateIndexesMessage = "Index name %s duplicated"
DuplicatePrimaryKeyedColumnMessage = "Primary key column %s duplicated"
ExtremalIndexAdviceFormat = "Index suggestion | sql uses the extreme value function, you can use the ordered nature of the index to quickly find the extreme value. it is recommended to add a single-column index to table %s, refer to the column: %s"
FunctionIndexAdviceFormatAll = "Index suggestion | sql uses functions as query conditions. in mysql 5.7 and above versions, you can create indexes on virtual columns. in mysql 8.0.13 and above versions, you can create function indexes. it is recommended to add appropriate indexes to table %s based on the mysql version, refer to the column: %s"
FunctionIndexAdviceFormatV57 = "Index suggestion | sql uses functions as query conditions. in mysql 5.7 and above versions, you can create indexes on virtual columns. it is recommended to add virtual column indexes to table %s, refer to the column: %s"
FunctionIndexAdviceFormatV80 = "Index suggestion | sql uses functions as query conditions. in mysql 8.0.13 and above versions, you can create function indexes. it is recommended to add function indexes to table %s, refer to the column: %s"
GhostDryRunError = "Table space size exceeds %vmb, gh-ost will be used for online deployment, but the dry-run throws the following error: %v"
GhostDryRunNotice = "Table space size exceeds %vmb, gh-ost will be used for online deployment"
IndexExistMessage = "Index %s already exists"
IndexNotExistMessage = "Index %s does not exist"
JoinIndexAdviceFormat = "Index suggestion | sql field %s is the associated field on the driven table %s. it is recommended to add a single-column index to table %s, refer to the column: %s"
KeyedColumnNotExistMessage = "Index column %s does not exist"
MultiPrimaryKeyMessage = "The primary key can only be set to one"
NotSupportExceedMaxRowsRollback = "The estimated number of affected rows exceeds the configured maximum, no rollback statement is generated"
NotSupportHasVariableRollback = "Rollback does not support DML statements containing variables"
NotSupportInsertWithoutPrimaryKeyRollback = "Rollback does not support insert statements without specifying the primary key"
NotSupportMultiTableStatementRollback = "Rollback does not support multi-table DML statements"
NotSupportNoPrimaryKeyTableRollback = "Rollback does not support DML statements for tables without primary keys"
NotSupportOnDuplicatStatementRollback = "Rollback does not support on duplicate statements"
NotSupportParamMarkerStatementRollback = "Rollback does not support statements containing fingerprints"
NotSupportStatementRollback = "Rollback does not support this type of statement"
NotSupportSubQueryStatementRollback = "Rollback does not support statements with subqueries"
OptDMLCheckLimitOffsetNumAnnotation = "OptDMLCheckLimitOffsetNumAnnotation"
OptDMLCheckLimitOffsetNumDesc = "OptDMLCheckLimitOffsetNumDesc"
OptDMLCheckMathComputationOrFuncOnIndexAnnotation = "OptDMLCheckMathComputationOrFuncOnIndexAnnotation"
OptDMLCheckMathComputationOrFuncOnIndexDesc = "OptDMLCheckMathComputationOrFuncOnIndexDesc"
OptDMLCheckNotEqualSymbolAnnotation = "OptDMLCheckNotEqualSymbolAnnotation"
OptDMLCheckNotEqualSymbolDesc = "OptDMLCheckNotEqualSymbolDesc"
OptDMLCheckWhereExistImplicitConversionAnnotation = "OptDMLCheckWhereExistImplicitConversionAnnotation"
OptDMLCheckWhereExistImplicitConversionDesc = "OptDMLCheckWhereExistImplicitConversionDesc"
OptDMLCheckWhereExistScalarSubqueryAnnotation = "OptDMLCheckWhereExistScalarSubqueryAnnotation"
OptDMLCheckWhereExistScalarSubqueryDesc = "OptDMLCheckWhereExistScalarSubqueryDesc"
OptDMLHintGroupByRequiresConditionsAnnotation = "OptDMLHintGroupByRequiresConditionsAnnotation"
OptDMLHintGroupByRequiresConditionsDesc = "OptDMLHintGroupByRequiresConditionsDesc"
OptDMLHintInNullOnlyFalseAnnotation = "OptDMLHintInNullOnlyFalseAnnotation"
OptDMLHintInNullOnlyFalseDesc = "OptDMLHintInNullOnlyFalseDesc"
OptDMLHintUseTruncateInsteadOfDeleteAnnotation = "OptDMLHintUseTruncateInsteadOfDeleteAnnotation"
OptDMLHintUseTruncateInsteadOfDeleteDesc = "OptDMLHintUseTruncateInsteadOfDeleteDesc"
OptDMLNotRecommendHavingAnnotation = "OptDMLNotRecommendHavingAnnotation"
OptDMLNotRecommendHavingDesc = "OptDMLNotRecommendHavingDesc"
OptDMLNotRecommendInAnnotation = "OptDMLNotRecommendInAnnotation"
OptDMLNotRecommendInDesc = "OptDMLNotRecommendInDesc"
OptDMLNotRecommendNotWildcardLikeAnnotation = "OptDMLNotRecommendNotWildcardLikeAnnotation"
OptDMLNotRecommendNotWildcardLikeDesc = "OptDMLNotRecommendNotWildcardLikeDesc"
OptDMLRuleAllSubqueryRewriteAnnotation = "OptDMLRuleAllSubqueryRewriteAnnotation"
OptDMLRuleAllSubqueryRewriteDesc = "OptDMLRuleAllSubqueryRewriteDesc"
OptDMLRuleDiffOrderingSpecTypeWarningAnnotation = "OptDMLRuleDiffOrderingSpecTypeWarningAnnotation"
OptDMLRuleDiffOrderingSpecTypeWarningDesc = "OptDMLRuleDiffOrderingSpecTypeWarningDesc"
OptDMLRuleDistinctEliminationRewriteAnnotation = "OptDMLRuleDistinctEliminationRewriteAnnotation"
OptDMLRuleDistinctEliminationRewriteDesc = "OptDMLRuleDistinctEliminationRewriteDesc"
OptDMLRuleExists2JoinRewriteAnnotation = "OptDMLRuleExists2JoinRewriteAnnotation"
OptDMLRuleExists2JoinRewriteDesc = "OptDMLRuleExists2JoinRewriteDesc"
OptDMLRuleFilterPredicatePushDownRewriteAnnotation = "OptDMLRuleFilterPredicatePushDownRewriteAnnotation"
OptDMLRuleFilterPredicatePushDownRewriteDesc = "OptDMLRuleFilterPredicatePushDownRewriteDesc"
OptDMLRuleGroupingFromDiffTablesRewriteAnnotation = "OptDMLRuleGroupingFromDiffTablesRewriteAnnotation"
OptDMLRuleGroupingFromDiffTablesRewriteDesc = "OptDMLRuleGroupingFromDiffTablesRewriteDesc"
OptDMLRuleJoinEliminationRewriteAnnotation = "OptDMLRuleJoinEliminationRewriteAnnotation"
OptDMLRuleJoinEliminationRewriteDesc = "OptDMLRuleJoinEliminationRewriteDesc"
OptDMLRuleLimitClausePushDownRewriteAnnotation = "OptDMLRuleLimitClausePushDownRewriteAnnotation"
OptDMLRuleLimitClausePushDownRewriteDesc = "OptDMLRuleLimitClausePushDownRewriteDesc"
OptDMLRuleLimitClausePushDownRewriteParams1 = "OptDMLRuleLimitClausePushDownRewriteParams1"
OptDMLRuleMaxMinAggRewriteAnnotation = "OptDMLRuleMaxMinAggRewriteAnnotation"
OptDMLRuleMaxMinAggRewriteDesc = "OptDMLRuleMaxMinAggRewriteDesc"
OptDMLRuleMoveOrder2LeadingRewriteAnnotation = "OptDMLRuleMoveOrder2LeadingRewriteAnnotation"
OptDMLRuleMoveOrder2LeadingRewriteDesc = "OptDMLRuleMoveOrder2LeadingRewriteDesc"
OptDMLRuleNPERewriteAnnotation = "OptDMLRuleNPERewriteAnnotation"
OptDMLRuleNPERewriteDesc = "OptDMLRuleNPERewriteDesc"
OptDMLRuleOrCond4SelectRewriteAnnotation = "OptDMLRuleOrCond4SelectRewriteAnnotation"
OptDMLRuleOrCond4SelectRewriteDesc = "OptDMLRuleOrCond4SelectRewriteDesc"
OptDMLRuleOrCond4UpDeleteRewriteAnnotation = "OptDMLRuleOrCond4UpDeleteRewriteAnnotation"
OptDMLRuleOrCond4UpDeleteRewriteDesc = "OptDMLRuleOrCond4UpDeleteRewriteDesc"
OptDMLRuleOrderEliminationInSubqueryRewriteAnnotation = "OptDMLRuleOrderEliminationInSubqueryRewriteAnnotation"
OptDMLRuleOrderEliminationInSubqueryRewriteDesc = "OptDMLRuleOrderEliminationInSubqueryRewriteDesc"
OptDMLRuleOrderingFromDiffTablesRewriteAnnotation = "OptDMLRuleOrderingFromDiffTablesRewriteAnnotation"
OptDMLRuleOrderingFromDiffTablesRewriteDesc = "OptDMLRuleOrderingFromDiffTablesRewriteDesc"
OptDMLRuleOuter2InnerConversionRewriteAnnotation = "OptDMLRuleOuter2InnerConversionRewriteAnnotation"
OptDMLRuleOuter2InnerConversionRewriteDesc = "OptDMLRuleOuter2InnerConversionRewriteDesc"
OptDMLRuleProjectionPushdownRewriteAnnotation = "OptDMLRuleProjectionPushdownRewriteAnnotation"
OptDMLRuleProjectionPushdownRewriteDesc = "OptDMLRuleProjectionPushdownRewriteDesc"
OptDMLRuleQualifierSubQueryRewriteAnnotation = "OptDMLRuleQualifierSubQueryRewriteAnnotation"
OptDMLRuleQualifierSubQueryRewriteDesc = "OptDMLRuleQualifierSubQueryRewriteDesc"
OptDMLRuleQueryFoldingRewriteAnnotation = "OptDMLRuleQueryFoldingRewriteAnnotation"
OptDMLRuleQueryFoldingRewriteDesc = "OptDMLRuleQueryFoldingRewriteDesc"
OptDMLRuleSATTCRewriteAnnotation = "OptDMLRuleSATTCRewriteAnnotation"
OptDMLRuleSATTCRewriteDesc = "OptDMLRuleSATTCRewriteDesc"
OptDMLWhereExistNullAnnotation = "OptDMLWhereExistNullAnnotation"
OptDMLWhereExistNullDesc = "OptDMLWhereExistNullDesc"
OptOracle500Annotation = "OptOracle500Annotation"
OptOracle500Desc = "OptOracle500Desc"
OptOracle501Annotation = "OptOracle501Annotation"
OptOracle501Desc = "OptOracle501Desc"
OptOracle502Annotation = "OptOracle502Annotation"
OptOracle502Desc = "OptOracle502Desc"
OptOracle503Annotation = "OptOracle503Annotation"
OptOracle503Desc = "OptOracle503Desc"
OptOracle504Annotation = "OptOracle504Annotation"
OptOracle504Desc = "OptOracle504Desc"
OptOracle505Annotation = "OptOracle505Annotation"
OptOracle505Desc = "OptOracle505Desc"
OptOracle506Annotation = "OptOracle506Annotation"
OptOracle506Desc = "OptOracle506Desc"
OptOracle507Annotation = "OptOracle507Annotation"
OptOracle507Desc = "OptOracle507Desc"
OptOracle508Annotation = "OptOracle508Annotation"
OptOracle508Desc = "OptOracle508Desc"
OptOracle509Annotation = "OptOracle509Annotation"
OptOracle509Desc = "OptOracle509Desc"
OptOracle510Annotation = "OptOracle510Annotation"
OptOracle510Desc = "OptOracle510Desc"
OptOracle511Annotation = "OptOracle511Annotation"
OptOracle511Desc = "OptOracle511Desc"
OptOracle512Annotation = "OptOracle512Annotation"
OptOracle512Desc = "OptOracle512Desc"
OptOracle513Annotation = "OptOracle513Annotation"
OptOracle513Desc = "OptOracle513Desc"
OptOracle514Annotation = "OptOracle514Annotation"
OptOracle514Desc = "OptOracle514Desc"
OptOracle515Annotation = "OptOracle515Annotation"
OptOracle515Desc = "OptOracle515Desc"
OptOracle516Annotation = "OptOracle516Annotation"
OptOracle516Desc = "OptOracle516Desc"
OptOracle517Annotation = "OptOracle517Annotation"
OptOracle517Desc = "OptOracle517Desc"
OptOracle518Annotation = "OptOracle518Annotation"
OptOracle518Desc = "OptOracle518Desc"
OptOracle519Annotation = "OptOracle519Annotation"
OptOracle519Desc = "OptOracle519Desc"
OptOracle520Annotation = "OptOracle520Annotation"
OptOracle520Desc = "OptOracle520Desc"
OptOracle521Annotation = "OptOracle521Annotation"
OptOracle521Desc = "OptOracle521Desc"
OptOracle522Annotation = "OptOracle522Annotation"
OptOracle522Desc = "OptOracle522Desc"
OptOracle523Annotation = "OptOracle523Annotation"
OptOracle523Desc = "OptOracle523Desc"
OptOracle524Annotation = "OptOracle524Annotation"
OptOracle524Desc = "OptOracle524Desc"
OptOracle525Annotation = "OptOracle525Annotation"
OptOracle525Desc = "OptOracle525Desc"
OptOracle526Annotation = "OptOracle526Annotation"
OptOracle526Desc = "OptOracle526Desc"
OptOracle527Annotation = "OptOracle527Annotation"
OptOracle527Desc = "OptOracle527Desc"
PTOSCAvoidNoDefaultValueOnNotNullColumn = "[osc]Non-null fields must have default values, otherwise pt-online-schema-change will fail to execute"
PTOSCAvoidRenameTable = "[osc]Pt-online-schema-change does not support renaming tables using rename table"
PTOSCAvoidUniqueIndex = "[osc]Adding a unique key using pt-online-schema-change may cause data loss. insert ignore was used when data was migrated to a new table"
PTOSCNoUniqueIndexOrPrimaryKey = "[osc]At least one primary key or unique key index is required to use pt-online-schema-change"
ParseDDLError = "Failed to parse the create table statement. some online audit rules may be invalid. please confirm manually"
PrefixIndexAdviceFormat = "Index suggestion | the sql uses prefix fuzzy matching. when the data volume is large, you can create a reverse function index"
PrimaryKeyExistMessage = "Primary key already exists, cannot be added again"
PrimaryKeyNotExistMessage = "No primary key exists currently, cannot perform deletion"
RuleTypeDDLConvention = "DDL convention"
RuleTypeDMLConvention = "DML convention"
RuleTypeGlobalConfig = "Global configuration"
RuleTypeIndexInvalidation = "Index invalidation"
RuleTypeIndexOptimization = "Index optimization"
RuleTypeIndexingConvention = "Indexing convention"
RuleTypeNamingConvention = "Naming convention"
RuleTypeUsageSuggestion = "Usage suggestion"
SchemaExistMessage = "Schema %s already exists"
SchemaNotExistMessage = "Schema %s does not exist"
TableExistMessage = "Table %s already exists"
TableNotExistMessage = "Table %s does not exist"
ThreeStarIndexAdviceFormat = "Index suggestion | according to the three-star index design specification, it is recommended to add %s index to table %s: [%s]"
UnsupportedSyntaxError = "Syntax error or the parser does not support it. please confirm the sql correctness manually"
