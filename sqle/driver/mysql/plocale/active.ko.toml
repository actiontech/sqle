AdvisorIndexTypeComposite = "복합"
AdvisorIndexTypeSingle = "단일 컬럼"
AllCheckPrepareStatementPlaceholdersAnnotation = "바인드 변수를 과도하게 사용하면 쿼리 복잡성이 증가하여 쿼리 성능이 저하될 수 있습니다. 또한 유지보수 비용도 증가합니다. 기본 임계값: 100"
AllCheckPrepareStatementPlaceholdersDesc = "바인드 변수의 수는 임계값을 초과하지 않아야 합니다"
AllCheckPrepareStatementPlaceholdersMessage = "바인드 변수의 수는 %v이며, 설정된 임계값 %v를 초과하지 않아야 합니다"
AllCheckPrepareStatementPlaceholdersParams1 = "바인드 변수의 최대 수"
AnalysisDescCardinality = "구분도"
AnalysisDescCharacterSetName = "문자 집합"
AnalysisDescColumnComment = "컬럼 주석"
AnalysisDescColumnDefault = "기본값"
AnalysisDescColumnKey = "컬럼 인덱스"
AnalysisDescColumnName = "컬럼 이름"
AnalysisDescColumnType = "컬럼 타입"
AnalysisDescComment = "주석"
AnalysisDescExtra = "추가 정보"
AnalysisDescIndexType = "인덱스 타입"
AnalysisDescIsNullable = "NULL 허용 여부"
AnalysisDescKeyName = "인덱스 이름"
AnalysisDescSeqInIndex = "컬럼 순서"
AnalysisDescUnique = "고유성"
AnonymousMark = "(익명)"
AuditResultMsgExcludedSQL = "감사 SQL 예외"
AuditResultMsgWhiteList = "화이트리스트"
CheckInvalidError = "사전 검사 실패"
CheckInvalidErrorFormat = "사전 검사 실패: %v"
ColumnExistMessage = "컬럼 %s가 이미 존재합니다"
ColumnIsAmbiguousMessage = "컬럼 %s가 모호합니다"
ColumnNotExistMessage = "컬럼 %s가 존재하지 않습니다"
ColumnsValuesNotMatchMessage = "지정된 값의 수가 컬럼 수와 일치하지 않습니다"
ConfigDDLGhostMinSizeAnnotation = "이 규칙을 활성화하면 대용량 테이블에 대해 gh-ost 도구를 자동으로 사용하여 온라인 테이블 수정을 수행합니다. 대용량 테이블에 직접 DDL 변경을 수행하면 긴 테이블 잠금이 발생하여 비즈니스 지속성에 영향을 줄 수 있습니다. 대용량 테이블을 정의하는 특정 임계값은 비즈니스 요구에 따라 조정할 수 있으며, 기본값은 1024입니다."
ConfigDDLGhostMinSizeDesc = "테이블 크기(MB)가 지정된 크기를 초과할 때 gh-ost를 사용하여 SQL을 실행"
ConfigDDLGhostMinSizeParams1 = "테이블 공간 크기(MB)"
ConfigDDLOSCMinSizeAnnotation = "이 규칙을 활성화하면 pt-osc 도구를 사용하여 대용량 테이블 DDL 문에 대한 재작성 제안을 제공합니다 【제안에 따라 명령을 수동으로 실행해야 하며, 자동 실행은 향후 지원 예정】. 대용량 테이블에 직접 DDL 변경을 수행하면 긴 테이블 잠금이 발생하여 비즈니스 지속성에 영향을 줄 수 있습니다. 대용량 테이블을 정의하는 특정 임계값은 비즈니스 요구에 따라 조정할 수 있으며, 기본값은 1024입니다."
ConfigDDLOSCMinSizeDesc = "테이블 공간(MB)이 지정된 크기를 초과할 때 감사 중에 osc 재작성 제안 출력"
ConfigDDLOSCMinSizeParams1 = "테이블 공간 크기(MB)"
ConfigDMLExplainPreCheckEnableAnnotation = "EXPLAIN을 사용하여 실행할 DML이 올바른지 확인하고 사전에 문장 오류를 감지하여 실행 성공률을 향상시킵니다."
ConfigDMLExplainPreCheckEnableDesc = "EXPLAIN을 사용하여 사전 검사 기능 강화"
ConfigDMLRollbackMaxRowsAnnotation = "대규모 트랜잭션 롤백은 데이터베이스 성능에 쉽게 영향을 미치고 비즈니스 변동을 일으킬 수 있습니다. 특정 규칙 임계값은 비즈니스 요구에 따라 조정할 수 있으며, 기본값은 1000입니다."
ConfigDMLRollbackMaxRowsDesc = "영향을 받는 예상 행 수가 지정된 값을 초과하는 경우 DML 문에서 롤백하지 않음"
ConfigDMLRollbackMaxRowsParams1 = "영향을 받는 최대 행 수"
ConfigOptimizeIndexEnabledAnnotation = "이 규칙을 통해 인덱스 최적화 제안을 활성화하고, 인덱스 최적화 제안의 동작을 정의하는 두 가지 구성 매개변수를 제공합니다. 1. 최소 컬럼 구분도 임계값(백분율): 현재 테이블에서 컬럼이 인덱스로 사용되지 않을 최소 컬럼 구분도를 구성합니다. 2. 복합 인덱스의 최대 컬럼 수: 제안된 복합 인덱스가 다른 SQL 표준을 위반하지 않도록 복합 인덱스 제안의 최대 컬럼 수를 제한합니다."
ConfigOptimizeIndexEnabledDesc = "인덱스 생성 제안"
ConfigOptimizeIndexEnabledParams1 = "최소 컬럼 구분도 임계값(백분율)"
ConfigOptimizeIndexEnabledParams2 = "복합 인덱스의 최대 컬럼 수"
ConfigSQLIsExecutedAnnotation = "이 규칙을 활성화하여 감사 후 시나리오를 지원하고, 이후 수집된 DDL 및 DML 문은 더 이상 실행 여부를 확인하지 않습니다. 예를 들어, 라이브러리 테이블 메타데이터 스캐닝 작업은 이 규칙을 활성화할 수 있습니다."
ConfigSQLIsExecutedDesc = "온라인 감사 모드 비활성화"
DDLAvoidEventAnnotation = "이벤트를 사용하면 데이터베이스 유지 관리 난이도와 의존성이 증가하고 보안 문제도 발생합니다."
DDLAvoidEventDesc = "이벤트를 사용하지 마세요"
DDLAvoidEventMessage = "이벤트를 사용하지 마세요"
DDLAvoidFullTextAnnotation = "전문 인덱스를 사용하면 저장 오버헤드가 증가하고 쓰기 작업 성능에 일정한 영향을 미칩니다."
DDLAvoidFullTextDesc = "전문 인덱스를 사용하지 마세요"
DDLAvoidFullTextMessage = "전문 인덱스를 사용하지 마세요"
DDLAvoidGeometryAnnotation = "공간 필드와 공간 인덱스를 사용하면 저장 요구사항이 증가하고 데이터베이스 성능에 일정한 영향을 미칩니다"
DDLAvoidGeometryDesc = "공간 필드와 공간 인덱스 사용을 피하세요"
DDLAvoidGeometryMessage = "공간 필드와 공간 인덱스 사용을 피하세요"
DDLAvoidTextAnnotation = "TEXT 타입 필드를 원본 테이블에서 분리하여 다른 테이블에 저장하면 데이터베이스 성능과 쿼리 속도를 향상시키고 불필요한 I/O 작업을 줄일 수 있습니다."
DDLAvoidTextDesc = "TEXT 타입 필드를 원본 테이블에서 분리하여 원본 테이블의 기본 키와 함께 별도로 저장하는 것이 좋습니다"
DDLAvoidTextMessage = "필드: %v는 TEXT 타입입니다. 원본 테이블에서 분리하여 원본 테이블의 기본 키와 함께 별도로 저장하는 것이 좋습니다"
DDLCheckAllIndexNotNullConstraintAnnotation = "모든 인덱스 필드가 not null로 제약되지 않았습니다. 테이블 인덱스 계획의 합리성을 확인하세요."
DDLCheckAllIndexNotNullConstraintDesc = "최소한 하나의 인덱스에 not null 제약 조건을 추가하세요"
DDLCheckAllIndexNotNullConstraintMessage = "최소한 하나의 인덱스에 not null 제약 조건을 추가하세요"
DDLCheckAlterTableNeedMergeAnnotation = "여러 번의 TABLE REBUILD로 인한 온라인 비즈니스 소비와 영향을 피하세요"
DDLCheckAlterTableNeedMergeDesc = "동일한 테이블에 대한 여러 수정 문이 있습니다. 하나의 ALTER 문으로 병합하는 것이 좋습니다"
DDLCheckAlterTableNeedMergeMessage = "이 테이블에 대한 수정 문이 이미 있습니다. 하나의 ALTER 문으로 병합하는 것이 좋습니다"
DDLCheckAutoIncrementAnnotation = "테이블 생성 시 AUTO_INCREMENT를 0으로 설정하면 자동 증가가 1부터 시작되어 데이터 공백을 방지할 수 있습니다. 예를 들어, 테이블 구조 DDL을 내보낼 때 테이블 구조의 AUTO_INCREMENT는 일반적으로 현재 자동 증가 값입니다. 테이블 생성 시 AUTO_INCREMENT를 0으로 설정하지 않으면 이 DDL을 통해 테이블을 생성할 때 자동 증가 값이 의미 없는 숫자부터 시작됩니다."
DDLCheckAutoIncrementDesc = "테이블의 초기 AUTO_INCREMENT 값은 0으로 설정하는 것이 좋습니다"
DDLCheckAutoIncrementFieldNumAnnotation = "MySQL InnoDB, MyISAM 엔진은 여러 자동 증가 필드를 허용하지 않습니다. 여러 자동 증가 필드를 설정하면 배포 실패가 발생합니다."
DDLCheckAutoIncrementFieldNumDesc = "테이블 생성 시 하나의 자동 증가 필드만 설정할 수 있습니다"
DDLCheckAutoIncrementFieldNumMessage = "테이블 생성 시 하나의 자동 증가 필드만 설정할 수 있습니다"
DDLCheckAutoIncrementMessage = "테이블의 초기 AUTO_INCREMENT 값은 0으로 설정하는 것이 좋습니다"
DDLCheckBigintInsteadOfDecimalAnnotation = "CPU는 DECIMAL에 대한 직접 연산을 지원하지 않으며, MySQL 자체만이 DECIMAL의 고정밀 계산을 구현하지만 계산 비용이 높고 동일한 범위의 값을 저장할 때 차지하는 공간도 더 많습니다. BIGINT를 DECIMAL 대신 사용하면 소수점 자릿수에 따라 해당 배수를 곱하여 정밀한 부동 소수점 저장 및 계산을 달성할 수 있어 DECIMAL 계산의 높은 비용을 피할 수 있습니다"
DDLCheckBigintInsteadOfDecimalDesc = "DECIMAL 대신 BIGINT 타입 사용"
DDLCheckBigintInsteadOfDecimalMessage = "컬럼 %s에 DECIMAL 대신 BIGINT 타입을 사용하는 것이 좋습니다"
DDLCheckCharLengthAnnotation = "너무 길거나 많은 varchar, char 필드를 사용하면 비즈니스 로직의 복잡성이 증가할 수 있습니다. 필드의 평균 길이가 너무 크면 더 많은 저장 공간을 차지하게 됩니다."
DDLCheckCharLengthDesc = "char, varchar 타입 필드의 총 문자 길이가 임계값을 초과하는 것을 금지"
DDLCheckCharLengthMessage = "char, varchar 타입 필드의 총 문자 길이가 임계값 %v를 초과하는 것을 금지"
DDLCheckCharLengthParams1 = "문자 길이"
DDLCheckColumnBlobDefaultIsNotNullAnnotation = "엄격한 SQL_MODE 모드에서는 BLOB 및 TEXT 타입에 기본값을 설정할 수 없습니다. 값을 지정하지 않고 데이터를 삽입하면 필드는 NULL로 설정됩니다"
DDLCheckColumnBlobDefaultIsNotNullDesc = "BLOB 및 TEXT 타입 필드의 기본값은 NULL만 가능"
DDLCheckColumnBlobDefaultIsNotNullMessage = "BLOB 및 TEXT 타입 필드의 기본값은 NULL만 가능"
DDLCheckColumnBlobNoticeAnnotation = "BLOB 또는 TEXT 타입은 많은 네트워크 및 IO 대역폭을 소비하며, 이 테이블에 대한 DML 작업은 매우 느려집니다"
DDLCheckColumnBlobNoticeDesc = "BLOB 또는 TEXT 타입 사용을 권장하지 않음"
DDLCheckColumnBlobNoticeMessage = "BLOB 또는 TEXT 타입 사용을 권장하지 않음"
DDLCheckColumnBlobWithNotNullAnnotation = "BLOB 및 TEXT 타입 필드는 기본값을 지정할 수 없습니다. 필드를 지정하지 않고 데이터를 삽입하면 기본값은 NULL입니다. NOT NULL 제약 조건을 추가하면 필드 값을 지정하지 않고 데이터를 쓰면 쓰기 실패가 발생합니다"
DDLCheckColumnBlobWithNotNullDesc = "BLOB 및 TEXT 타입 필드를 NOT NULL로 설정하는 것을 권장하지 않음"
DDLCheckColumnBlobWithNotNullMessage = "BLOB 및 TEXT 타입 필드를 NOT NULL로 설정하는 것을 권장하지 않음"
DDLCheckColumnCharLengthAnnotation = "VARCHAR는 가변 길이 필드로, 저장 공간을 절약하고 비교적 작은 필드에 대해 더 높은 검색 효율성을 가집니다"
DDLCheckColumnCharLengthDesc = "CHAR의 길이가 20보다 클 때는 VARCHAR 타입을 사용해야 함"
DDLCheckColumnCharLengthMessage = "CHAR의 길이가 20보다 클 때는 VARCHAR 타입을 사용해야 함"
DDLCheckColumnEnumNoticeAnnotation = "ENUM 타입은 SQL 표준이 아니므로 이식성이 떨어집니다. 나중에 enum 값을 수정하거나 추가하면 전체 테이블을 재구축해야 하며, 비용이 많이 들고 리터럴 값으로 정렬할 수 없습니다"
DDLCheckColumnEnumNoticeDesc = "ENUM 타입 사용을 권장하지 않음"
DDLCheckColumnEnumNoticeMessage = "ENUM 타입 사용을 권장하지 않음"
DDLCheckColumnNotNULLAnnotation = "테이블 필드에는 NOT NULL 제약 조건을 설정하는 것이 좋습니다. 이는 데이터 무결성을 보장하고, null 값 삽입을 방지하며, 쿼리 정확성을 향상시킵니다."
DDLCheckColumnNotNULLDesc = "테이블 필드에는 NOT NULL 제약 조건을 설정하는 것이 좋습니다"
DDLCheckColumnNotNULLMessage = "필드 %v에 NOT NULL 제약 조건을 설정하는 것이 좋습니다"
DDLCheckColumnQuantityAnnotation = "OLTP 시스템에서 넓은 테이블 설계를 피하세요. 이는 나중에 성능에 큰 영향을 미칩니다. 특정 규칙 임계값은 비즈니스 요구에 따라 조정할 수 있으며, 기본값은 40입니다."
DDLCheckColumnQuantityDesc = "테이블의 컬럼 수가 임계값을 초과하지 않는 것이 좋습니다"
DDLCheckColumnQuantityInPKAnnotation = "기본 키에 너무 많은 컬럼이 있으면 보조 인덱스가 더 많은 공간을 차지하고 인덱스 유지 관리 비용이 증가합니다. 특정 규칙 임계값은 비즈니스 요구에 따라 조정할 수 있으며, 기본값은 2입니다."
DDLCheckColumnQuantityInPKDesc = "기본 키에 포함된 컬럼 수가 임계값을 초과하지 않는 것이 좋습니다"
DDLCheckColumnQuantityInPKMessage = "기본 키에 포함된 컬럼 수가 임계값을 초과하지 않는 것이 좋습니다"
DDLCheckColumnQuantityInPKParams1 = "최대 컬럼 수"
DDLCheckColumnQuantityMessage = "테이블의 컬럼 수가 임계값을 초과하지 않는 것이 좋습니다"
DDLCheckColumnQuantityParams1 = "최대 컬럼 수"
DDLCheckColumnSetNoticeAnnotation = "SET의 수정은 컬럼의 재정의가 필요하며, 나중에 수정하는 데 비용이 많이 듭니다. 비즈니스 계층에서 구현하는 것이 좋습니다"
DDLCheckColumnSetNoticeDesc = "SET 타입 사용을 권장하지 않음"
DDLCheckColumnSetNoticeMessage = "SET 타입 사용을 권장하지 않음"
DDLCheckColumnTimestampWithoutDefaultAnnotation = "모든 0 날짜 형식이 비즈니스 기대와 일치하지 않는 상황을 피하기 위해 TIMESTAMP에 기본값을 추가하세요"
DDLCheckColumnTimestampWithoutDefaultDesc = "TIMESTAMP 타입의 컬럼에는 반드시 기본값을 추가해야 합니다"
DDLCheckColumnTimestampWithoutDefaultMessage = "TIMESTAMP 타입의 컬럼에는 반드시 기본값을 추가해야 합니다"
DDLCheckColumnTypeIntegerAnnotation = "INT(M) 또는 BIGINT(M)에서 M은 최대 표시 너비를 나타내며, 최대 값 저장 너비는 각각 10, 20입니다. INT(10) 또는 BIGINT(20)을 사용하면 가능한 표시 잘림을 방지할 수 있습니다"
DDLCheckColumnTypeIntegerDesc = "정수 정의에는 INT(10) 또는 BIGINT(20) 사용을 권장합니다"
DDLCheckColumnTypeIntegerMessage = "정수 정의에는 INT(10) 또는 BIGINT(20) 사용을 권장합니다"
DDLCheckColumnWithoutCommentAnnotation = "컬럼에 주석을 추가하면 컬럼의 의미가 더 명확해지고 향후 유지 관리가 용이해집니다"
DDLCheckColumnWithoutCommentDesc = "컬럼에 주석을 추가하는 것이 좋습니다"
DDLCheckColumnWithoutCommentMessage = "컬럼에 주석을 추가하는 것이 좋습니다"
DDLCheckColumnWithoutDefaultAnnotation = "컬럼에 기본값을 추가하면 컬럼이 NULL일 때 쿼리에 미치는 영향을 방지할 수 있습니다"
DDLCheckColumnWithoutDefaultDesc = "자동 증가 컬럼과 대용량 필드 컬럼을 제외한 각 컬럼에는 반드시 기본값을 추가해야 합니다"
DDLCheckColumnWithoutDefaultMessage = "자동 증가 컬럼과 대용량 필드 컬럼을 제외한 각 컬럼에는 반드시 기본값을 추가해야 합니다"
DDLCheckCompositeIndexDistinctionAnnotation = "구분도가 높은 필드를 복합 인덱스의 앞쪽에 배치하면 인덱스의 쿼리 성능을 향상시킬 수 있습니다. 이는 데이터 범위를 더 빠르게 줄이고 검색 효율성을 향상시키기 때문입니다."
DDLCheckCompositeIndexDistinctionDesc = "구분도가 높은 필드를 복합 인덱스의 앞쪽에 배치하는 것이 좋습니다"
DDLCheckCompositeIndexDistinctionMessage = "구분도가 높은 필드를 복합 인덱스의 앞쪽에 배치하는 것이 좋습니다, %v"
DDLCheckCompositeIndexMaxAnnotation = "복합 인덱스는 인덱스 컬럼 수에 따라 해당 조합 인덱스를 생성합니다. 컬럼이 많을수록 더 많은 인덱스가 생성되며, 각 인덱스는 디스크 공간 오버헤드를 증가시키고 인덱스 유지 관리 오버헤드도 증가시킵니다. 특정 규칙 임계값은 비즈니스 요구에 따라 조정할 수 있으며, 기본값은 3입니다"
DDLCheckCompositeIndexMaxDesc = "복합 인덱스의 컬럼 수는 임계값을 초과하지 않는 것이 좋습니다"
DDLCheckCompositeIndexMaxMessage = "복합 인덱스의 컬럼 수는 %v를 초과하지 않는 것이 좋습니다"
DDLCheckCompositeIndexMaxParams1 = "인덱스 컬럼의 최대 수"
DDLCheckCreateFunctionAnnotation = "사용자 정의 함수는 유지 관리가 어렵고 의존성이 높아 SQL을 데이터베이스 간에 사용할 수 없게 만듭니다"
DDLCheckCreateFunctionDesc = "사용자 정의 함수 사용 금지"
DDLCheckCreateFunctionMessage = "사용자 정의 함수 사용 금지"
DDLCheckCreateProcedureAnnotation = "저장 프로시저는 프로그램을 디버깅하고 확장하기 어렵게 만들 수 있습니다. 다양한 데이터베이스에서 저장 프로시저의 구문이 매우 다르기 때문에 향후 데이터베이스 마이그레이션에 큰 어려움을 가져오고 버그 발생 가능성을 크게 증가시킵니다"
DDLCheckCreateProcedureDesc = "저장 프로시저 사용 금지"
DDLCheckCreateProcedureMessage = "저장 프로시저 사용 금지"
DDLCheckCreateTimeColumnAnnotation = "CREATE_TIME 필드를 사용하면 문제 추적 및 데이터 검색에 도움이 되며, 향후 데이터 수명주기 관리의 불편함을 방지할 수 있습니다. 기본값 CURRENT_TIMESTAMP는 시간의 정확성을 보장할 수 있습니다"
DDLCheckCreateTimeColumnDesc = "테이블 DDL에 생성 시간 필드를 포함하고 기본값은 CURRENT_TIMESTAMP로 설정하는 것이 좋습니다"
DDLCheckCreateTimeColumnMessage = "테이블 DDL에 %v 필드를 포함하고 기본값은 CURRENT_TIMESTAMP로 설정하는 것이 좋습니다"
DDLCheckCreateTimeColumnParams1 = "생성 시간 필드 이름"
DDLCheckCreateTriggerAnnotation = "트리거는 개발 및 유지 관리가 어렵고, 효율적으로 이식할 수 없으며, 복잡한 로직과 높은 동시성에서 비즈니스에 영향을 미치는 교착 상태가 발생하기 쉽습니다"
DDLCheckCreateTriggerDesc = "트리거 사용 금지"
DDLCheckCreateTriggerMessage = "트리거 사용 금지"
DDLCheckCreateViewAnnotation = "뷰의 쿼리 성능이 좋지 않고, 기본 테이블 구조가 변경되면 뷰를 유지 관리해야 합니다. 뷰의 가독성이 좋지 않고 복잡한 로직이 포함되어 있으면 유지 관리 비용이 증가합니다"
DDLCheckCreateViewDesc = "뷰 사용 금지"
DDLCheckCreateViewMessage = "뷰 사용 금지"
DDLCheckDatabaseCollationAnnotation = "이 규칙을 통해 전역 데이터베이스 콜레이션을 제한함으로써 예상치 못한 데이터베이스 콜레이션 생성을 방지하고 비즈니스 측면에서 예상치 못한 정렬 결과를 방지할 수 있습니다. 프로젝트의 데이터베이스 테이블은 통일된 문자 집합과 문자 집합 콜레이션을 사용하는 것이 좋습니다. 테이블 조인 쿼리의 일부 경우에서 필드의 문자 집합이나 콜레이션이 일치하지 않으면 인덱스 실패가 발생할 수 있으며 이를 찾기 어려울 수 있습니다"
DDLCheckDatabaseCollationDesc = "지정된 데이터베이스 콜레이션을 사용하는 것이 좋습니다"
DDLCheckDatabaseCollationMessage = "지정된 데이터베이스 콜레이션 %s를 사용하는 것이 좋습니다"
DDLCheckDatabaseCollationParams1 = "데이터베이스 콜레이션"
DDLCheckDatabaseSuffixAnnotation = "이 규칙을 구성하여 특정 비즈니스에 대한 데이터베이스 명명 규칙을 표준화할 수 있습니다. 특정 명명 규칙은 사용자 정의할 수 있습니다. 기본 프롬프트 값: _DB"
DDLCheckDatabaseSuffixDesc = "데이터베이스 이름에 고정 접미사를 사용하는 것이 좋습니다"
DDLCheckDatabaseSuffixMessage = "데이터베이스 이름이 \"%v\"로 끝나는 것이 좋습니다"
DDLCheckDatabaseSuffixParams1 = "데이터베이스 이름 접미사"
DDLCheckDecimalTypeColumnAnnotation = "부동 소수점 연산의 경우, DECIMAL이 더 높은 정확도를 가집니다"
DDLCheckDecimalTypeColumnDesc = "정밀한 부동 소수점 숫자에는 DECIMAL을 사용하세요"
DDLCheckDecimalTypeColumnMessage = "정밀한 부동 소수점 숫자에는 DECIMAL을 사용하세요"
DDLCheckFieldNotNUllMustContainDefaultValueAnnotation = "기본값이 없는 NOT NULL 필드가 있는 경우, 이러한 필드 없이 레코드를 삽입하면 오류가 발생합니다"
DDLCheckFieldNotNUllMustContainDefaultValueDesc = "NOT NULL 제약 조건이 있는 필드에 기본값을 설정하세요"
DDLCheckFieldNotNUllMustContainDefaultValueMessage = "NOT NULL 제약 조건이 있는 필드에 기본값을 설정하세요. 다음 필드가 규정을 준수하지 않습니다: %v"
DDLCheckFullWidthQuotationMarksAnnotation = "이 규칙을 활성화하여 MySQL이 중국어 전각 따옴표를 이름의 일부로 처리하여 예상치 못한 실행 결과가 발생하는 것을 방지하세요"
DDLCheckFullWidthQuotationMarksDesc = "DDL 문에서 중국어 전각 따옴표 사용을 피하세요"
DDLCheckFullWidthQuotationMarksMessage = "DDL 문에서 중국어 전각 따옴표 사용을 피하세요. 오타일 수 있습니다"
DDLCheckIndexCountAnnotation = "테이블에 생성된 각 인덱스는 저장 오버헤드를 증가시킵니다. 인덱스는 또한 삽입, 삭제 및 업데이트 작업에 대한 처리 오버헤드를 증가시킵니다. 너무 많거나, 불충분하거나, 잘못된 인덱스는 성능에 도움이 되지 않습니다. 특정 규칙 임계값은 비즈니스 요구에 따라 조정할 수 있습니다. 기본값: 5"
DDLCheckIndexCountDesc = "인덱스 수는 임계값을 초과하지 않아야 합니다"
DDLCheckIndexCountMessage = "인덱스 수는 %v를 초과하지 않아야 합니다"
DDLCheckIndexCountParams1 = "최대 인덱스 수"
DDLCheckIndexNotNullConstraintAnnotation = "인덱스 필드에 NOT NULL 제약 조건이 없으면 테이블 레코드와 인덱스 레코드가 완전히 매핑되지 않습니다."
DDLCheckIndexNotNullConstraintDesc = "인덱스 필드에는 NOT NULL 제약 조건이 있어야 합니다"
DDLCheckIndexNotNullConstraintMessage = "이러한 인덱스 필드(%v)에는 NOT NULL 제약 조건이 필요합니다"
DDLCheckIndexOptionAnnotation = "빠른 데이터 지역화를 위해 선택성이 높은 필드를 인덱스로 선택하세요. 낮은 선택성은 인덱스를 효과적으로 활용할 수 없으며 많은 데이터 페이지를 스캔해야 할 수 있어 SQL 속도가 느려집니다. 특정 규칙 임계값은 비즈니스 요구에 따라 조정할 수 있습니다. 기본값: 70"
DDLCheckIndexOptionDesc = "인덱스 필드는 임계값보다 큰 선택성을 가져야 합니다"
DDLCheckIndexOptionMessage = "인덱스 %v는 %v 퍼센트의 선택성 임계값을 초과하지 않습니다. 인덱스로 선택하는 것을 권장하지 않습니다"
DDLCheckIndexOptionParams1 = "선택성 (백분율)"
DDLCheckIndexPrefixAnnotation = "이 규칙을 구성하여 특정 비즈니스에 대한 인덱스 명명 규칙을 표준화할 수 있습니다. 특정 명명 규칙은 사용자 정의할 수 있습니다. 기본 프롬프트 값: idx_"
DDLCheckIndexPrefixDesc = "일반 인덱스에 고정 접두사 사용"
DDLCheckIndexPrefixMessage = "일반 인덱스에 \"%v\"를 접두사로 사용"
DDLCheckIndexPrefixParams1 = "인덱스 접두사"
DDLCheckIndexTooManyAnnotation = "단일 필드에 너무 많은 인덱스가 있습니다. 일반적으로 이러한 인덱스는 가치가 없습니다. 반대로 데이터 추가 및 삭제 성능이 저하되며, 특히 자주 업데이트되는 테이블에서 그렇습니다. 특정 규칙 임계값은 비즈니스 요구에 따라 조정할 수 있습니다. 기본값: 2"
DDLCheckIndexTooManyDesc = "단일 필드의 인덱스 수는 임계값을 초과하지 않아야 합니다"
DDLCheckIndexTooManyMessage = "필드 %v의 인덱스 수는 %v를 초과하지 않아야 합니다"
DDLCheckIndexTooManyParams1 = "단일 필드의 최대 인덱스 수"
DDLCheckIndexedColumnWithBlobAnnotation = "BLOB 타입은 대용량 필드 타입에 속하며, 이를 인덱스로 사용하면 많은 저장 공간을 차지합니다"
DDLCheckIndexedColumnWithBlobDesc = "인덱스에 BLOB 컬럼을 포함하지 마세요"
DDLCheckIndexedColumnWithBlobMessage = "인덱스에 BLOB 컬럼을 포함하지 마세요"
DDLCheckIndexesExistBeforeCreateConstraintsAnnotation = "제약 조건을 생성하기 전에 인덱스를 생성하세요. 제약 조건은 보조 인덱스에 적용하여 전체 테이블 스캔을 방지하고 성능을 향상시킬 수 있습니다"
DDLCheckIndexesExistBeforeCreateConstraintsDesc = "필드에 제약 조건을 생성하기 전에 인덱스를 생성하세요"
DDLCheckIndexesExistBeforeCreateConstraintsMessage = "필드에 제약 조건을 생성하기 전에 인덱스를 생성하세요"
DDLCheckIsExistLimitOffsetAnnotation = "예: LIMIT N OFFSET M 또는 LIMIT M,N. 오프셋 m이 너무 크면 MySQL이 먼저 m+n 데이터를 검색한 다음 처음 m 데이터를 버리기 때문에 쿼리 효율성이 매우 낮아집니다. 대용량 데이터가 있는 MySQL 테이블의 경우 LIMIT 페이지네이션을 사용하면 심각한 성능 문제가 발생합니다"
DDLCheckIsExistLimitOffsetDesc = "페이지네이션 쿼리에서 오프셋 사용을 피하세요"
DDLCheckIsExistLimitOffsetMessage = "페이지네이션 쿼리에서 오프셋 사용을 피하세요"
DDLCheckObjectNameIsUpperAndLowerLetterMixedAnnotation = "데이터베이스 객체 명명 규칙. 대소문자 혼합 형식을 사용하지 않는 것이 좋습니다. 코드 가독성을 향상시키기 위해 단어를 밑줄로 연결하는 것이 좋습니다"
DDLCheckObjectNameIsUpperAndLowerLetterMixedDesc = "데이터베이스 객체 이름은 대소문자가 혼합되지 않아야 합니다"
DDLCheckObjectNameIsUpperAndLowerLetterMixedMessage = "데이터베이스 객체 이름은 대소문자가 혼합되지 않아야 합니다. 다음 객체 이름이 규정을 준수하지 않습니다: %v"
DDLCheckObjectNameLengthAnnotation = "이 규칙을 구성하여 특정 비즈니스의 객체 명명 길이를 표준화할 수 있습니다. 특정 길이는 사용자 정의할 수 있습니다. 기본 최대 길이: 64. 이는 MySQL에서 허용하는 식별자의 최대 길이입니다"
DDLCheckObjectNameLengthDesc = "테이블 이름, 컬럼 이름 및 인덱스 이름의 길이는 임계값을 초과하지 않아야 합니다"
DDLCheckObjectNameLengthMessage = "테이블 이름, 컬럼 이름 및 인덱스 이름의 길이는 %v 바이트를 초과하지 않아야 합니다"
DDLCheckObjectNameLengthParams1 = "최대 길이(바이트)"
DDLCheckObjectNameUseCNAnnotation = "이 규칙을 구성하여 특정 비즈니스의 데이터 객체 명명 규칙을 표준화할 수 있습니다"
DDLCheckObjectNameUseCNDesc = "데이터베이스 객체 이름은 영문자, 밑줄 또는 숫자만 사용할 수 있습니다. 첫 글자는 영문이어야 합니다"
DDLCheckObjectNameUseCNMessage = "데이터베이스 객체 이름은 영문자, 밑줄 또는 숫자만 사용할 수 있습니다. 첫 글자는 영문이어야 합니다"
DDLCheckObjectNameUsingKeywordAnnotation = "이 규칙을 구성하여 충돌과 혼란을 피하기 위해 특정 비즈니스의 데이터 객체 명명 규칙을 표준화할 수 있습니다"
DDLCheckObjectNameUsingKeywordDesc = "데이터베이스 객체 이름은 예약어를 사용하는 것이 금지됩니다"
DDLCheckObjectNameUsingKeywordMessage = "데이터베이스 객체 이름은 예약어 %s를 사용하는 것이 금지됩니다"
DDLCheckPKNameAnnotation = "이 규칙을 구성하여 특정 비즈니스의 기본 키 명명 규칙을 표준화할 수 있습니다"
DDLCheckPKNameDesc = "기본 키 이름으로 \"PK_테이블_이름\" 사용을 제안합니다"
DDLCheckPKNameMessage = "기본 키 이름으로 \"PK_테이블_이름\" 사용을 제안합니다"
DDLCheckPKNotExistAnnotation = "기본 키는 데이터의 전역 고유성을 보장하여 데이터 검색 효율성을 향상시킵니다"
DDLCheckPKNotExistDesc = "테이블에는 반드시 기본 키가 있어야 합니다"
DDLCheckPKNotExistMessage = "테이블에는 반드시 기본 키가 있어야 합니다"
DDLCheckPKProhibitAutoIncrementAnnotation = "나중에 유지 관리하기가 상대적으로 불편하고, 전역 고유성을 달성하기 위해 데이터베이스 자동 증가 메커니즘에 과도하게 의존하며, 분할이 어렵고 기본 키 충돌이 발생하기 쉽습니다"
DDLCheckPKProhibitAutoIncrementDesc = "기본 키에 자동 증가 사용을 권장하지 않습니다"
DDLCheckPKProhibitAutoIncrementMessage = "기본 키에 자동 증가 사용을 권장하지 않습니다"
DDLCheckPKWithoutAutoIncrementAnnotation = "자동 증가 기본 키는 숫자 타입이 빠르고, 증분 성장하며, 적은 공간을 차지하고, 데이터 삽입 작업이 더 빠르며, 인덱스 유지 관리 비용 증가를 방지합니다"
DDLCheckPKWithoutAutoIncrementDesc = "기본 키에 자동 증가 사용을 제안합니다"
DDLCheckPKWithoutAutoIncrementMessage = "기본 키에 자동 증가 사용을 제안합니다"
DDLCheckPKWithoutBigintUnsignedAnnotation = "BIGINT UNSIGNED는 더 큰 값 범위를 가집니다. 오버플로우를 방지하기 위해 이 규칙을 활성화하는 것이 좋습니다"
DDLCheckPKWithoutBigintUnsignedDesc = "기본 키에 BIGINT unsigned 타입, 즉 BIGINT UNSIGNED 사용을 제안합니다"
DDLCheckPKWithoutBigintUnsignedMessage = "기본 키에 BIGINT unsigned 타입, 즉 BIGINT UNSIGNED 사용을 제안합니다"
DDLCheckPKWithoutIfNotExistsAnnotation = "새 테이블을 생성할 때 테이블이 이미 존재하는 경우, IF NOT EXISTS 없이 CREATE를 추가하면 SQL 실행 시 오류가 발생합니다. SQL 실제 실행 시 오류를 방지하기 위해 이 규칙을 활성화하는 것이 좋습니다"
DDLCheckPKWithoutIfNotExistsDesc = "반복 실행 시 오류가 발생하지 않도록 새 테이블 생성 시 IF NOT EXISTS 추가를 제안합니다"
DDLCheckPKWithoutIfNotExistsMessage = "반복 실행 시 오류가 발생하지 않도록 새 테이블 생성 시 IF NOT EXISTS 추가를 제안합니다"
DDLCheckRedundantIndexAnnotation = "MySQL은 중복 인덱스를 별도로 유지 관리해야 합니다. 중복 인덱스는 유지 관리 비용을 증가시키고, 최적화 시 옵티마이저가 비용을 하나씩 계산해야 하므로 쿼리 성능에 영향을 미칩니다"
DDLCheckRedundantIndexDesc = "중복 인덱스 생성을 권장하지 않습니다"
DDLCheckRedundantIndexMessage = "%v"
DDLCheckTableCharacterSetAnnotation = "이 규칙은 전역 데이터베이스 문자 집합을 제한하여 예상치 못한 문자 집합 생성을 방지하고 비즈니스 측면에서 \"깨진 코드\" 문제를 방지합니다. 프로젝트의 라이브러리 테이블은 통일된 문자 집합과 문자 집합 정렬을 사용하는 것이 좋습니다. 조인 쿼리의 일부 경우에서 필드의 문자 집합이나 정렬 규칙이 일치하지 않으면 인덱스 실패로 이어질 수 있으며 감지하기 어려울 수 있습니다"
DDLCheckTableCharacterSetDesc = "지정된 데이터베이스 문자 집합 사용을 제안합니다"
DDLCheckTableCharacterSetMessage = "%v 데이터베이스 문자 집합 사용을 제안합니다"
DDLCheckTableCharacterSetParams1 = "데이터베이스 문자 집합"
DDLCheckTableDBEngineAnnotation = "이 규칙을 구성하여 비즈니스에서 지정한 데이터베이스 엔진을 표준화할 수 있습니다. 특정 규칙은 사용자 정의할 수 있습니다. 기본값은 INNODB입니다. INNODB는 트랜잭션, 행 수준 잠금, 더 나은 복구 가능성 및 높은 동시성에서 더 나은 성능을 지원합니다"
DDLCheckTableDBEngineDesc = "지정된 데이터베이스 엔진 사용을 제안합니다"
DDLCheckTableDBEngineMessage = "%v 데이터베이스 엔진 사용을 제안합니다"
DDLCheckTableDBEngineParams1 = "데이터베이스 엔진"
DDLCheckTablePartitionAnnotation = "파티션 테이블은 물리적으로 파일 모음이지만 논리적으로는 하나의 테이블입니다. 파티션 간 쿼리는 효율성이 떨어질 수 있습니다. 대용량 데이터 관리를 위해 물리적 테이블 분할을 사용하는 것이 좋습니다"
DDLCheckTablePartitionDesc = "파티션 테이블 기능 사용을 권장하지 않음"
DDLCheckTablePartitionMessage = "파티션 테이블 기능 사용을 권장하지 않음"
DDLCheckTableRowsAnnotation = "테이블의 행 수가 임계값을 초과하면 테이블을 분할하여 데이터베이스 성능과 쿼리 속도를 향상시킬 수 있습니다"
DDLCheckTableRowsDesc = "테이블의 행 수가 임계값을 초과하면 테이블 분할을 권장합니다"
DDLCheckTableRowsMessage = "테이블의 행 수가 임계값을 초과하면 테이블 분할을 권장합니다"
DDLCheckTableRowsParams1 = "행 수(만 단위)"
DDLCheckTableSizeAnnotation = "대용량 테이블에서 DDL을 실행하면 시간이 오래 걸리고 부하가 높으며, 오랜 시간 잠금 리소스를 차지하여 데이터베이스 성능에 영향을 미칩니다. 특정 규칙 임계값은 비즈니스 요구에 따라 조정할 수 있습니다. 기본값은 1024입니다"
DDLCheckTableSizeDesc = "대용량 데이터가 있는 테이블에서 DDL 실행을 권장하지 않음"
DDLCheckTableSizeMessage = "DDL 실행을 위한 테이블 %v 공간은 %vMB를 초과하지 않는 것이 좋습니다"
DDLCheckTableSizeParams1 = "테이블 공간 크기(MB)"
DDLCheckTableWithoutCommentAnnotation = "테이블에 주석을 추가하면 테이블의 의미가 더 명확해지고 향후 유지 관리가 용이해집니다"
DDLCheckTableWithoutCommentDesc = "테이블에 주석 추가를 제안합니다"
DDLCheckTableWithoutCommentMessage = "테이블에 주석 추가를 제안합니다"
DDLCheckTransactionIsolationLevelAnnotation = "RC는 더티 리드를 방지하지만 팬텀 리드 문제를 해결하지 않습니다. RR을 사용하면 팬텀 리드를 방지할 수 있지만 갭 락의 도입으로 잠금 범위가 확장되어 동시성에 영향을 미치고 교착 상태를 쉽게 유발할 수 있습니다. 따라서 대부분의 비즈니스 시나리오에서 팬텀 리드 발생 확률이 낮으므로 RC가 기본적으로 비즈니스 요구를 충족할 수 있습니다"
DDLCheckTransactionIsolationLevelDesc = "트랜잭션 격리 수준을 RC로 설정하는 것을 제안합니다"
DDLCheckTransactionIsolationLevelMessage = "트랜잭션 격리 수준을 RC로 설정하는 것을 제안합니다"
DDLCheckUniqueIndexAnnotation = "이 규칙을 구성하여 비즈니스에서 지정한 UNIQUE 인덱스의 명명 규칙을 표준화할 수 있습니다"
DDLCheckUniqueIndexDesc = "UNIQUE 인덱스 이름으로 IDX_UK_테이블명_필드명 사용을 제안합니다"
DDLCheckUniqueIndexMessage = "UNIQUE 인덱스 이름으로 IDX_UK_테이블명_필드명 사용을 제안합니다"
DDLCheckUniqueIndexPrefixAnnotation = "이 규칙을 구성하여 비즈니스에서 지정한 UNIQUE 인덱스의 명명 규칙을 표준화할 수 있습니다. 특정 명명 규칙은 사용자 정의할 수 있습니다. 기본 힌트는 uniq_입니다"
DDLCheckUniqueIndexPrefixDesc = "UNIQUE 인덱스에 고정 접두사 사용을 제안합니다"
DDLCheckUniqueIndexPrefixMessage = "UNIQUE 인덱스에 \"%v\"를 접두사로 사용하는 것을 제안합니다"
DDLCheckUniqueIndexPrefixParams1 = "인덱스 접두사"
DDLCheckUpdateTimeColumnAnnotation = "업데이트 시간 필드를 사용하면 문제 추적, 데이터 검색 및 데이터 수명주기 관리에 도움이 됩니다. 기본값 UPDATE_TIME은 시간 정확성을 보장합니다."
DDLCheckUpdateTimeColumnDesc = "테이블 DDL에는 기본값이 CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP인 업데이트 시간 필드가 포함되어야 합니다"
DDLCheckUpdateTimeColumnMessage = "테이블 DDL에는 기본값이 CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP인 %v 필드가 포함되어야 합니다"
DDLCheckUpdateTimeColumnParams1 = "업데이트 시간 필드 이름"
DDLCheckVarcharSizeAnnotation = "MySQL은 인덱스된 컬럼의 크기를 제한하지 않으며, 인덱스 길이는 필드 길이를 기본값으로 사용합니다. VARCHAR 정의가 길수록 인덱스 저장 크기가 커집니다. 비즈니스 요구에 따라 임계값을 조정하세요. 기본값: 1024."
DDLCheckVarcharSizeDesc = "임계값보다 큰 VARCHAR 길이 정의는 권장하지 않습니다"
DDLCheckVarcharSizeMessage = "임계값보다 큰 VARCHAR 길이 정의는 권장하지 않습니다. 임계값은 %d입니다"
DDLCheckVarcharSizeParams1 = "최대 VARCHAR 길이"
DDLDisableAlterFieldUseFirstAndAfterAnnotation = "FIRST 및 AFTER ALTER 작업은 COPY TABLE을 사용하여 완료되며, 이는 비즈니스에 상당한 영향을 미칠 수 있습니다."
DDLDisableAlterFieldUseFirstAndAfterDesc = "ALTER 테이블 필드에 FIRST 또는 AFTER를 사용하지 마세요"
DDLDisableAlterFieldUseFirstAndAfterMessage = "ALTER 테이블 필드에 FIRST 또는 AFTER를 사용하지 마세요"
DDLDisableDropStatementAnnotation = "DROP은 DDL 작업으로, 데이터 변경 사항이 로그에 기록되지 않으며 롤백할 수 없습니다. 실수로 인한 삭제를 방지하기 위해 이 규칙을 활성화하는 것이 좋습니다."
DDLDisableDropStatementDesc = "인덱스를 제외한 DROP 작업을 사용하지 마세요"
DDLDisableDropStatementMessage = "인덱스를 제외한 DROP 작업을 사용하지 마세요"
DDLDisableFKAnnotation = "외래 키는 높은 동시성 시나리오에서 성능 병목 현상을 일으키고 교착 상태를 초래할 수 있습니다. 또한 유지 관리(분할, 마이그레이션)를 더 어렵게 만듭니다."
DDLDisableFKDesc = "외래 키를 사용하지 마세요"
DDLDisableFKMessage = "외래 키를 사용하지 마세요"
DDLDisableTypeTimestampAnnotation = "TIMESTAMP는 최대값 제한('2038-01-19 03:14:07' UTC)이 있으며 시간대 변환 문제를 일으킬 수 있습니다."
DDLDisableTypeTimestampDesc = "TIMESTAMP 필드를 사용하지 마세요"
DDLDisableTypeTimestampMessage = "TIMESTAMP 필드를 사용하지 마세요"
DDLHintDropColumnAnnotation = "삭제된 컬럼에 대한 비즈니스 로직 및 종속성이 완전히 제거되지 않았습니다. 컬럼을 삭제하면 프로그램 동작 이상(정상적으로 읽거나 쓸 수 없음)이 발생할 수 있습니다. 이 규칙을 활성화하면 컬럼 삭제가 고위험 작업임을 알려줍니다."
DDLHintDropColumnDesc = "컬럼을 삭제하지 마세요"
DDLHintDropColumnMessage = "컬럼을 삭제하지 마세요"
DDLHintDropForeignKeyAnnotation = "기존 제약 조건을 삭제하면 기존 비즈니스 로직에 영향을 미칩니다. 이 규칙을 활성화하면 외래 키 삭제가 고위험 작업임을 알려줍니다."
DDLHintDropForeignKeyDesc = "외래 키를 삭제하지 마세요"
DDLHintDropForeignKeyMessage = "외래 키를 삭제하지 마세요"
DDLHintDropPrimaryKeyAnnotation = "기존 제약 조건을 삭제하면 기존 비즈니스 로직에 영향을 미칩니다. 이 규칙을 활성화하면 기본 키 삭제가 고위험 작업임을 알려줍니다."
DDLHintDropPrimaryKeyDesc = "기본 키를 삭제하지 마세요"
DDLHintDropPrimaryKeyMessage = "기본 키를 삭제하지 마세요"
DDLHintUpdateTableCharsetWillNotUpdateFieldCharsetAnnotation = "테이블의 기본 문자 집합을 수정하면 이후 추가된 필드에만 영향을 미치고 기존 필드에는 영향을 미치지 않습니다. 테이블의 모든 필드의 문자 집합을 변경해야 하는 경우 이 규칙을 활성화하는 것이 좋습니다."
DDLHintUpdateTableCharsetWillNotUpdateFieldCharsetDesc = "테이블의 기본 문자 집합을 수정하지 마세요"
DDLHintUpdateTableCharsetWillNotUpdateFieldCharsetMessage = "테이블의 기본 문자 집합을 수정하지 마세요"
DDLNotAllowRenamingAnnotation = "RENAME/CHANGE 테이블 이름/컬럼 이름은 온라인 비즈니스 무중단 배포에 영향을 미칩니다. 이 작업이 필요한 경우 DBA가 수동으로 개입해야 합니다."
DDLNotAllowRenamingDesc = "RENAME 또는 CHANGE를 사용하여 테이블 또는 필드 이름을 수정하지 마세요"
DDLNotAllowRenamingMessage = "RENAME 또는 CHANGE를 사용하여 테이블 또는 필드 이름을 수정하지 마세요"
DDLRecommendTableColumnCharsetSameAnnotation = "통일된 문자 집합은 문자 집합 변환으로 인한 깨진 문자를 방지할 수 있습니다. 서로 다른 문자 집합을 비교하려면 변환이 필요하며, 이로 인해 인덱스 실패가 발생할 수 있습니다."
DDLRecommendTableColumnCharsetSameDesc = "컬럼과 테이블에 동일한 문자 집합을 사용하는 것이 좋습니다"
DDLRecommendTableColumnCharsetSameMessage = "컬럼과 테이블에 동일한 문자 집합을 사용하는 것이 좋습니다"
DMLAvoidWhereEqualNullAnnotation = "NULL은 SQL에서 특수한 값이며 일반 값과 비교할 수 없습니다. 예: column = NULL은 항상 거짓입니다. column에 null 값이 있더라도 쿼리되지 않으므로 column = NULL은 column is NULL로 작성해야 합니다."
DMLAvoidWhereEqualNullDesc = "WHERE 절에서 NULL 값을 다른 필드나 값과 비교하지 마세요"
DMLAvoidWhereEqualNullMessage = "WHERE 절에서 NULL 값을 다른 필드나 값과 비교하지 마세요"
DMLCheckAffectedRowsAnnotation = "DML 작업이 너무 많은 행에 영향을 미치면 더 많은 데이터를 스캔해야 하므로 쿼리 성능이 저하될 수 있습니다."
DMLCheckAffectedRowsDesc = "UPDATE/DELETE 작업이 임계값 이상의 행에 영향을 미치는 것을 권장하지 않습니다"
DMLCheckAffectedRowsMessage = "UPDATE/DELETE 작업이 임계값 이상의 행에 영향을 미치는 것을 권장하지 않습니다. 영향을 받는 행은 %v로, 설정된 임계값 %v를 초과합니다"
DMLCheckAffectedRowsParams1 = "최대 영향 행 수"
DMLCheckAggregateAnnotation = "쿼리 단순성, 높은 성능 및 데이터 일관성을 보장하기 위해 SQL 집계 함수를 사용하지 않는 것이 좋습니다."
DMLCheckAggregateDesc = "집계 함수를 사용하지 마세요"
DMLCheckAggregateMessage = "계산에 집계 함수를 사용하지 마세요"
DMLCheckAliasAnnotation = "테이블이나 컬럼의 별칭이 실제 이름과 같으면 쿼리를 구분하기 어렵게 만듭니다"
DMLCheckAliasDesc = "테이블이나 컬럼 이름과 동일한 별칭 사용을 권장하지 않습니다"
DMLCheckAliasMessage = "이러한 별칭(%v)은 컬럼 또는 테이블 이름과 동일합니다"
DMLCheckBatchInsertListsMaxAnnotation = "대규모 트랜잭션을 피하고 롤백이 비즈니스에 미치는 영향을 줄이세요. 특정 규칙 임계값은 비즈니스 요구에 따라 조정할 수 있습니다. 기본값: 100"
DMLCheckBatchInsertListsMaxDesc = "단일 INSERT 문에서 임계값 이상 삽입하지 않는 것이 좋습니다"
DMLCheckBatchInsertListsMaxMessage = "단일 INSERT 문에서 %v행 이상 삽입하지 않는 것이 좋습니다"
DMLCheckBatchInsertListsMaxParams1 = "삽입할 최대 행 수"
DMLCheckExplainAccessTypeAllAnnotation = "전체 테이블 스캔 시 스캔된 행 수는 성능 문제를 방지하기 위해 지정된 수를 초과하지 않아야 합니다. 특정 규칙 임계값은 비즈니스 요구에 따라 조정할 수 있습니다. 기본값: 10000. 0으로 설정하면 전체 테이블 스캔이 규칙을 트리거합니다"
DMLCheckExplainAccessTypeAllDesc = "전체 테이블 스캔 시 스캔된 행 수는 지정된 수를 초과하지 않아야 합니다(기본값: 10000)"
DMLCheckExplainAccessTypeAllMessage = "이 쿼리는 전체 테이블 스캔을 사용하며 %v행을 스캔합니다"
DMLCheckExplainAccessTypeAllParams1 = "스캔된 최대 행 수"
DMLCheckExplainExtraUsingFilesortAnnotation = "대용량 데이터의 경우, 파일 정렬은 SQL 성능이 낮다는 의미이며, OS 오버헤드를 증가시키고 데이터베이스 성능에 영향을 미칩니다"
DMLCheckExplainExtraUsingFilesortDesc = "파일 정렬 사용을 권장하지 않음"
DMLCheckExplainExtraUsingFilesortMessage = "파일 정렬 사용을 권장하지 않음"
DMLCheckExplainExtraUsingIndexForSkipScanAnnotation = "인덱스 스캔은 점프 스캔으로, 왼쪽 우선 일치 원칙을 따르지 않아 인덱스 사용 효율성을 감소시키고 쿼리 성능에 영향을 미칠 수 있습니다"
DMLCheckExplainExtraUsingIndexForSkipScanDesc = "테이블에서 인덱스 점프 스캔을 권장하지 않음"
DMLCheckExplainExtraUsingIndexForSkipScanMessage = "테이블에서 인덱스 점프 스캔을 권장하지 않음"
DMLCheckExplainExtraUsingTemporaryAnnotation = "대용량 데이터의 경우, 임시 테이블은 SQL 성능이 낮다는 의미이며, OS 오버헤드를 증가시키고 데이터베이스 성능에 영향을 미칩니다"
DMLCheckExplainExtraUsingTemporaryDesc = "임시 테이블 사용을 권장하지 않음"
DMLCheckExplainExtraUsingTemporaryMessage = "임시 테이블 사용을 권장하지 않음"
DMLCheckExplainFullIndexScanAnnotation = "대용량 데이터의 경우, 전체 인덱스 스캔은 SQL 성능에 심각한 영향을 미칩니다"
DMLCheckExplainFullIndexScanDesc = "테이블에 대한 전체 인덱스 스캔을 권장하지 않음"
DMLCheckExplainFullIndexScanMessage = "테이블에 대한 전체 인덱스 스캔을 권장하지 않음"
DMLCheckExplainUsingIndexAnnotation = "인덱스를 사용하면 SQL 쿼리의 성능을 크게 향상시킬 수 있습니다"
DMLCheckExplainUsingIndexDesc = "SQL 쿼리 조건은 인덱스를 사용해야 합니다"
DMLCheckExplainUsingIndexMessage = "인덱스를 사용하여 SQL 쿼리 성능을 최적화하는 것이 좋습니다"
DMLCheckFuzzySearchAnnotation = "전체 퍼지 검색이나 왼쪽 퍼지 검색을 사용하면 쿼리가 인덱스를 사용할 수 없게 되어 전체 테이블 스캔이 발생합니다"
DMLCheckFuzzySearchDesc = "전체 퍼지 검색이나 왼쪽 퍼지 검색 금지"
DMLCheckFuzzySearchMessage = "전체 퍼지 검색이나 왼쪽 퍼지 검색 금지"
DMLCheckHasJoinConditionAnnotation = "조인 조건을 지정하면 조인 작업의 정확성과 신뢰성을 보장할 수 있습니다. 조인 조건을 지정하지 않으면 조인 실패나 잘못된 조인이 발생할 수 있습니다."
DMLCheckHasJoinConditionDesc = "조인 작업에 조인 조건을 지정하는 것이 좋습니다"
DMLCheckHasJoinConditionMessage = "조인 작업에 조인 조건을 지정하는 것이 좋습니다. JOIN 필드에는 반드시 ON 조건이 있어야 합니다"
DMLCheckIfAfterUnionDistinctAnnotation = "UNION은 필드 순서에 따라 정렬하고 중복을 제거하며, UNION ALL은 단순히 두 결과를 병합하여 반환합니다. 효율성 측면에서 UNION ALL이 UNION보다 훨씬 빠릅니다. 병합된 두 결과에 중복 데이터가 포함될 수 있고 정렬이 필요하지 않은 경우, 이 규칙을 활성화하고 UNION 대신 UNION ALL을 사용하는 것이 좋습니다"
DMLCheckIfAfterUnionDistinctDesc = "UNION 대신 UNION ALL을 사용하는 것이 좋습니다"
DMLCheckIfAfterUnionDistinctMessage = "UNION 대신 UNION ALL을 사용하는 것이 좋습니다"
DMLCheckInQueryNumberAnnotation = "IN 값이 너무 많으면 쿼리가 전체 테이블 스캔을 수행하게 되어 MySQL 성능이 급격히 저하될 수 있습니다. 특정 규칙 임계값은 비즈니스 요구에 따라 조정할 수 있으며, 기본값은 50입니다"
DMLCheckInQueryNumberDesc = "WHERE 조건 내 IN 문의 매개변수 수는 임계값을 초과할 수 없습니다"
DMLCheckInQueryNumberMessage = "WHERE 조건 내 IN 문에 이미 %v개의 매개변수가 있으며, 임계값 %v를 초과하지 않는 것이 좋습니다"
DMLCheckInQueryNumberParams1 = "in 문의 최대 매개변수 수"
DMLCheckIndexSelectivityAnnotation = "SQL 실행 계획에서 사용되는 높은 인덱스 선택성을 보장하면 쿼리 성능을 향상시키고 쿼리 효율성을 최적화하는 데 도움이 됩니다."
DMLCheckIndexSelectivityDesc = "데이터베이스를 쿼리할 때 SQL 실행 계획에서 사용되는 인덱스 선택성이 임계값보다 큰지 확인하는 것이 좋습니다"
DMLCheckIndexSelectivityMessage = "인덱스: %v가 선택성 임계값: %v를 초과하지 않습니다. 임계값을 초과하는 인덱스를 사용하는 것이 좋습니다."
DMLCheckIndexSelectivityParams1 = "선택성 (백분율)"
DMLCheckInsertColumnsExistAnnotation = "테이블 구조가 변경되고 INSERT 요청이 컬럼 이름을 명시적으로 지정하지 않으면 데이터 삽입 불일치가 발생할 수 있습니다. 삽입된 결과가 비즈니스 기대와 일치하지 않는 것을 방지하기 위해 이 규칙을 활성화하는 것이 좋습니다"
DMLCheckInsertColumnsExistDesc = "INSERT 문은 COLUMN을 지정해야 합니다"
DMLCheckInsertColumnsExistMessage = "INSERT 문은 COLUMN을 지정해야 합니다"
DMLCheckInsertSelectAnnotation = "기본 트랜잭션 격리 수준에서 INSERT ... SELECT를 사용하면 쿼리된 테이블에 테이블 수준 잠금이 발생할 수 있습니다."
DMLCheckInsertSelectDesc = "INSERT ... SELECT 사용을 권장하지 않음"
DMLCheckInsertSelectMessage = "INSERT ... SELECT 사용을 권장하지 않음"
DMLCheckJoinFieldCharacterSetAndCollationAnnotation = "연결된 테이블 필드의 일관된 문자 집합과 콜레이션은 데이터 불일치와 쿼리 오류를 방지하고 연결 작업이 올바르게 실행되도록 보장합니다."
DMLCheckJoinFieldCharacterSetAndCollationDesc = "조인된 테이블 필드의 문자 집합과 콜레이션은 일관되어야 합니다"
DMLCheckJoinFieldCharacterSetAndCollationMessage = "조인된 테이블 필드의 문자 집합과 콜레이션은 일관되어야 합니다"
DMLCheckJoinFieldTypeAnnotation = "일관되지 않은 JOIN 필드 타입은 타입 불일치와 암시적 타입 변환을 초래할 수 있으며, 이로 인해 인덱스 실패가 발생할 수 있습니다. 인덱스 실패를 방지하기 위해 이 규칙을 활성화하는 것이 좋습니다."
DMLCheckJoinFieldTypeDesc = "JOIN 필드 타입을 일관되게 유지하는 것이 좋습니다"
DMLCheckJoinFieldTypeMessage = "JOIN 필드 타입을 일관되게 유지하는 것이 좋습니다. 그렇지 않으면 암시적 변환이 발생할 수 있습니다"
DMLCheckJoinFieldUseIndexAnnotation = "인덱스가 있는 JOIN 필드는 조인 작업의 성능과 쿼리 속도를 향상시킬 수 있습니다."
DMLCheckJoinFieldUseIndexDesc = "JOIN 필드에는 인덱스가 포함되어야 합니다"
DMLCheckJoinFieldUseIndexMessage = "JOIN 필드에는 인덱스가 포함되어야 합니다"
DMLCheckLimitMustExistAnnotation = "LIMIT 조건은 잘못된 SQL 작성 비용(잘못된 데이터 삭제)을 줄이고 동시에 긴 트랜잭션이 비즈니스에 영향을 미치는 것을 방지할 수 있습니다"
DMLCheckLimitMustExistDesc = "DELETE/UPDATE 문에 LIMIT 조건을 사용하는 것이 좋습니다"
DMLCheckLimitMustExistMessage = "DELETE/UPDATE 문에 LIMIT 조건을 사용하는 것이 좋습니다"
DMLCheckLimitOffsetNumAnnotation = "OFFSET은 결과 집합의 시작 위치를 지정하기 때문에, 시작 위치가 너무 크면 MySQL이 결과 집합을 반환하기 위해 더 많은 데이터를 처리해야 하며, 이로 인해 쿼리 성능이 저하될 수 있습니다."
DMLCheckLimitOffsetNumDesc = "LIMIT에 임계값보다 큰 오프셋을 사용하지 않는 것이 좋습니다"
DMLCheckLimitOffsetNumMessage = "LIMIT에 임계값보다 큰 오프셋을 사용하지 않는 것이 좋습니다. OFFSET=%v(임계값은 %v)"
DMLCheckLimitOffsetNumParams1 = "오프셋 크기"
DMLCheckMathComputationOrFuncOnIndexAnnotation = "인덱스된 컬럼에 수학적 연산을 수행하고 함수를 사용하면 인덱스 실패가 발생하여 전체 테이블 스캔이 발생하고 쿼리 성능에 영향을 미칩니다."
DMLCheckMathComputationOrFuncOnIndexDesc = "인덱스된 컬럼에 수학적 연산 및 함수 사용 금지"
DMLCheckMathComputationOrFuncOnIndexMessage = "인덱스된 컬럼에 수학적 연산 및 함수 사용 금지"
DMLCheckNeedlessFuncAnnotation = "이 규칙을 구성하여 비즈니스에서 금지해야 하는 내장 함수를 지정할 수 있습니다. 내장 함수를 사용하면 SQL이 인덱스를 사용하지 못하거나 예상치 못한 결과가 발생할 수 있습니다. 실제로 비활성화해야 하는 함수는 규칙 설정을 통해 구성할 수 있습니다."
DMLCheckNeedlessFuncDesc = "불필요한 내장 함수 사용 피하기"
DMLCheckNeedlessFuncMessage = "불필요한 내장 함수 %v 사용 피하기"
DMLCheckNeedlessFuncParams1 = "지정된 함수 집합(쉼표로 구분)"
DMLCheckNotEqualSymbolAnnotation = "'!='는 비표준 연산자이며, '<>'는 SQL의 표준 부등호 연산자입니다"
DMLCheckNotEqualSymbolDesc = "'!=' 대신 '<>' 사용을 권장합니다"
DMLCheckNotEqualSymbolMessage = "'!=' 대신 '<>' 사용을 권장합니다"
DMLCheckNumberOfJoinTablesAnnotation = "조인되는 테이블이 많을수록 드라이버 관계 조합이 많아지고 다양한 결과 집합의 실행 비용을 비교하는 비용이 높아져 SQL 쿼리 성능이 크게 저하됩니다. 특정 규칙 임계값은 비즈니스 요구에 따라 조정할 수 있으며, 기본값은 3입니다"
DMLCheckNumberOfJoinTablesDesc = "JOIN을 사용하여 테이블을 연결할 때 임계값을 초과하지 않는 것이 좋습니다"
DMLCheckNumberOfJoinTablesMessage = "JOIN을 사용하여 테이블을 연결할 때 %v 테이블을 초과하지 않는 것이 좋습니다"
DMLCheckNumberOfJoinTablesParams1 = "조인된 테이블의 최대 수"
DMLCheckSQLInjectionFuncAnnotation = "공격자는 SQL 인젝션을 통해 데이터베이스의 데이터에 무단으로 접근할 수 있으며, 이는 사용자 정보 도용 및 사용자 데이터 유출과 같은 보안 취약점을 초래합니다."
DMLCheckSQLInjectionFuncDesc = "일반적인 SQL 인젝션 함수 사용을 권장하지 않음"
DMLCheckSQLInjectionFuncMessage = "일반적인 SQL 인젝션 함수 사용을 권장하지 않음"
DMLCheckSQLLengthAnnotation = "긴 SQL은 가독성이 떨어지고 유지 관리가 어려우며 성능 문제가 발생하기 쉽습니다. 특정 규칙 임계값은 비즈니스 요구에 따라 조정할 수 있으며, 기본값은 1024입니다"
DMLCheckSQLLengthDesc = "긴 SQL을 여러 개의 간단한 SQL로 분할하는 것이 좋습니다"
DMLCheckSQLLengthMessage = "긴 SQL을 여러 개의 간단한 SQL로 분할하는 것이 좋습니다"
DMLCheckSQLLengthParams1 = "최대 SQL 길이"
DMLCheckSameTableJoinedMultipleTimesAnnotation = "단일 테이블을 여러 번 쿼리하면 쿼리 성능이 저하됩니다."
DMLCheckSameTableJoinedMultipleTimesDesc = "동일한 테이블을 여러 번 조인하는 것을 권장하지 않음"
DMLCheckSameTableJoinedMultipleTimesMessage = "테이블 %v가 여러 번 조인되었습니다"
DMLCheckScanRowsAnnotation = "필터 조건에는 기본 키나 인덱스를 포함해야 데이터베이스 쿼리의 시간 복잡성을 줄이고 쿼리 효율성을 향상시킬 수 있습니다."
DMLCheckScanRowsDesc = "스캔된 행 수가 임계값을 초과하면 필터 조건에 기본 키 또는 인덱스를 포함해야 합니다"
DMLCheckScanRowsMessage = "스캔된 행 수가 임계값을 초과하면 필터 조건에 기본 키 또는 인덱스를 포함해야 합니다"
DMLCheckScanRowsParams1 = "스캔된 행 수(만 단위)"
DMLCheckSelectForUpdateAnnotation = "SELECT FOR UPDATE는 쿼리 결과 집합의 각 데이터 행에 배타적 잠금을 추가합니다. 다른 스레드는 레코드 업데이트 및 삭제가 차단되어 높은 동시성 환경에서 데이터베이스에 많은 잠금 대기가 발생하기 쉽고, 이는 데이터베이스 쿼리 성능에 영향을 미칩니다."
DMLCheckSelectForUpdateDesc = "SELECT FOR UPDATE 사용을 권장하지 않음"
DMLCheckSelectForUpdateMessage = "SELECT FOR UPDATE 사용을 권장하지 않음"
DMLCheckSelectLimitAnnotation = "쿼리에 의해 스캔되는 행 수가 많으면 옵티마이저가 잘못된 인덱스를 선택하거나 인덱스를 사용하지 않을 수 있습니다. 특정 규칙 임계값은 비즈니스 요구에 따라 조정할 수 있으며, 기본값은 1000입니다"
DMLCheckSelectLimitDesc = "SELECT 문에는 LIMIT가 있어야 합니다"
DMLCheckSelectLimitMessage = "SELECT 문에는 LIMIT가 있어야 하며, 제한 수는 %v를 초과할 수 없습니다"
DMLCheckSelectLimitParams1 = "쿼리할 최대 행 수"
DMLCheckSelectRowsAnnotation = "필터 조건에 기본 키나 인덱스를 추가하면 쿼리 성능을 향상시키고 전체 테이블 스캔 비용을 줄일 수 있습니다."
DMLCheckSelectRowsDesc = "쿼리 데이터 양이 임계값을 초과하면 필터 조건에 기본 키 또는 인덱스를 포함해야 합니다"
DMLCheckSelectRowsMessage = "쿼리 데이터 양이 임계값을 초과하면 필터 조건에 기본 키 또는 인덱스를 포함해야 합니다"
DMLCheckSelectRowsParams1 = "쿼리 데이터 양(만 단위)"
DMLCheckSelectWithOrderByAnnotation = "ORDER BY는 쿼리 성능에 상당한 영향을 미치며 최적화 및 유지 관리에 도움이 되지 않습니다. 정렬 부분을 비즈니스 처리에 포함시키는 것이 좋습니다."
DMLCheckSelectWithOrderByDesc = "SELECT 문에는 ORDER BY가 있을 수 없습니다"
DMLCheckSelectWithOrderByMessage = "SELECT 문에는 ORDER BY가 있을 수 없습니다"
DMLCheckSortColumnLengthAnnotation = "VARCHAR(2000)와 같은 긴 필드에 대한 ORDER BY, DISTINCT, GROUP BY, UNION과 같은 정렬 작업은 정렬을 발생시키고 성능 위험이 있습니다."
DMLCheckSortColumnLengthDesc = "긴 필드 정렬 금지"
DMLCheckSortColumnLengthMessage = "임계값보다 긴 필드를 ORDER BY, DISTINCT, GROUP BY, UNION에 사용하는 것을 권장하지 않습니다. 해당 필드: %v"
DMLCheckSortColumnLengthParams1 = "정렬 가능한 필드의 최대 길이"
DMLCheckSortDirectionAnnotation = "MySQL 8.0 이전 버전에서는 ORDER BY의 여러 컬럼에 대해 지정된 정렬 방향이 다를 경우 설정된 인덱스를 사용할 수 없습니다. MySQL 8.0 이후에는 정렬 순서에 맞는 해당 조인 인덱스를 설정하여 최적화할 수 있습니다"
DMLCheckSortDirectionDesc = "ORDER BY 문에서 여러 다른 조건에 대해 서로 다른 정렬 방향을 사용하는 것을 권장하지 않습니다"
DMLCheckSortDirectionMessage = "ORDER BY 문에서 여러 다른 조건에 대해 서로 다른 정렬 방향을 사용하는 것을 권장하지 않습니다"
DMLCheckSpacesAroundTheStringAnnotation = "문자열 앞뒤의 공백은 쿼리 판단 로직이 잘못될 수 있습니다. 예를 들어 MySQL 5.5에서는 'a'와 'a '가 쿼리에서 동일한 값으로 간주됩니다"
DMLCheckSpacesAroundTheStringDesc = "따옴표 안에 문자열의 시작이나 끝에 공백을 포함하는 것을 권장하지 않습니다"
DMLCheckSpacesAroundTheStringMessage = "따옴표 안에 문자열의 시작이나 끝에 공백을 포함하는 것을 권장하지 않습니다"
DMLCheckSubQueryNestNumAnnotation = "서브쿼리의 중첩 수준이 임계값을 초과합니다. 일부 경우에 서브쿼리는 인덱스를 사용할 수 없습니다. 동시에 결과 집합이 큰 서브쿼리의 경우 많은 임시 테이블이 생성되어 CPU와 IO 리소스를 과도하게 소비하여 많은 느린 쿼리가 발생합니다."
DMLCheckSubQueryNestNumDesc = "서브쿼리의 중첩 수준이 임계값을 초과하지 않는 것이 좋습니다"
DMLCheckSubQueryNestNumMessage = "서브쿼리의 중첩 수준이 임계값 %v를 초과합니다"
DMLCheckSubQueryNestNumParams1 = "서브쿼리의 중첩 수준이 임계값을 초과하지 않는 것이 좋습니다"
DMLCheckSubqueryLimitAnnotation = "일부 MySQL 버전은 서브쿼리에서 'LIMIT & IN/ALL/ANY/SOME'을 지원하지 않습니다."
DMLCheckSubqueryLimitDesc = "서브쿼리에서 LIMIT 사용을 권장하지 않습니다"
DMLCheckSubqueryLimitMessage = "서브쿼리에서 LIMIT 사용을 권장하지 않습니다"
DMLCheckTableSizeAnnotation = "대용량 테이블에 대한 DML 작업은 시간이 오래 걸리고 부하가 높아 데이터베이스 성능에 영향을 미칠 수 있습니다. 특정 규칙 임계값은 비즈니스 요구에 따라 조정할 수 있습니다. 기본값: 1024"
DMLCheckTableSizeDesc = "데이터가 너무 많은 테이블에서 DML 작업 수행을 권장하지 않습니다"
DMLCheckTableSizeMessage = "DML을 실행하기 위한 테이블 %v 공간은 %vMB를 초과하지 않는 것이 좋습니다"
DMLCheckTableSizeParams1 = "테이블 공간 크기(MB)"
DMLCheckUpdateOrDeleteHasWhereAnnotation = "이러한 문장의 목적은 데이터베이스의 데이터를 수정하는 것이므로, 업데이트하거나 삭제할 레코드를 필터링하기 위해 WHERE 조건을 사용하여 데이터의 정확성을 보장해야 합니다. 또한 WHERE 조건을 사용하면 쿼리 성능도 향상시킬 수 있습니다."
DMLCheckUpdateOrDeleteHasWhereDesc = "UPDATE/DELETE 작업에 WHERE 조건을 사용하는 것이 좋습니다"
DMLCheckUpdateOrDeleteHasWhereMessage = "UPDATE/DELETE 작업에 WHERE 조건을 사용하는 것이 좋습니다"
DMLCheckWhereExistFuncAnnotation = "조건 필드에 함수 연산을 수행하면 인덱스 값의 순서가 손상되어 옵티마이저가 인덱스 사용을 포기하도록 선택할 수 있으며, 이는 쿼리 성능을 크게 저하시킵니다."
DMLCheckWhereExistFuncDesc = "조건 필드에 함수 연산 사용을 피하세요"
DMLCheckWhereExistFuncMessage = "조건 필드에 함수 연산 사용을 피하세요"
DMLCheckWhereExistImplicitConversionAnnotation = "WHERE 조건에서 필터 필드와 일치하지 않는 데이터 타입을 사용하면 암시적 데이터 타입 변환이 발생하여 쿼리가 인덱스를 사용하지 못할 위험이 있습니다. 높은 동시성과 대용량 데이터의 경우, 인덱스를 사용하지 않으면 데이터베이스의 쿼리 성능이 크게 저하됩니다."
DMLCheckWhereExistImplicitConversionDesc = "WHERE 조건에서 필터 필드와 일치하지 않는 데이터 타입을 사용하지 않는 것이 좋습니다"
DMLCheckWhereExistImplicitConversionMessage = "WHERE 조건에서 필터 필드와 일치하지 않는 데이터 타입을 사용하지 않는 것이 좋습니다"
DMLCheckWhereExistNotAnnotation = "부정 쿼리를 사용하면 전체 테이블 스캔이 발생하여 느린 SQL이 발생합니다"
DMLCheckWhereExistNotDesc = "조건 필드에 부정 쿼리를 사용하지 않는 것이 좋습니다"
DMLCheckWhereExistNotMessage = "조건 필드에 부정 쿼리를 사용하지 않는 것이 좋습니다"
DMLCheckWhereExistScalarSubqueryAnnotation = "스칼라 서브쿼리는 동일한 테이블에 여러 번 접근하는 문제가 있어 실행 오버헤드가 높고 효율성이 낮습니다. LEFT JOIN을 사용하여 스칼라 서브쿼리를 대체할 수 있습니다"
DMLCheckWhereExistScalarSubqueryDesc = "스칼라 서브쿼리 사용을 권장하지 않습니다"
DMLCheckWhereExistScalarSubqueryMessage = "스칼라 서브쿼리 사용을 권장하지 않습니다"
DMLCheckWhereIsInvalidAnnotation = "WHERE 조건이 없는 SQL은 실행 중에 전체 테이블 스캔을 수행하여 추가 오버헤드가 발생합니다. 대용량 데이터가 있는 고동시성 환경에서 이를 활성화하여 데이터베이스 쿼리 성능에 영향을 미치지 않도록 하는 것이 좋습니다."
DMLCheckWhereIsInvalidDesc = "WHERE 조건이 없거나 항상 TRUE인 WHERE 조건이 있는 SQL 금지"
DMLCheckWhereIsInvalidMessage = "WHERE 조건이 없거나 항상 TRUE인 WHERE 조건이 있는 SQL 금지"
DMLCheckWithLimitAnnotation = "LIMIT 조건을 사용하는 DELETE/UPDATE 문은 삭제나 업데이트할 데이터를 무작위로 선택하므로 비즈니스에서 예측할 수 없습니다"
DMLCheckWithLimitDesc = "DELETE/UPDATE 문에 LIMIT 조건이 있을 수 없습니다"
DMLCheckWithLimitMessage = "DELETE/UPDATE 문에 LIMIT 조건이 있을 수 없습니다"
DMLCheckWithOrderByAnnotation = "DELETE/UPDATE에 ORDER BY가 있으면 정렬을 사용하게 되어 불필요한 오버헤드가 발생합니다"
DMLCheckWithOrderByDesc = "DELETE/UPDATE 문에는 ORDER BY가 있을 수 없습니다"
DMLCheckWithOrderByMessage = "DELETE/UPDATE 문에는 ORDER BY가 있을 수 없습니다"
DMLDisableSelectAllColumnAnnotation = "테이블 구조가 변경될 때 * 와일드카드를 사용하여 모든 컬럼을 선택하면 쿼리 동작이 변경되어 비즈니스 기대와 일치하지 않게 됩니다. 동시에 SELECT *의 불필요한 필드는 불필요한 디스크 I/O 및 네트워크 오버헤드를 가져오고 인덱스를 커버할 수 없어 테이블 스캔이 발생하고 쿼리 효율성이 크게 저하됩니다"
DMLDisableSelectAllColumnDesc = "SELECT *를 사용하지 마세요"
DMLDisableSelectAllColumnMessage = "SELECT *를 사용하지 마세요"
DMLHintCountFuncWithColAnnotation = "COUNT(COL)을 사용하면 전체 테이블 스캔이 필요하여 성능 저하가 발생할 수 있으므로 COUNT(*)를 사용하는 것이 좋습니다"
DMLHintCountFuncWithColDesc = "COUNT(COL) 사용을 피하세요"
DMLHintCountFuncWithColMessage = "COUNT(COL) 사용을 피하세요"
DMLHintDeleteTipsAnnotation = "DROP/TRUNCATE는 DDL이며, 작업이 즉시 적용되고 로그에 기록되지 않아 롤백할 수 없습니다. 고위험 작업을 수행하기 전에 데이터를 백업하는 것이 필요합니다"
DMLHintDeleteTipsDesc = "DELETE/DROP/TRUNCATE 작업을 수행하기 전에 백업하는 것이 좋습니다"
DMLHintDeleteTipsMessage = "DELETE/DROP/TRUNCATE 작업을 수행하기 전에 백업하는 것이 좋습니다"
DMLHintGroupByRequiresConditionsAnnotation = "5.7에서는 MySQL이 기본적으로 'GROUP BY col1, …'를 'ORDER BY col1,…' 순서로 암시적으로 정렬하여 불필요한 정렬과 추가 오버헤드가 발생합니다. 8.0에서는 이런 일이 발생하지 않습니다. 정렬이 필요하지 않은 경우 명시적으로 'ORDER BY NULL'을 추가하는 것이 좋습니다"
DMLHintGroupByRequiresConditionsDesc = "GROUP BY 문에 ORDER BY 조건을 추가하는 것이 좋습니다"
DMLHintGroupByRequiresConditionsMessage = "GROUP BY 문에 ORDER BY 조건을 추가하는 것이 좋습니다"
DMLHintInNullOnlyFalseAnnotation = "쿼리 조건이 항상 거짓이면 쿼리에서 일치하는 결과가 없게 됩니다"
DMLHintInNullOnlyFalseDesc = "IN (NULL) 또는 NOT IN (NULL) 사용을 피하세요"
DMLHintInNullOnlyFalseMessage = "IN (NULL)/NOT IN (NULL) 사용을 피하세요. 이 사용법은 항상 거짓이며 조건이 무효화됩니다"
DMLHintLimitMustBeCombinedWithOrderByAnnotation = "ORDER BY 없는 LIMIT는 실행 계획에 따라 비결정적 결과를 초래하여 비즈니스 요구 사항을 충족하지 못할 수 있습니다"
DMLHintLimitMustBeCombinedWithOrderByDesc = "LIMIT 쿼리에 ORDER BY 사용을 권장합니다"
DMLHintLimitMustBeCombinedWithOrderByMessage = "LIMIT 쿼리에 ORDER BY 사용을 권장합니다"
DMLHintSumFuncTipsAnnotation = "컬럼의 값이 모두 NULL일 때, COUNT(COL)의 반환값은 0이지만 SUM(COL)의 반환값은 NULL입니다. 따라서 SUM()을 사용할 때는 NPE 문제(데이터가 NULL을 반환하는 것을 의미)에 주의해야 합니다. 비즈니스에서 NPE 문제를 방지해야 하는 경우 이 규칙을 활성화하는 것이 좋습니다"
DMLHintSumFuncTipsDesc = "SUM(COL) 사용을 피하세요"
DMLHintSumFuncTipsMessage = "SUM(COL) 사용을 피하세요. 이 사용법은 NULL 값을 반환하여 프로그램 널 포인터를 발생시킬 위험이 있습니다"
DMLHintTruncateTipsAnnotation = "TRUNCATE는 DDL이며, 데이터를 롤백할 수 없습니다. 백업 없이 TRUNCATE를 사용할 때는 주의하세요"
DMLHintTruncateTipsDesc = "TRUNCATE 작업을 사용하지 마세요"
DMLHintTruncateTipsMessage = "TRUNCATE 작업을 사용하지 마세요"
DMLHintUseTruncateInsteadOfDeleteAnnotation = "TRUNCATE TABLE은 DELETE보다 빠르고 시스템 및 트랜잭션 로그 리소스를 적게 사용합니다. 또한 TRUNCATE 후 테이블이 차지하는 공간이 해제되지만, DELETE 후에는 테이블 공간을 해제하기 위해 수동으로 OPTIMIZE를 실행해야 합니다"
DMLHintUseTruncateInsteadOfDeleteDesc = "전체 테이블을 삭제할 때는 DELETE 대신 TRUNCATE를 사용하는 것이 좋습니다"
DMLHintUseTruncateInsteadOfDeleteMessage = "전체 테이블을 삭제할 때는 DELETE 대신 TRUNCATE를 사용하는 것이 좋습니다"
DMLMustMatchLeftMostPrefixAnnotation = "복합 인덱스의 가장 왼쪽 필드에 IN, OR 등 비등가 쿼리를 사용하면 복합 인덱스가 무효화됩니다"
DMLMustMatchLeftMostPrefixDesc = "복합 인덱스의 가장 왼쪽 필드에 IN, OR 등 비등가 쿼리 사용 금지"
DMLMustMatchLeftMostPrefixMessage = "복합 인덱스의 가장 왼쪽 필드에 IN, OR 등 비등가 쿼리를 사용하면 복합 인덱스가 무효화됩니다"
DMLMustUseLeftMostPrefixAnnotation = "복합 인덱스를 사용할 때 첫 번째 필드를 포함하지 않으면 복합 인덱스가 무효화됩니다"
DMLMustUseLeftMostPrefixDesc = "복합 인덱스를 사용할 때는 반드시 복합 인덱스의 첫 번째 필드를 사용해야 합니다"
DMLMustUseLeftMostPrefixMessage = "복합 인덱스를 사용할 때는 반드시 복합 인덱스의 첫 번째 필드를 사용해야 합니다"
DMLNotAllowInsertAutoincrementAnnotation = "수동 할당은 데이터 간격과 기본 키 충돌을 일으킬 수 있습니다"
DMLNotAllowInsertAutoincrementDesc = "자동 증가 필드 값을 수동으로 설정하는 것을 금지합니다"
DMLNotAllowInsertAutoincrementMessage = "자동 증가 필드 값을 수동으로 설정하는 것을 금지합니다"
DMLNotRecommendFuncInWhereAnnotation = "함수나 연산자를 사용하면 쿼리가 테이블의 인덱스를 사용할 수 없게 되어 전체 테이블 스캔을 수행하게 되며, 성능이 저하됩니다"
DMLNotRecommendFuncInWhereDesc = "WHERE 조건에서 함수나 다른 연산자 사용을 피해야 합니다"
DMLNotRecommendFuncInWhereMessage = "WHERE 조건에서 함수나 다른 연산자 사용을 피해야 합니다"
DMLNotRecommendGroupByConstantAnnotation = "GROUP BY 1은 첫 번째 컬럼으로 그룹화하는 것을 의미합니다. GROUP BY 절에서 표현식이나 컬럼 이름 대신 숫자를 사용하면 쿼리 컬럼 순서가 변경될 때 쿼리 로직에 문제가 발생할 수 있습니다"
DMLNotRecommendGroupByConstantDesc = "상수에 대해 GROUP BY를 수행하지 마세요"
DMLNotRecommendGroupByConstantMessage = "상수에 대해 GROUP BY를 수행하지 마세요"
DMLNotRecommendGroupByExpressionAnnotation = "ORDER BY 조건이 표현식이나 함수인 경우 임시 테이블을 사용합니다. WHERE가 지정되지 않거나 WHERE 조건이 반환하는 결과 집합이 큰 경우 성능이 매우 저하됩니다"
DMLNotRecommendGroupByExpressionDesc = "ORDER BY 조건으로 표현식을 사용하지 마세요"
DMLNotRecommendGroupByExpressionMessage = "ORDER BY 조건으로 표현식을 사용하지 마세요"
DMLNotRecommendHavingAnnotation = "인덱스된 필드가 HAVING 절에 배치되면 인덱스를 사용하지 않습니다. HAVING 절을 WHERE의 쿼리 조건으로 다시 작성하는 것이 좋습니다. 이렇게 하면 쿼리 처리 중에 인덱스를 사용하고 SQL 실행 효율성을 향상시킬 수 있습니다"
DMLNotRecommendHavingDesc = "HAVING 절을 사용하지 마세요"
DMLNotRecommendHavingMessage = "HAVING 절을 사용하지 마세요"
DMLNotRecommendInAnnotation = "IN 값의 수가 너무 많으면 쿼리가 전체 테이블 스캔을 수행하게 되어 MySQL 성능이 크게 저하될 수 있습니다."
DMLNotRecommendInDesc = "IN 사용을 권장하지 않음"
DMLNotRecommendInMessage = "IN 사용을 권장하지 않음"
DMLNotRecommendNotWildcardLikeAnnotation = "와일드카드를 포함하지 않는 LIKE 쿼리는 논리적으로 등가 쿼리와 동일합니다. 대신 등가 쿼리를 사용하는 것이 좋습니다."
DMLNotRecommendNotWildcardLikeDesc = "와일드카드가 없는 LIKE 쿼리 사용을 권장하지 않음"
DMLNotRecommendNotWildcardLikeMessage = "와일드카드가 없는 LIKE 쿼리 사용을 권장하지 않음"
DMLNotRecommendOrderByRandAnnotation = "ORDER BY RAND()는 임시 테이블을 사용한 다음 정렬합니다. 대용량 데이터의 경우 서버 부하와 쿼리 시간이 증가합니다."
DMLNotRecommendOrderByRandDesc = "ORDER BY RAND() 사용을 권장하지 않음"
DMLNotRecommendOrderByRandMessage = "ORDER BY RAND() 사용을 권장하지 않음"
DMLNotRecommendSubqueryAnnotation = "일부 경우에 서브쿼리는 인덱스를 사용할 수 없습니다. 또한 결과 집합이 큰 서브쿼리의 경우 많은 임시 테이블이 생성되어 CPU와 IO 리소스를 과도하게 소비하여 많은 느린 쿼리가 발생합니다."
DMLNotRecommendSubqueryDesc = "서브쿼리 사용을 권장하지 않음"
DMLNotRecommendSubqueryMessage = "서브쿼리 사용을 권장하지 않음"
DMLNotRecommendSysdateAnnotation = "STATEMENT 기반 마스터-슬레이브 환경에서 SYSDATE() 함수를 사용하면 데이터 불일치가 발생할 수 있습니다. 이는 문장이 마스터에서 실행될 때와 로그가 슬레이브로 전송될 때 사이에 시간 차이가 있기 때문입니다. 슬레이브에서 실행될 때는 다른 시간 값이 됩니다. ROW 기반 복제 환경을 채택하는 것이 좋습니다."
DMLNotRecommendSysdateDesc = "SYSDATE() 함수 사용을 권장하지 않음"
DMLNotRecommendSysdateMessage = "SYSDATE() 함수 사용을 권장하지 않음"
DMLNotRecommendUpdatePKAnnotation = "기본 키 인덱스 데이터 컬럼의 순서는 테이블 레코드의 물리적 저장 순서입니다. 기본 키를 자주 업데이트하면 전체 테이블 레코드의 순서가 조정되어 상당한 양의 리소스가 소비됩니다."
DMLNotRecommendUpdatePKDesc = "기본 키 UPDATE를 권장하지 않음"
DMLNotRecommendUpdatePKMessage = "기본 키 UPDATE를 권장하지 않음"
DMLSQLExplainLowestLevelAnnotation = "SQL 실행 계획의 type 필드가 쿼리 성능을 보장하기 위해 필요한 수준을 충족하는지 확인합니다."
DMLSQLExplainLowestLevelDesc = "SQL 실행 계획의 type 필드는 지정된 수준을 충족해야 합니다"
DMLSQLExplainLowestLevelMessage = "실행 계획의 type 필드가 지정된 수준 중 하나를 충족하도록 SQL을 수정하는 것이 좋습니다: %v"
DMLSQLExplainLowestLevelParams1 = "쿼리 계획 타입 수준, 쉼표로 구분"
DMLWhereExistNullAnnotation = "IS NULL 또는 IS NOT NULL을 사용하면 쿼리가 인덱스 사용을 포기하고 전체 테이블 스캔을 수행할 수 있습니다."
DMLWhereExistNullDesc = "조건 필드에 NULL 값 판단 사용을 권장하지 않음"
DMLWhereExistNullMessage = "조건 필드에 NULL 값 판단 사용을 권장하지 않음"
DuplicateColumnsMessage = "컬럼 이름 %s가 중복됩니다"
DuplicateIndexedColumnMessage = "인덱스 %s 컬럼 %s가 중복됩니다"
DuplicateIndexesMessage = "인덱스 이름 %s가 중복됩니다"
DuplicatePrimaryKeyedColumnMessage = "기본 키 컬럼 %s가 중복됩니다"
ExtremalIndexAdviceFormat = "인덱스 제안 | SQL이 극값 함수를 사용했습니다. 인덱스의 정렬 특성을 활용하여 극값을 빠르게 찾을 수 있습니다. 테이블 %s에 단일 컬럼 인덱스를 추가하는 것이 좋습니다. 참조 컬럼: %s"
FunctionIndexAdviceFormatAll = "인덱스 제안 | SQL이 함수를 쿼리 조건으로 사용했습니다. MySQL 5.7 이상 버전에서는 가상 컬럼에 인덱스를 생성할 수 있습니다. MySQL 8.0.13 이상 버전에서는 함수 인덱스를 생성할 수 있습니다. MySQL 버전에 따라 테이블 %s에 적절한 인덱스를 추가하는 것이 좋습니다. 참조 컬럼: %s"
FunctionIndexAdviceFormatV57 = "인덱스 제안 | SQL이 함수를 쿼리 조건으로 사용했습니다. MySQL 5.7 이상 버전에서는 가상 컬럼에 인덱스를 생성할 수 있습니다. 테이블 %s에 가상 컬럼 인덱스를 추가하는 것이 좋습니다. 참조 컬럼: %s"
FunctionIndexAdviceFormatV80 = "인덱스 제안 | SQL이 함수를 쿼리 조건으로 사용했습니다. MySQL 8.0.13 이상 버전에서는 함수 인덱스를 생성할 수 있습니다. 테이블 %s에 함수 인덱스를 추가하는 것이 좋습니다. 참조 컬럼: %s"
GhostDryRunError = "테이블 공간 크기가 %vMB를 초과합니다. gh-ost가 온라인으로 사용될 예정이지만, 드라이 런에서 다음 오류가 발생했습니다: %v"
GhostDryRunNotice = "테이블 공간 크기가 %vMB를 초과합니다. gh-ost가 온라인으로 사용될 예정입니다"
IndexExistMessage = "인덱스 %s가 이미 존재합니다"
IndexNotExistMessage = "인덱스 %s가 존재하지 않습니다"
JoinIndexAdviceFormat = "인덱스 제안 | SQL의 필드 %s는 구동 테이블 %s의 조인 필드입니다. 테이블 %s에 단일 컬럼 인덱스를 추가하는 것이 좋습니다. 참조 컬럼: %s"
KeyedColumnNotExistMessage = "인덱스 컬럼 %s가 존재하지 않습니다"
MultiPrimaryKeyMessage = "기본 키는 하나만 설정할 수 있습니다"
NotSupportExceedMaxRowsRollback = "영향을 받을 것으로 예상되는 행 수가 구성된 최대값을 초과합니다. 롤백 문이 생성되지 않습니다."
NotSupportHasVariableRollback = "변수를 포함하는 DML 문의 롤백은 지원되지 않습니다"
NotSupportInsertWithoutPrimaryKeyRollback = "기본 키를 지정하지 않은 INSERT 문의 롤백은 지원되지 않습니다"
NotSupportMultiTableStatementRollback = "여러 테이블에 대한 DML 문의 롤백은 아직 지원되지 않습니다"
NotSupportNoPrimaryKeyTableRollback = "기본 키가 없는 테이블에 대한 DML 문의 롤백은 지원되지 않습니다"
NotSupportOnDuplicatStatementRollback = "ON DUPLICATE 문의 롤백은 아직 지원되지 않습니다"
NotSupportParamMarkerStatementRollback = "지문이 포함된 문의 롤백은 지원되지 않습니다"
NotSupportStatementRollback = "이 유형의 문에 대한 롤백은 아직 지원되지 않습니다"
NotSupportSubQueryStatementRollback = "서브쿼리가 있는 문의 롤백은 아직 지원되지 않습니다"
OptDMLCheckLimitOffsetNumAnnotation = "LIMIT 및 OFFSET 절은 각각 쿼리 결과 수를 제어하고 데이터를 반환할 시작 행을 지정하는 데 사용할 수 있습니다. 그러나 OFFSET 값이 큰 경우, 시스템이 시작 행을 찾기 위해 더 많은 데이터를 스캔해야 하므로 쿼리 효율성이 저하됩니다. 이는 대용량 데이터셋에서 성능 문제와 리소스 소비로 이어질 수 있습니다."
OptDMLCheckLimitOffsetNumDesc = "OFFSET 값이 임계값을 초과합니다"
OptDMLCheckMathComputationOrFuncOnIndexAnnotation = "인덱스된 컬럼에 대한 수학 연산은 인덱스를 무효화하여 전체 테이블 스캔과 심각한 성능 문제를 쉽게 초래할 수 있습니다. 따라서 인덱스된 컬럼에 대한 연산을 상수 측으로 변환하도록 노력하세요."
OptDMLCheckMathComputationOrFuncOnIndexDesc = "인덱스된 컬럼에 대한 연산으로 인한 인덱스 무효화"
OptDMLCheckNotEqualSymbolAnnotation = "'!='는 비표준 연산자이며, '<>'는 SQL의 표준 부등호 연산자입니다"
OptDMLCheckNotEqualSymbolDesc = "'!=' 대신 '<>' 사용"
OptDMLCheckWhereExistImplicitConversionAnnotation = "WHERE 조건에서 필터링 필드와 일치하지 않는 데이터 타입을 사용하면 암시적 데이터 타입 변환이 발생하여 쿼리가 인덱스를 사용하지 못할 위험이 있습니다. 높은 동시성과 대용량 데이터에서 인덱스를 사용하지 않으면 데이터베이스의 쿼리 성능이 크게 저하됩니다"
OptDMLCheckWhereExistImplicitConversionDesc = "암시적 타입 변환으로 인한 인덱스 무효화"
OptDMLCheckWhereExistScalarSubqueryAnnotation = "존재 여부를 판단하기 위해 COUNT 스칼라 서브쿼리를 사용하는 경우, EXISTS 서브쿼리로 다시 작성하여 클러스터 작업을 피할 수 있습니다."
OptDMLCheckWhereExistScalarSubqueryDesc = "COUNT 스칼라 서브쿼리 재작성"
OptDMLHintGroupByRequiresConditionsAnnotation = "MySQL 초기 버전에서는 GROUP BY가 기본적으로 정렬을 수행하며, 이는 ORDER BY NULL을 추가하여 취소하고 쿼리 효율성을 향상시킬 수 있습니다."
OptDMLHintGroupByRequiresConditionsDesc = "GROUP BY에 명시적으로 ORDER BY 조건 추가 (< MYSQL 5.7)"
OptDMLHintInNullOnlyFalseAnnotation = "쿼리 조건이 항상 거짓이면 쿼리에서 일치하는 결과가 없게 됩니다"
OptDMLHintInNullOnlyFalseDesc = "NULL 값이 있는 IN 서브쿼리는 예상치 못한 결과 집합을 초래할 수 있음"
OptDMLHintUseTruncateInsteadOfDeleteAnnotation = "TRUNCATE TABLE은 DELETE보다 빠르고, 시스템 및 트랜잭션 로그 리소스를 적게 사용하며, TRUNCATE 후 테이블이 차지하는 공간이 해제되지만, DELETE 후에는 테이블 공간을 해제하기 위해 OPTIMIZE를 수동으로 실행해야 합니다"
OptDMLHintUseTruncateInsteadOfDeleteDesc = "조건 없는 DELETE는 Truncate로 재작성해야 함"
OptDMLNotRecommendHavingAnnotation = "논리적으로 HAVING 조건은 그룹화 후에 실행되지만, WHERE 절의 조건은 테이블 접근(인덱스 접근) 중이나 테이블 접근 후 그룹화 전에 실행될 수 있습니다. 이 두 조건은 그룹화 후 실행하는 것보다 비용이 적게 듭니다."
OptDMLNotRecommendHavingDesc = "HAVING 조건 푸시다운"
OptDMLNotRecommendInAnnotation = "IN 서브쿼리는 다음 형식을 따르는 서브쿼리를 의미합니다. IN 서브쿼리는 동등한 상관 EXISTS 서브쿼리나 내부 조인으로 재작성하여 새로운 필터링 조건을 생성할 수 있습니다."
OptDMLNotRecommendInDesc = "IN 서브쿼리 최적화"
OptDMLNotRecommendNotWildcardLikeAnnotation = "와일드카드가 없는 LIKE 쿼리는 논리적으로 등가 쿼리와 동일합니다. 등가 쿼리를 대신 사용하는 것이 좋습니다. 또한, 와일드카드가 없는 LIKE 쿼리는 일반적으로 개발자 오류로 인해 발생하며 예상된 비즈니스 로직 구현을 충족하지 못할 수 있습니다"
OptDMLNotRecommendNotWildcardLikeDesc = "와일드카드가 없는 LIKE 쿼리 사용 피하기"
OptDMLRuleAllSubqueryRewriteAnnotation = "ALL 서브쿼리 결과에 NULL이 있으면 이 SQL은 항상 빈 결과를 반환합니다. 올바른 방법은 서브쿼리에 비널 제약 조건을 추가하거나 max/min 표기법을 사용하는 것입니다."
OptDMLRuleAllSubqueryRewriteDesc = "ALL 한정 서브쿼리 재작성"
OptDMLRuleDiffOrderingSpecTypeWarningAnnotation = "인덱스를 활용하여 정렬을 피하려면 ORDER BY 절의 모든 표현식이 동일한 ASC 또는 DESC 방향으로 정렬되어야 합니다. ORDER BY 문이 여러 다른 조건에 대해 서로 다른 정렬 방향을 사용하면 인덱스를 사용할 수 없습니다"
OptDMLRuleDiffOrderingSpecTypeWarningDesc = "서로 다른 정렬 필드 방향으로 인한 인덱스 무효화"
OptDMLRuleDistinctEliminationRewriteAnnotation = "존재 여부만 테스트하는 서브쿼리의 경우, 서브쿼리에 DISTINCT가 포함되어 있으면 중복 제거 작업을 피하기 위해 일반적으로 DISTINCT를 제거할 수 있습니다."
OptDMLRuleDistinctEliminationRewriteDesc = "서브쿼리에서 DISTINCT 제거"
OptDMLRuleExists2JoinRewriteAnnotation = "EXISTS 서브쿼리는 적절한 조건에서 JOIN으로 변환하여 쿼리를 최적화하고 데이터베이스 처리 효율성과 성능을 향상시킬 수 있습니다."
OptDMLRuleExists2JoinRewriteDesc = "EXISTS 쿼리를 테이블 조인으로 변환"
OptDMLRuleFilterPredicatePushDownRewriteAnnotation = "필터 조건 푸시다운(FPPD)은 내부 쿼리 블록에 필터 조건을 더 일찍 적용하여 데이터 처리량을 줄이고 SQL 실행 효율성을 향상시키는 기술입니다."
OptDMLRuleFilterPredicatePushDownRewriteDesc = "필터 조건 푸시다운"
OptDMLRuleGroupingFromDiffTablesRewriteAnnotation = "그룹화 필드가 서로 다른 테이블에서 온 경우, 데이터베이스 옵티마이저는 정렬을 피하기 위해 인덱스의 순서를 활용할 수 없습니다. 등가 조건이 있는 경우, 이러한 필드를 동일한 테이블의 필드로 대체하여 인덱스를 활용해 정렬을 최적화하고 쿼리 효율성을 향상시킬 수 있습니다."
OptDMLRuleGroupingFromDiffTablesRewriteDesc = "서로 다른 테이블의 GROUPBY 필드"
OptDMLRuleJoinEliminationRewriteAnnotation = "결과에 영향을 주지 않고 불필요한 테이블 조인을 제거하여 쿼리를 단순화하고 성능을 향상시킵니다. 쿼리가 주 테이블의 기본 키 컬럼만 포함하는 시나리오에 적용 가능합니다."
OptDMLRuleJoinEliminationRewriteDesc = "테이블 조인 제거"
OptDMLRuleLimitClausePushDownRewriteAnnotation = "Limit 절 푸시다운 최적화는 Limit 절을 가능한 한 아래로 푸시하여 일부 데이터를 미리 필터링함으로써 중간 결과 집합의 크기를 줄이고 후속 계산에서 처리해야 하는 데이터 양을 줄여 쿼리 성능을 향상시킵니다."
OptDMLRuleLimitClausePushDownRewriteDesc = "LIMIT을 UNION 분기로 푸시다운"
OptDMLRuleLimitClausePushDownRewriteParams1 = "OFFSET 최대 임계값"
OptDMLRuleMaxMinAggRewriteAnnotation = "MAX/MIN을 사용하는 서브쿼리의 경우, 재작성을 통해 인덱스 순서를 활용하여 클러스터 작업을 피할 수 있습니다."
OptDMLRuleMaxMinAggRewriteDesc = "MAX/MIN 서브쿼리 재작성"
OptDMLRuleMoveOrder2LeadingRewriteAnnotation = "쿼리가 동일한 테이블의 정렬 필드와 그룹화 필드를 모두 포함하지만 필드 순서가 다른 경우, 그룹화 필드 순서를 정렬 필드 순서와 일치하도록 조정하여 데이터베이스가 정렬 작업을 피할 수 있습니다."
OptDMLRuleMoveOrder2LeadingRewriteDesc = "ORDER 절 재정렬 최적화"
OptDMLRuleNPERewriteAnnotation = "SQL의 NPE(Null Pointer Exception) 문제는 SQL 쿼리에서 집계 컬럼이 모두 NULL일 때 SUM 및 AVG와 같은 집계 함수가 NULL을 반환하여 후속 프로그램에서 널 포인터 예외가 발생할 수 있다는 것을 의미합니다."
OptDMLRuleNPERewriteDesc = "NPE 재작성"
OptDMLRuleOrCond4SelectRewriteAnnotation = "쿼리 문이 OR 조건을 사용하는 경우 데이터베이스 옵티마이저가 인덱스를 사용하여 쿼리를 완료하지 못할 수 있습니다. 쿼리 문을 UNION 또는 UNION ALL 쿼리로 재작성하여 인덱스를 사용하고 쿼리 성능을 향상시킬 수 있습니다."
OptDMLRuleOrCond4SelectRewriteDesc = "OR 조건이 있는 SELECT 재작성"
OptDMLRuleOrCond4UpDeleteRewriteAnnotation = "OR 조건을 사용하는 UPDATE 또는 DELETE 문이 있는 경우 데이터베이스 옵티마이저가 인덱스를 사용하여 작업을 완료하지 못할 수 있습니다. 여러 DELETE 문으로 재작성하여 인덱스를 사용하고 쿼리 성능을 향상시킬 수 있습니다."
OptDMLRuleOrCond4UpDeleteRewriteDesc = "OR 조건이 있는 UPDELETE 재작성"
OptDMLRuleOrderEliminationInSubqueryRewriteAnnotation = "서브쿼리에 LIMIT 절이 없는 경우, 서브쿼리의 정렬 작업은 의미가 없으며 최종 결과에 영향을 주지 않고 제거할 수 있습니다."
OptDMLRuleOrderEliminationInSubqueryRewriteDesc = "IN 서브쿼리에서 LIMIT 없는 정렬 제거"
OptDMLRuleOrderingFromDiffTablesRewriteAnnotation = "정렬 필드가 서로 다른 테이블에서 왔고 등가 조건이 있는 경우, 이러한 필드를 동일한 테이블의 필드로 대체하여 인덱스를 사용해 추가 정렬을 피하고 효율성을 향상시킬 수 있습니다."
OptDMLRuleOrderingFromDiffTablesRewriteDesc = "서로 다른 테이블의 ORDERBY 필드 피하기"
OptDMLRuleOuter2InnerConversionRewriteAnnotation = "외부 조인 최적화는 특정 조건(외부 테이블에 NULL 거부 조건이 있음)을 충족하는 외부 조인을 내부 조인으로 변환하는 것을 의미하며, 이를 통해 데이터베이스 옵티마이저가 더 나은 실행 계획을 선택하고 SQL 쿼리 성능을 향상시킬 수 있습니다."
OptDMLRuleOuter2InnerConversionRewriteDesc = "외부 조인 최적화"
OptDMLRuleProjectionPushdownRewriteAnnotation = "프로젝션 푸시다운은 DT 서브쿼리에서 의미 없는 컬럼(외부 쿼리에서 사용되지 않는)을 삭제하여 IO 및 네트워크 비용을 줄이고, 동시에 옵티마이저가 테이블 접근 계획 시 테이블을 반환할 필요가 없는 최적화 옵션을 사용할 확률을 높이는 것을 의미합니다."
OptDMLRuleProjectionPushdownRewriteDesc = "프로젝션 푸시다운"
OptDMLRuleQualifierSubQueryRewriteAnnotation = "ANY/SOME/ALL로 한정된 서브쿼리는 값 관계를 비교하는 데 사용되지만, 비교를 행별로 처리하기 때문에 비효율적입니다. 쿼리 재작성을 통해 이러한 서브쿼리의 실행 효율성을 향상시킬 수 있습니다."
OptDMLRuleQualifierSubQueryRewriteDesc = "한정자 서브쿼리 재작성 최적화"
OptDMLRuleQueryFoldingRewriteAnnotation = "쿼리 폴딩은 뷰, CTE 또는 DT 서브쿼리를 확장하고 이를 참조하는 쿼리와 병합하여 중간 결과 집합의 직렬화를 줄이거나 테이블 조인 계획에 대한 더 나은 최적화 기법을 트리거하는 것을 의미합니다."
OptDMLRuleQueryFoldingRewriteDesc = "쿼리 폴딩"
OptDMLRuleSATTCRewriteAnnotation = "SAT-TC 재작성 최적화는 쿼리 조건의 논리적 관계를 분석하고 처리하여 모순을 발견하고, 조건을 단순화하거나 새로운 조건을 추론함으로써 데이터베이스 옵티마이저가 더 효율적인 실행 계획을 개발하고 SQL 성능을 향상시키는 데 도움을 줍니다."
OptDMLRuleSATTCRewriteDesc = "SATTC 재작성 최적화"
OptDMLWhereExistNullAnnotation = "= null은 표현식이 비어 있는지 판단할 수 없으며, = null은 항상 거짓으로 판단됩니다. 표현식이 비어 있는지 판단하려면 is null을 사용하세요."
OptDMLWhereExistNullDesc = "null 값 판단에 =NULL 사용 금지"
OptOracle500Annotation = "SQL NPE(Null Pointer Exception) 문제는 SQL 쿼리에서 집계된 모든 컬럼이 NULL일 때 SUM 및 AVG와 같은 집계 함수가 NULL을 반환하여 후속 프로그램에서 널 포인터 예외가 발생할 수 있다는 것을 의미합니다."
OptOracle500Desc = "NPE 재작성"
OptOracle501Annotation = "ALL 서브쿼리의 결과에 NULL이 포함되어 있으면 이 SQL은 항상 빈 결과를 반환합니다. 올바른 방법은 서브쿼리에 비널 제한을 추가하거나 max/min 방법을 사용하는 것입니다."
OptOracle501Desc = "ALL 한정 서브쿼리 재작성"
OptOracle502Annotation = "존재 여부를 판단하기 위해 COUNT 스칼라 서브쿼리를 사용하는 경우, EXISTS 서브쿼리로 재작성하여 집계 작업을 피할 수 있습니다."
OptOracle502Desc = "COUNT 스칼라 서브쿼리 재작성"
OptOracle503Annotation = "TRUNCATE TABLE은 DELETE보다 빠르고, 시스템 및 트랜잭션 로그 리소스를 적게 사용하며, TRUNCATE 후 테이블이 차지하는 공간이 해제되지만, DELETE는 테이블 공간을 해제하기 위해 OPTIMIZE를 수동으로 실행해야 합니다"
OptOracle503Desc = "조건 없는 DELETE는 Truncate로 재작성해야 함"
OptOracle504Annotation = "WHERE 조건에서 필터 필드와 일치하지 않는 데이터 타입을 사용하면 암시적 데이터 타입 변환이 발생하여 쿼리가 인덱스를 사용하지 못할 위험이 있습니다. 높은 동시성과 대용량 데이터의 경우, 인덱스를 사용하지 않으면 데이터베이스의 쿼리 성능이 크게 저하됩니다."
OptOracle504Desc = "암시적 타입 변환으로 인한 인덱스 무효화"
OptOracle505Annotation = "인덱스를 사용하여 정렬을 피하려면 ORDER BY 절의 모든 표현식을 동일한 ASC 또는 DESC 방향으로 정렬해야 합니다. ORDER BY 문이 여러 다른 조건에 대해 서로 다른 정렬 방향을 사용하면 인덱스를 사용할 수 없습니다."
OptOracle505Desc = "서로 다른 정렬 필드 방향으로 인한 인덱스 무효화"
OptOracle506Annotation = "인덱스된 컬럼에 대한 연산은 인덱스 무효화를 초래하여 전체 테이블 스캔을 쉽게 발생시키고 심각한 성능 문제를 초래할 수 있습니다. 따라서 가능한 한 인덱스된 컬럼에 대한 연산을 상수 측으로 변환해야 합니다."
OptOracle506Desc = "인덱스된 컬럼에 대한 연산으로 인한 인덱스 무효화"
OptOracle507Annotation = "논리적으로 HAVING 조건은 그룹화 후에 실행되지만, WHERE 절의 조건은 테이블 접근(인덱스 접근) 중이나 테이블 접근 후 그룹화 전에 실행될 수 있습니다. 이 두 조건은 그룹화 후 실행하는 것보다 비용이 적게 듭니다."
OptOracle507Desc = "HAVING 조건 푸시다운"
OptOracle508Annotation = "= null은 표현식이 비어 있는지 판단할 수 없으며, = null은 항상 거짓으로 판단됩니다. 표현식이 비어 있는지 판단하려면 is null을 사용하세요."
OptOracle508Desc = "null 값 판단에 =NULL 사용 금지"
OptOracle509Annotation = "IN 서브쿼리는 다음 형식을 충족하는 서브쿼리를 의미합니다. IN 서브쿼리는 동등한 관련 EXISTS 서브쿼리나 내부 조인으로 재작성하여 새로운 필터 조건을 생성할 수 있습니다."
OptOracle509Desc = "IN 서브쿼리 최적화"
OptOracle510Annotation = "쿼리 조건이 절대 참이 아니면 쿼리에서 일치하는 결과가 없게 됩니다."
OptOracle510Desc = "IN nullable 서브쿼리는 결과 집합이 예상과 일치하지 않을 수 있음"
OptOracle511Annotation = "와일드카드가 없는 LIKE 쿼리는 논리적으로 등가 쿼리와 동일하므로 등가 쿼리를 대신 사용하는 것이 좋습니다. 또한, 와일드카드가 없는 LIKE 쿼리는 일반적으로 개발자 오류로 인해 발생하며 예상된 비즈니스 로직 구현을 충족하지 못할 수 있습니다."
OptOracle511Desc = "와일드카드가 없는 LIKE 쿼리 사용 피하기"
OptOracle512Annotation = "'!='는 비표준 연산자이며, '<>'는 SQL의 표준 부등호 연산자입니다."
OptOracle512Desc = "'!=' 대신 '<>' 사용을 권장합니다"
OptOracle513Annotation = "존재 여부만 테스트하는 서브쿼리의 경우, 서브쿼리에 DISTINCT가 포함되어 있으면 중복 제거 작업을 피하기 위해 일반적으로 DISTINCT를 제거할 수 있습니다."
OptOracle513Desc = "서브쿼리에서 DISTINCT 제거"
OptOracle514Annotation = "EXISTS 서브쿼리는 적절한 경우에 JOIN으로 변환하여 쿼리를 최적화하고 데이터베이스 처리 효율성과 성능을 향상시킬 수 있습니다."
OptOracle514Desc = "EXISTS 쿼리를 테이블 조인으로 변환"
OptOracle515Annotation = "필터 조건 푸시다운(FPPD)은 내부 쿼리 블록에 필터 조건을 일찍 적용하여 데이터 처리를 줄이고 SQL 실행 효율성을 향상시키는 기술입니다."
OptOracle515Desc = "필터 조건 푸시다운"
OptOracle516Annotation = "그룹화 필드가 서로 다른 테이블에서 온 경우, 데이터베이스 옵티마이저는 정렬을 피하기 위해 인덱스의 순서를 활용할 수 없습니다. 등가 조건이 있는 경우, 이러한 필드를 동일한 테이블의 필드로 대체하여 인덱스를 활용해 정렬을 최적화하고 쿼리 효율성을 향상시킬 수 있습니다."
OptOracle516Desc = "서로 다른 테이블의 GROUPBY 필드"
OptOracle517Annotation = "결과에 영향을 주지 않고 불필요한 테이블 조인을 제거하여 쿼리를 단순화하고 성능을 향상시킵니다. 이는 쿼리가 주 테이블의 기본 키 컬럼만 포함하는 시나리오에 적합합니다."
OptOracle517Desc = "테이블 조인 제거"
OptOracle518Annotation = "MAX/MIN을 사용하는 서브쿼리의 경우, 인덱스 순서를 활용하여 집계 작업을 피하도록 재작성하세요."
OptOracle518Desc = "MAX/MIN 서브쿼리 재작성"
OptOracle519Annotation = "쿼리가 동일한 테이블의 정렬 필드와 그룹화 필드를 모두 포함하지만 순서가 다른 경우, 그룹화 필드 순서를 정렬 필드 순서와 일치하도록 조정하여 정렬 작업을 피할 수 있습니다."
OptOracle519Desc = "ORDER 절 재정렬 최적화"
OptOracle520Annotation = "쿼리 문에서 OR 조건을 사용하면 데이터베이스 옵티마이저가 인덱스를 사용하여 쿼리를 완료하지 못할 수 있습니다. 쿼리 문을 UNION 또는 UNION ALL 쿼리로 재작성하여 인덱스를 사용하고 쿼리 성능을 향상시킬 수 있습니다."
OptOracle520Desc = "OR 조건이 있는 SELECT 재작성"
OptOracle521Annotation = "UPDATE 또는 DELETE 문에서 OR 조건을 사용하면 데이터베이스 옵티마이저가 인덱스를 사용하여 작업을 완료하지 못할 수 있습니다. 여러 DELETE 문으로 재작성하여 인덱스를 사용하고 쿼리 성능을 향상시킬 수 있습니다."
OptOracle521Desc = "OR 조건이 있는 UPDELETE 재작성"
OptOracle522Annotation = "정렬 필드가 서로 다른 테이블에서 왔을 때, 등가 조건이 있다면 이러한 필드를 동일한 테이블의 필드로 대체하여 인덱스를 사용해 추가 정렬을 피하고 효율성을 향상시킬 수 있습니다."
OptOracle522Desc = "서로 다른 테이블의 ORDERBY 필드 피하기"
OptOracle523Annotation = "외부 조인 최적화는 특정 조건(외부 테이블에 NULL 거부 조건이 있음)을 충족하는 외부 조인을 내부 조인으로 변환할 수 있어 데이터베이스 옵티마이저가 더 나은 실행 계획을 선택하고 SQL 쿼리의 성능을 향상시킬 수 있다는 것을 의미합니다."
OptOracle523Desc = "외부 조인 최적화"
OptOracle524Annotation = "프로젝션 푸시다운은 DT 서브쿼리에서 의미 없는 컬럼(외부 쿼리에서 사용되지 않는)을 제거하여 IO 및 네트워크 비용을 줄이고, 동시에 옵티마이저가 테이블 접근 계획 시 테이블 스캔이 필요 없는 최적화 옵션을 선택할 가능성을 높이는 것을 의미합니다."
OptOracle524Desc = "프로젝션 푸시다운(PROJECTION PUSHDOWN)"
OptOracle525Annotation = "ANY/SOME/ALL 수정된 서브쿼리는 값 관계를 비교하는 데 사용되지만, 비교를 행별로 처리하기 때문에 비효율적입니다. 쿼리를 재작성하면 이러한 서브쿼리의 실행 효율성을 향상시킬 수 있습니다."
OptOracle525Desc = "수정된 서브쿼리 재작성 최적화"
OptOracle526Annotation = "쿼리 폴딩은 뷰, CTE 또는 DT 서브쿼리를 확장하고 이를 참조하는 쿼리와 병합하여 중간 결과 집합의 직렬화를 줄이거나 테이블 조인 계획에 대한 더 나은 최적화 기법을 트리거하는 것을 의미합니다."
OptOracle526Desc = "쿼리 폴딩(QUERY FOLDING)"
OptOracle527Annotation = "SAT-TC 재작성 최적화는 쿼리 조건의 논리적 관계를 분석하고 처리하여 모순을 발견하고, 조건을 단순화하거나 새로운 조건을 추론함으로써 데이터베이스 옵티마이저가 더 효율적인 실행 계획을 개발하고 SQL 성능을 향상시키는 데 도움을 줍니다."
OptOracle527Desc = "SATTC 재작성 최적화"
PTOSCAvoidNoDefaultValueOnNotNullColumn = "[osc]비어 있지 않은 필드는 기본값이 있어야 합니다. 그렇지 않으면 pt-online-schema-change가 실패합니다."
PTOSCAvoidRenameTable = "[osc]pt-online-schema-change는 rename table을 사용한 테이블 이름 변경을 지원하지 않습니다."
PTOSCAvoidUniqueIndex = "[osc]pt-online-schema-change를 사용하여 고유 키를 추가하면 데이터 손실이 발생할 수 있습니다. 새 테이블로 데이터를 마이그레이션할 때 insert ignore가 사용되었습니다."
PTOSCNoUniqueIndexOrPrimaryKey = "[osc]pt-online-schema-change를 사용하려면 최소한 하나의 기본 키 또는 고유 키 인덱스가 포함되어야 합니다."
ParseDDLError = "테이블 생성 문장을 파싱하지 못했습니다. 일부 온라인 감사 규칙이 유효하지 않을 수 있습니다. 수동으로 확인하세요."
PrefixIndexAdviceFormat = "인덱스 제안 | SQL이 접두사 퍼지 매칭을 사용합니다. 데이터 양이 많을 때는 역방향 함수 인덱스를 구축할 수 있습니다."
PrimaryKeyExistMessage = "기본 키가 이미 존재하므로 다시 추가할 수 없습니다."
PrimaryKeyNotExistMessage = "현재 기본 키가 없어 삭제를 실행할 수 없습니다."
RuleTypeDDLConvention = "DDL 규칙"
RuleTypeDMLConvention = "DML 규칙"
RuleTypeGlobalConfig = "전역 구성"
RuleTypeIndexInvalidation = "인덱스 무효화"
RuleTypeIndexOptimization = "인덱스 최적화"
RuleTypeIndexingConvention = "인덱스 규칙"
RuleTypeNamingConvention = "명명 규칙"
RuleTypeUsageSuggestion = "사용 제안"
SchemaExistMessage = "스키마 %s가 이미 존재합니다."
SchemaNotExistMessage = "스키마 %s가 존재하지 않습니다."
TableExistMessage = "테이블 %s가 이미 존재합니다."
TableNotExistMessage = "테이블 %s가 존재하지 않습니다."
ThreeStarIndexAdviceFormat = "인덱스 제안 | 세 가지 별 인덱스 설계 사양에 따라 테이블 %s에 %s 인덱스를 추가하는 것이 좋습니다: [%s]"
UnsupportedSyntaxError = "구문 오류이거나 파서가 지원하지 않습니다. SQL의 정확성을 수동으로 확인하세요."
