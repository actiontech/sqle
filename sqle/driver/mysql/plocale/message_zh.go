package plocale

import "github.com/nicksnyder/go-i18n/v2/i18n"

// advisor
var (
	ThreeStarIndexAdviceFormat   = &i18n.Message{ID: "ThreeStarIndexAdviceFormat", Other: "索引建议 | 根据三星索引设计规范，建议对表%s添加%s索引：【%s】"}
	PrefixIndexAdviceFormat      = &i18n.Message{ID: "PrefixIndexAdviceFormat", Other: "索引建议 | SQL使用了前模糊匹配，数据量大时，可建立翻转函数索引"}
	ExtremalIndexAdviceFormat    = &i18n.Message{ID: "ExtremalIndexAdviceFormat", Other: "索引建议 | SQL使用了最值函数，可以利用索引有序的性质快速找到最值，建议对表%s添加单列索引，参考列：%s"}
	FunctionIndexAdviceFormatV80 = &i18n.Message{ID: "FunctionIndexAdviceFormatV80", Other: "索引建议 | SQL使用了函数作为查询条件，在MySQL8.0.13以上的版本，可以创建函数索引，建议对表%s添加函数索引，参考列：%s"}
	FunctionIndexAdviceFormatV57 = &i18n.Message{ID: "FunctionIndexAdviceFormatV57", Other: "索引建议 | SQL使用了函数作为查询条件，在MySQL5.7以上的版本，可以在虚拟列上创建索引，建议对表%s添加虚拟列索引，参考列：%s"}
	FunctionIndexAdviceFormatAll = &i18n.Message{ID: "FunctionIndexAdviceFormatAll", Other: "索引建议 | SQL使用了函数作为查询条件，在MySQL5.7以上的版本，可以在虚拟列上创建索引，在MySQL8.0.13以上的版本，可以创建函数索引，建议根据MySQL版本对表%s添加合适的索引，参考列：%s"}
	JoinIndexAdviceFormat        = &i18n.Message{ID: "JoinIndexAdviceFormat", Other: "索引建议 | SQL中字段%s为被驱动表%s上的关联字段，建议对表%s添加单列索引，参考列：%s"}

	AdvisorIndexTypeComposite  = &i18n.Message{ID: "AdvisorIndexTypeComposite", Other: "复合"}
	AdvisorIndexTypeSingle     = &i18n.Message{ID: "AdvisorIndexTypeSingle", Other: "单列"}
	SQLCostChartOnlySupportDML = &i18n.Message{ID: "SQLCostChartOnlySupportDML", Other: "该SQL不是DML，无需分析SQL执行计划代价趋势"}
)

// analysis
var (
	AnalysisDescColumnName       = &i18n.Message{ID: "AnalysisDescColumnName", Other: "列名"}
	AnalysisDescColumnType       = &i18n.Message{ID: "AnalysisDescColumnType", Other: "列类型"}
	AnalysisDescCharacterSetName = &i18n.Message{ID: "AnalysisDescCharacterSetName", Other: "列字符集"}
	AnalysisDescIsNullable       = &i18n.Message{ID: "AnalysisDescIsNullable", Other: "是否可以为空"}
	AnalysisDescColumnKey        = &i18n.Message{ID: "AnalysisDescColumnKey", Other: "列索引"}
	AnalysisDescColumnDefault    = &i18n.Message{ID: "AnalysisDescColumnDefault", Other: "默认值"}
	AnalysisDescExtra            = &i18n.Message{ID: "AnalysisDescExtra", Other: "拓展信息"}
	AnalysisDescColumnComment    = &i18n.Message{ID: "AnalysisDescColumnComment", Other: "列说明"}
	AnalysisDescKeyName          = &i18n.Message{ID: "AnalysisDescKeyName", Other: "索引名"}
	AnalysisDescUnique           = &i18n.Message{ID: "AnalysisDescUnique", Other: "唯一性"}
	AnalysisDescSeqInIndex       = &i18n.Message{ID: "AnalysisDescSeqInIndex", Other: "列序列"}
	AnalysisDescCardinality      = &i18n.Message{ID: "AnalysisDescCardinality", Other: "基数"}
	AnalysisDescIndexType        = &i18n.Message{ID: "AnalysisDescIndexType", Other: "索引类型"}
	AnalysisDescComment          = &i18n.Message{ID: "AnalysisDescComment", Other: "备注"}
	AnalysisChartXTime           = &i18n.Message{ID: "AnalysisChartXTime", Other: "时间"}
	AnalysisChartYCost           = &i18n.Message{ID: "AnalysisChartYTime", Other: "花费"}
)

// audit
var (
	SchemaNotExistMessage              = &i18n.Message{ID: "SchemaNotExistMessage", Other: "schema %s 不存在"}
	SchemaExistMessage                 = &i18n.Message{ID: "SchemaExistMessage", Other: "schema %s 已存在"}
	TableNotExistMessage               = &i18n.Message{ID: "TableNotExistMessage", Other: "表 %s 不存在"}
	TableExistMessage                  = &i18n.Message{ID: "TableExistMessage", Other: "表 %s 已存在"}
	ColumnNotExistMessage              = &i18n.Message{ID: "ColumnNotExistMessage", Other: "字段 %s 不存在"}
	ColumnExistMessage                 = &i18n.Message{ID: "ColumnExistMessage", Other: "字段 %s 已存在"}
	ColumnIsAmbiguousMessage           = &i18n.Message{ID: "ColumnIsAmbiguousMessage", Other: "字段 %s 指代不明"}
	IndexNotExistMessage               = &i18n.Message{ID: "IndexNotExistMessage", Other: "索引 %s 不存在"}
	IndexExistMessage                  = &i18n.Message{ID: "IndexExistMessage", Other: "索引 %s 已存在"}
	DuplicateColumnsMessage            = &i18n.Message{ID: "DuplicateColumnsMessage", Other: "字段名 %s 重复"}
	DuplicateIndexesMessage            = &i18n.Message{ID: "DuplicateIndexesMessage", Other: "索引名 %s 重复"}
	MultiPrimaryKeyMessage             = &i18n.Message{ID: "MultiPrimaryKeyMessage", Other: "主键只能设置一个"}
	KeyedColumnNotExistMessage         = &i18n.Message{ID: "KeyedColumnNotExistMessage", Other: "索引字段 %s 不存在"}
	PrimaryKeyExistMessage             = &i18n.Message{ID: "PrimaryKeyExistMessage", Other: "已经存在主键，不能再添加"}
	PrimaryKeyNotExistMessage          = &i18n.Message{ID: "PrimaryKeyNotExistMessage", Other: "当前没有主键，不能执行删除"}
	ColumnsValuesNotMatchMessage       = &i18n.Message{ID: "ColumnsValuesNotMatchMessage", Other: "指定的值列数与字段列数不匹配"}
	DuplicatePrimaryKeyedColumnMessage = &i18n.Message{ID: "DuplicatePrimaryKeyedColumnMessage", Other: "主键字段 %s 重复"}
	DuplicateIndexedColumnMessage      = &i18n.Message{ID: "DuplicateIndexedColumnMessage", Other: "索引 %s 字段 %s重复"}

	CheckInvalidErrorFormat = &i18n.Message{ID: "CheckInvalidErrorFormat", Other: "预检查失败: %v"}
	CheckInvalidError       = &i18n.Message{ID: "CheckInvalidError", Other: "预检查失败"}

	UnsupportedSyntaxError = &i18n.Message{ID: "UnsupportedSyntaxError", Other: "语法错误或者解析器不支持，请人工确认SQL正确性"}
	AnonymousMark          = &i18n.Message{ID: "AnonymousMark", Other: "(匿名)"}

	AuditResultMsgWhiteList   = &i18n.Message{ID: "AuditResultMsgWhiteList", Other: "白名单"}
	AuditResultMsgExcludedSQL = &i18n.Message{ID: "AuditResultMsgExcludedSQL", Other: "审核SQL例外"}
)

// mysql
var (
	ParseDDLError     = &i18n.Message{ID: "ParseDDLError", Other: "解析建表语句失败，部分在线审核规则可能失效，请人工确认"}
	GhostDryRunError  = &i18n.Message{ID: "GhostDryRunError", Other: "表空间大小超过%vMB, 将使用gh-ost进行上线, 但是dry-run抛出如下错误: %v"}
	GhostDryRunNotice = &i18n.Message{ID: "GhostDryRunNotice", Other: "表空间大小超过%vMB, 将使用gh-ost进行上线"}
)

// pt_otc
var (
	PTOSCNoUniqueIndexOrPrimaryKey          = &i18n.Message{ID: "PTOSCNoUniqueIndexOrPrimaryKey", Other: "[osc]至少要包含主键或者唯一键索引才能使用 pt-online-schema-change"}
	PTOSCAvoidUniqueIndex                   = &i18n.Message{ID: "PTOSCAvoidUniqueIndex", Other: "[osc]添加唯一键使用 pt-online-schema-change，可能会导致数据丢失，在数据迁移到新表时使用了insert ignore"}
	PTOSCAvoidRenameTable                   = &i18n.Message{ID: "PTOSCAvoidRenameTable", Other: "[osc]pt-online-schema-change 不支持使用rename table 来重命名表"}
	PTOSCAvoidNoDefaultValueOnNotNullColumn = &i18n.Message{ID: "PTOSCAvoidNoDefaultValueOnNotNullColumn", Other: "[osc]非空字段必须设置默认值，不然 pt-online-schema-change 会执行失败"}
)

// rollback
var (
	NotSupportStatementRollback               = &i18n.Message{ID: "NotSupportStatementRollback", Other: "暂不支持回滚该类型的语句"}
	NotSupportMultiTableStatementRollback     = &i18n.Message{ID: "NotSupportMultiTableStatementRollback", Other: "暂不支持回滚多表的 DML 语句"}
	NotSupportOnDuplicatStatementRollback     = &i18n.Message{ID: "NotSupportOnDuplicatStatementRollback", Other: "暂不支持回滚 ON DUPLICATE 语句"}
	NotSupportSubQueryStatementRollback       = &i18n.Message{ID: "NotSupportSubQueryStatementRollback", Other: "暂不支持回滚带子查询的语句"}
	NotSupportNoPrimaryKeyTableRollback       = &i18n.Message{ID: "NotSupportNoPrimaryKeyTableRollback", Other: "不支持回滚没有主键的表的DML语句"}
	NotSupportInsertWithoutPrimaryKeyRollback = &i18n.Message{ID: "NotSupportInsertWithoutPrimaryKeyRollback", Other: "不支持回滚 INSERT 没有指定主键的语句"}
	NotSupportParamMarkerStatementRollback    = &i18n.Message{ID: "NotSupportParamMarkerStatementRollback", Other: "不支持回滚包含指纹的语句"}
	NotSupportHasVariableRollback             = &i18n.Message{ID: "NotSupportHasVariableRollback", Other: "不支持回滚包含变量的 DML 语句"}
	NotSupportExceedMaxRowsRollback           = &i18n.Message{ID: "NotSupportExceedMaxRowsRollback", Other: "预计影响行数超过配置的最大值，不生成回滚语句"}
)

// rule Category
var (
	RuleTypeGlobalConfig             = &i18n.Message{ID: "RuleTypeGlobalConfig", Other: "全局配置"}
	RuleTypeNamingConvention         = &i18n.Message{ID: "RuleTypeNamingConvention", Other: "命名规范"}
	RuleTypeIndexingConvention       = &i18n.Message{ID: "RuleTypeIndexingConvention", Other: "索引规范"}
	RuleTypeDDLConvention            = &i18n.Message{ID: "RuleTypeDDLConvention", Other: "DDL规范"}
	RuleTypeDMLConvention            = &i18n.Message{ID: "RuleTypeDMLConvention", Other: "DML规范"}
	RuleTypeDQLConvention            = &i18n.Message{ID: "RuleTypeDQLConvention", Other: "DQL规范"}
	RuleTypeUsageSuggestion          = &i18n.Message{ID: "RuleTypeUsageSuggestion", Other: "使用建议"}
	RuleTypeIndexOptimization        = &i18n.Message{ID: "RuleTypeIndexOptimization", Other: "索引优化"}
	RuleTypeIndexInvalidation        = &i18n.Message{ID: "RuleTypeIndexInvalidation", Other: "索引失效"}
	RuleTypeExecutePlan              = &i18n.Message{ID: "RuleTypeExecutePlan", Other: "执行计划"}
	RuleTypeDistributedConvention    = &i18n.Message{ID: "RuleTypeDistributedConvention", Other: "分布式规范"}
	RuleCategoryOperand              = &i18n.Message{ID: "operand", Other: "操作对象"}
	RuleCategorySQL                  = &i18n.Message{ID: "sql", Other: "SQL分类"}
	RuleCategoryAuditPurpose         = &i18n.Message{ID: "audit_purpose", Other: "审核目的"}
	RuleCategoryAuditAccuracy        = &i18n.Message{ID: "audit_accuracy", Other: "审核精度"}
	RuleCategoryAuditPerformanceCost = &i18n.Message{ID: "performance_cost", Other: "审核性能消耗"}
	RuleTagDatabase                  = &i18n.Message{ID: "database", Other: "数据库"}
	RuleTagTablespace                = &i18n.Message{ID: "table_space", Other: "表空间"}
	RuleTagSQLTablespace             = &i18n.Message{ID: "sql_table_space", Other: "表空间"}
	RuleTagTable                     = &i18n.Message{ID: "table", Other: "表"}
	RuleTagColumn                    = &i18n.Message{ID: "column", Other: "字段"}
	RuleTagIndex                     = &i18n.Message{ID: "index", Other: "索引"}
	RuleTagView                      = &i18n.Message{ID: "view", Other: "视图"}
	RuleTagSQLView                   = &i18n.Message{ID: "sql_view", Other: "视图"}
	RuleTagProcedure                 = &i18n.Message{ID: "procedure", Other: "存储过程"}
	RuleTagSQLProcedure              = &i18n.Message{ID: "sql_procedure", Other: "存储过程"}
	RuleTagFunction                  = &i18n.Message{ID: "function", Other: "函数"}
	RuleTagSQLFunction               = &i18n.Message{ID: "sql_function", Other: "函数"}
	RuleTagTrigger                   = &i18n.Message{ID: "trigger", Other: "触发器"}
	RuleTagSQLTrigger                = &i18n.Message{ID: "sql_trigger", Other: "触发器"}
	RuleTagEvent                     = &i18n.Message{ID: "event", Other: "事件"}
	RuleTagUser                      = &i18n.Message{ID: "user", Other: "用户"}
	RuleTagSequence                  = &i18n.Message{ID: "sequence", Other: "序列"}
	RuleTagBusiness                  = &i18n.Message{ID: "business", Other: "业务数据"}
	RuleTagDML                       = &i18n.Message{ID: "dml", Other: "DML"}
	RuleTagDDL                       = &i18n.Message{ID: "ddl", Other: "DDL"}
	RuleTagDCL                       = &i18n.Message{ID: "dcl", Other: "DCL"}
	RuleTagIntegrity                 = &i18n.Message{ID: "integrity", Other: "完整性约束"}
	RuleTagComplete                  = &i18n.Message{ID: "complete", Other: "完全性约束"}
	RuleTagQuery                     = &i18n.Message{ID: "query", Other: "查询"}
	RuleTagJoin                      = &i18n.Message{ID: "join", Other: "连接"}
	RuleTagTransaction               = &i18n.Message{ID: "transaction", Other: "事务控制"}
	RuleTagPrivilege                 = &i18n.Message{ID: "privilege", Other: "数据权限"}
	RuleTagManagement                = &i18n.Message{ID: "management", Other: "数据库管理"}
	RuleTagPerformance               = &i18n.Message{ID: "performance", Other: "性能问题"}
	RuleTagMaintenance               = &i18n.Message{ID: "maintenance", Other: "可维护性"}
	RuleTagSecurity                  = &i18n.Message{ID: "security", Other: "安全性"}
	RuleTagCorrection                = &i18n.Message{ID: "correction", Other: "正确性"}
	RuleTagOnline                    = &i18n.Message{ID: "online", Other: "在线"}
	RuleTagOffline                   = &i18n.Message{ID: "offline", Other: "离线"}
	RuleTagPerformanceCostHigh       = &i18n.Message{ID: "high", Other: "高消耗"}
	RuleTagPerformanceCostMedium     = &i18n.Message{ID: "medium", Other: "中消耗"}
	RuleTagPerformanceCostLow        = &i18n.Message{ID: "low", Other: "低消耗"}
)

// rule list
var (
	DMLNotAllowInsertAutoincrementDesc                           = &i18n.Message{ID: "DMLNotAllowInsertAutoincrementDesc", Other: "禁止手动设置自增字段值"}
	DMLNotAllowInsertAutoincrementAnnotation                     = &i18n.Message{ID: "DMLNotAllowInsertAutoincrementAnnotation", Other: "手动赋值可能会造成数据空洞，主键冲突"}
	DMLNotAllowInsertAutoincrementMessage                        = &i18n.Message{ID: "DMLNotAllowInsertAutoincrementMessage", Other: "禁止手动设置自增字段值"}
	ConfigDMLRollbackMaxRowsDesc                                 = &i18n.Message{ID: "ConfigDMLRollbackMaxRowsDesc", Other: "在 DML 语句中预计影响行数超过指定值则不回滚"}
	ConfigDMLRollbackMaxRowsAnnotation                           = &i18n.Message{ID: "ConfigDMLRollbackMaxRowsAnnotation", Other: "大事务回滚，容易影响数据库性能，使得业务发生波动；具体规则阈值可以根据业务需求调整，默认值：1000"}
	ConfigDMLRollbackMaxRowsParams1                              = &i18n.Message{ID: "ConfigDMLRollbackMaxRowsParams1", Other: "最大影响行数"}
	ConfigDDLOSCMinSizeDesc                                      = &i18n.Message{ID: "ConfigDDLOSCMinSizeDesc", Other: "改表时，表空间超过指定大小(MB)审核时输出osc改写建议"}
	ConfigDDLOSCMinSizeAnnotation                                = &i18n.Message{ID: "ConfigDDLOSCMinSizeAnnotation", Other: "开启该规则后会对大表的DDL语句给出 pt-osc工具的改写建议【需要参考命令进行手工执行，后续会支持自动执行】；直接对大表进行DDL变更时可能会导致长时间锁表问题，影响业务可持续性。具体对大表定义的阈值可以根据业务需求调整，默认值：1024"}
	ConfigDDLOSCMinSizeParams1                                   = &i18n.Message{ID: "ConfigDDLOSCMinSizeParams1", Other: "表空间大小（MB）"}
	DDLCheckTableSizeDesc                                        = &i18n.Message{ID: "DDLCheckTableSizeDesc", Other: "不建议对数据量过大的表执行DDL操作"}
	DDLCheckTableSizeAnnotation                                  = &i18n.Message{ID: "DDLCheckTableSizeAnnotation", Other: "大表执行DDL，耗时较久且负载较高，长时间占用锁资源，会影响数据库性能；具体规则阈值可以根据业务需求调整，默认值：1024"}
	DDLCheckTableSizeMessage                                     = &i18n.Message{ID: "DDLCheckTableSizeMessage", Other: "执行DDL的表 %v 空间不建议超过 %vMB"}
	DDLCheckTableSizeParams1                                     = &i18n.Message{ID: "DDLCheckTableSizeParams1", Other: "表空间大小（MB）"}
	DDLCheckIndexTooManyDesc                                     = &i18n.Message{ID: "DDLCheckIndexTooManyDesc", Other: "单字段上的索引数量不建议超过阈值"}
	DDLCheckIndexTooManyAnnotation                               = &i18n.Message{ID: "DDLCheckIndexTooManyAnnotation", Other: "单字段上存在过多索引，一般情况下这些索引都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大；具体规则阈值可以根据业务需求调整，默认值：2"}
	DDLCheckIndexTooManyMessage                                  = &i18n.Message{ID: "DDLCheckIndexTooManyMessage", Other: "字段 %v 上的索引数量不建议超过%v个"}
	DDLCheckIndexTooManyParams1                                  = &i18n.Message{ID: "DDLCheckIndexTooManyParams1", Other: "单字段的索引数最大值"}
	ConfigDMLExplainPreCheckEnableDesc                           = &i18n.Message{ID: "ConfigDMLExplainPreCheckEnableDesc", Other: "使用EXPLAIN加强预检查能力"}
	ConfigDMLExplainPreCheckEnableAnnotation                     = &i18n.Message{ID: "ConfigDMLExplainPreCheckEnableAnnotation", Other: "通过 EXPLAIN 的形式将待上线的DML进行SQL是否能正确执行的检查，提前发现语句的错误，提高上线成功率"}
	DDLCheckRedundantIndexDesc                                   = &i18n.Message{ID: "DDLCheckRedundantIndexDesc", Other: "不建议创建冗余索引"}
	DDLCheckRedundantIndexAnnotation                             = &i18n.Message{ID: "DDLCheckRedundantIndexAnnotation", Other: "MySQL需要单独维护重复的索引，冗余索引增加维护成本，并且优化器在优化查询时需要逐个进行代价计算，影响查询性能"}
	DDLCheckRedundantIndexMessage                                = &i18n.Message{ID: "DDLCheckRedundantIndexMessage", Other: "%v"}
	DMLCheckTableSizeDesc                                        = &i18n.Message{ID: "DMLCheckTableSizeDesc", Other: "不建议对数据量过大的表执行DML操作"}
	DMLCheckTableSizeAnnotation                                  = &i18n.Message{ID: "DMLCheckTableSizeAnnotation", Other: "DML操作大表，耗时较久且负载较高，容易影响数据库性能；具体规则阈值可以根据业务需求调整，默认值：1024"}
	DMLCheckTableSizeMessage                                     = &i18n.Message{ID: "DMLCheckTableSizeMessage", Other: "执行DML的表 %v 空间不建议超过 %vMB"}
	DMLCheckTableSizeParams1                                     = &i18n.Message{ID: "DMLCheckTableSizeParams1", Other: "表空间大小（MB）"}
	ConfigOptimizeIndexEnabledDesc                               = &i18n.Message{ID: "ConfigOptimizeIndexEnabledDesc", Other: "索引创建建议"}
	ConfigOptimizeIndexEnabledAnnotation                         = &i18n.Message{ID: "ConfigOptimizeIndexEnabledAnnotation", Other: "通过该规则开启索引优化建议，提供两个参数配置来定义索引优化建议的行为。1. 列区分度最低值阈值（百分制）：配置当前表中列的区分度小于多少时，不作为索引的列；2. 联合索引最大列数：限制联合索引给到的列数最大值，防止给出建议的联合索引不符合其他SQL标准"}
	ConfigOptimizeIndexEnabledParams1                            = &i18n.Message{ID: "ConfigOptimizeIndexEnabledParams1", Other: "列区分度最低值阈值（百分比）"}
	ConfigOptimizeIndexEnabledParams2                            = &i18n.Message{ID: "ConfigOptimizeIndexEnabledParams2", Other: "联合索引最大列数"}
	ConfigSQLIsExecutedDesc                                      = &i18n.Message{ID: "ConfigSQLIsExecutedDesc", Other: "停用上线审核模式"}
	ConfigSQLIsExecutedAnnotation                                = &i18n.Message{ID: "ConfigSQLIsExecutedAnnotation", Other: "启用该规则来兼容事后审核的场景，对于事后采集的DDL 和 DML 语句将不再进行上线校验。例如库表元数据的扫描任务可开启该规则"}
	ConfigDDLGhostMinSizeDesc                                    = &i18n.Message{ID: "ConfigDDLGhostMinSizeDesc", Other: "改表时，表空间超过指定大小(MB)时使用gh-ost上线"}
	ConfigDDLGhostMinSizeAnnotation                              = &i18n.Message{ID: "ConfigDDLGhostMinSizeAnnotation", Other: "开启该规则后会自动对大表的DDL操作使用gh-ost 工具进行在线改表；直接对大表进行DDL变更时可能会导致长时间锁表问题，影响业务可持续性。具体对大表定义的阈值可以根据业务需求调整，默认值：1024"}
	ConfigDDLGhostMinSizeParams1                                 = &i18n.Message{ID: "ConfigDDLGhostMinSizeParams1", Other: "表空间大小（MB）"}
	DDLCheckPKWithoutIfNotExistsDesc                             = &i18n.Message{ID: "DDLCheckPKWithoutIfNotExistsDesc", Other: "新建表建议加入 IF NOT EXISTS，保证重复执行不报错"}
	DDLCheckPKWithoutIfNotExistsAnnotation                       = &i18n.Message{ID: "DDLCheckPKWithoutIfNotExistsAnnotation", Other: "新建表如果表已经存在，不添加IF NOT EXISTS CREATE执行SQL会报错，建议开启此规则，避免SQL实际执行报错"}
	DDLCheckPKWithoutIfNotExistsMessage                          = &i18n.Message{ID: "DDLCheckPKWithoutIfNotExistsMessage", Other: "新建表建议加入 IF NOT EXISTS，保证重复执行不报错"}
	DDLCheckObjectNameLengthDesc                                 = &i18n.Message{ID: "DDLCheckObjectNameLengthDesc", Other: "表名、列名、索引名的长度不建议超过阈值"}
	DDLCheckObjectNameLengthAnnotation                           = &i18n.Message{ID: "DDLCheckObjectNameLengthAnnotation", Other: "通过配置该规则可以规范指定业务的对象命名长度，具体长度可以自定义设置，默认最大长度：64。是MySQL规定标识符命名最大长度为64字节"}
	DDLCheckObjectNameLengthMessage                              = &i18n.Message{ID: "DDLCheckObjectNameLengthMessage", Other: "表名、列名、索引名的长度不建议大于%v字节"}
	DDLCheckObjectNameLengthParams1                              = &i18n.Message{ID: "DDLCheckObjectNameLengthParams1", Other: "最大长度（字节）"}
	DDLCheckObjectNameIsUpperAndLowerLetterMixedDesc             = &i18n.Message{ID: "DDLCheckObjectNameIsUpperAndLowerLetterMixedDesc", Other: "数据库对象命名不建议大小写字母混合"}
	DDLCheckObjectNameIsUpperAndLowerLetterMixedAnnotation       = &i18n.Message{ID: "DDLCheckObjectNameIsUpperAndLowerLetterMixedAnnotation", Other: "数据库对象命名规范，不推荐采用大小写混用的形式建议词语之间使用下划线连接，提高代码可读性"}
	DDLCheckObjectNameIsUpperAndLowerLetterMixedMessage          = &i18n.Message{ID: "DDLCheckObjectNameIsUpperAndLowerLetterMixedMessage", Other: "数据库对象命名不建议大小写字母混合，以下对象命名不规范：%v"}
	DDLCheckPKNotExistDesc                                       = &i18n.Message{ID: "DDLCheckPKNotExistDesc", Other: "表必须有主键"}
	DDLCheckPKNotExistAnnotation                                 = &i18n.Message{ID: "DDLCheckPKNotExistAnnotation", Other: "主键使数据达到全局唯一，可提高数据检索效率"}
	DDLCheckPKNotExistMessage                                    = &i18n.Message{ID: "DDLCheckPKNotExistMessage", Other: "表必须有主键"}
	DDLCheckPKWithoutAutoIncrementDesc                           = &i18n.Message{ID: "DDLCheckPKWithoutAutoIncrementDesc", Other: "主键建议使用自增"}
	DDLCheckPKWithoutAutoIncrementAnnotation                     = &i18n.Message{ID: "DDLCheckPKWithoutAutoIncrementAnnotation", Other: "自增主键，数字型速度快，而且是增量增长，占用空间小，更快速的做数据插入操作，避免增加维护索引的开销"}
	DDLCheckPKWithoutAutoIncrementMessage                        = &i18n.Message{ID: "DDLCheckPKWithoutAutoIncrementMessage", Other: "主键建议使用自增"}
	DDLCheckPKWithoutBigintUnsignedDesc                          = &i18n.Message{ID: "DDLCheckPKWithoutBigintUnsignedDesc", Other: "主键建议使用 BIGINT 无符号类型，即 BIGINT UNSIGNED"}
	DDLCheckPKWithoutBigintUnsignedAnnotation                    = &i18n.Message{ID: "DDLCheckPKWithoutBigintUnsignedAnnotation", Other: "BIGINT UNSIGNED拥有更大的取值范围，建议开启此规则，避免发生溢出"}
	DDLCheckPKWithoutBigintUnsignedMessage                       = &i18n.Message{ID: "DDLCheckPKWithoutBigintUnsignedMessage", Other: "主键建议使用 BIGINT 无符号类型，即 BIGINT UNSIGNED"}
	DMLCheckJoinFieldTypeDesc                                    = &i18n.Message{ID: "DMLCheckJoinFieldTypeDesc", Other: "建议JOIN字段类型保持一致"}
	DMLCheckJoinFieldTypeAnnotation                              = &i18n.Message{ID: "DMLCheckJoinFieldTypeAnnotation", Other: "JOIN字段类型不一致会导致类型不匹配发生隐式准换，建议开启此规则，避免索引失效"}
	DMLCheckJoinFieldTypeMessage                                 = &i18n.Message{ID: "DMLCheckJoinFieldTypeMessage", Other: "建议JOIN字段类型保持一致, 否则会导致隐式转换"}
	DMLCheckHasJoinConditionDesc                                 = &i18n.Message{ID: "DMLCheckHasJoinConditionDesc", Other: "建议连接操作指定连接条件"}
	DMLCheckHasJoinConditionAnnotation                           = &i18n.Message{ID: "DMLCheckHasJoinConditionAnnotation", Other: "指定连接条件可以确保连接操作的正确性和可靠性，如果没有指定连接条件，可能会导致连接失败或连接不正确的情况。"}
	DMLCheckHasJoinConditionMessage                              = &i18n.Message{ID: "DMLCheckHasJoinConditionMessage", Other: "建议连接操作指定连接条件，JOIN字段后必须有ON条件"}
	DDLCheckColumnCharLengthDesc                                 = &i18n.Message{ID: "DDLCheckColumnCharLengthDesc", Other: "CHAR长度大于20时，必须使用VARCHAR类型"}
	DDLCheckColumnCharLengthAnnotation                           = &i18n.Message{ID: "DDLCheckColumnCharLengthAnnotation", Other: "VARCHAR是变长字段，存储空间小，可节省存储空间，同时相对较小的字段检索效率显然也要高些"}
	DDLCheckColumnCharLengthMessage                              = &i18n.Message{ID: "DDLCheckColumnCharLengthMessage", Other: "CHAR长度大于20时，必须使用VARCHAR类型"}
	DDLCheckFieldNotNUllMustContainDefaultValueDesc              = &i18n.Message{ID: "DDLCheckFieldNotNUllMustContainDefaultValueDesc", Other: "建议字段约束为NOT NULL时带默认值"}
	DDLCheckFieldNotNUllMustContainDefaultValueAnnotation        = &i18n.Message{ID: "DDLCheckFieldNotNUllMustContainDefaultValueAnnotation", Other: "如存在NOT NULL且不带默认值的字段，INSERT时不包含该字段，会导致插入报错"}
	DDLCheckFieldNotNUllMustContainDefaultValueMessage           = &i18n.Message{ID: "DDLCheckFieldNotNUllMustContainDefaultValueMessage", Other: "建议字段约束为NOT NULL时带默认值，以下字段不规范:%v"}
	DDLDisableFKDesc                                             = &i18n.Message{ID: "DDLDisableFKDesc", Other: "禁止使用外键"}
	DDLDisableFKAnnotation                                       = &i18n.Message{ID: "DDLDisableFKAnnotation", Other: "外键在高并发场景下性能较差，容易造成死锁，同时不利于后期维护（拆分、迁移）"}
	DDLDisableFKMessage                                          = &i18n.Message{ID: "DDLDisableFKMessage", Other: "禁止使用外键"}
	DDLDisableAlterFieldUseFirstAndAfterDesc                     = &i18n.Message{ID: "DDLDisableAlterFieldUseFirstAndAfterDesc", Other: "ALTER表字段禁止使用FIRST,AFTER"}
	DDLDisableAlterFieldUseFirstAndAfterAnnotation               = &i18n.Message{ID: "DDLDisableAlterFieldUseFirstAndAfterAnnotation", Other: "FIRST,AFTER 的ALTER操作通过COPY TABLE的方式完成，对业务影响较大"}
	DDLDisableAlterFieldUseFirstAndAfterMessage                  = &i18n.Message{ID: "DDLDisableAlterFieldUseFirstAndAfterMessage", Other: "ALTER表字段禁止使用FIRST,AFTER"}
	DDLCheckCreateTimeColumnDesc                                 = &i18n.Message{ID: "DDLCheckCreateTimeColumnDesc", Other: "建议建表DDL包含创建时间字段且默认值为CURRENT_TIMESTAMP"}
	DDLCheckCreateTimeColumnAnnotation                           = &i18n.Message{ID: "DDLCheckCreateTimeColumnAnnotation", Other: "使用CREATE_TIME字段，有利于问题查找跟踪和检索数据，同时避免后期对数据生命周期管理不便 ，默认值为CURRENT_TIMESTAMP可保证时间的准确性"}
	DDLCheckCreateTimeColumnMessage                              = &i18n.Message{ID: "DDLCheckCreateTimeColumnMessage", Other: "建议建表DDL包含%v字段且默认值为CURRENT_TIMESTAMP"}
	DDLCheckCreateTimeColumnParams1                              = &i18n.Message{ID: "DDLCheckCreateTimeColumnParams1", Other: "创建时间字段名"}
	DDLCheckIndexCountDesc                                       = &i18n.Message{ID: "DDLCheckIndexCountDesc", Other: "索引个数建议不超过阈值"}
	DDLCheckIndexCountAnnotation                                 = &i18n.Message{ID: "DDLCheckIndexCountAnnotation", Other: "在表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销，太多与不充分、不正确的索引对性能都毫无益处；具体规则阈值可以根据业务需求调整，默认值：5"}
	DDLCheckIndexCountMessage                                    = &i18n.Message{ID: "DDLCheckIndexCountMessage", Other: "索引个数建议不超过%v个"}
	DDLCheckIndexCountParams1                                    = &i18n.Message{ID: "DDLCheckIndexCountParams1", Other: "最大索引个数"}
	DDLCheckUpdateTimeColumnDesc                                 = &i18n.Message{ID: "DDLCheckUpdateTimeColumnDesc", Other: "建表DDL需要包含更新时间字段且默认值为CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"}
	DDLCheckUpdateTimeColumnAnnotation                           = &i18n.Message{ID: "DDLCheckUpdateTimeColumnAnnotation", Other: "使用更新时间字段，有利于问题查找跟踪和检索数据，同时避免后期对数据生命周期管理不便 ，默认值为UPDATE_TIME可保证时间的准确性"}
	DDLCheckUpdateTimeColumnMessage                              = &i18n.Message{ID: "DDLCheckUpdateTimeColumnMessage", Other: "建表DDL需要包含%v字段且默认值为CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP"}
	DDLCheckUpdateTimeColumnParams1                              = &i18n.Message{ID: "DDLCheckUpdateTimeColumnParams1", Other: "更新时间字段名"}
	DDLCheckCompositeIndexMaxDesc                                = &i18n.Message{ID: "DDLCheckCompositeIndexMaxDesc", Other: "复合索引的列数量不建议超过阈值"}
	DDLCheckCompositeIndexMaxAnnotation                          = &i18n.Message{ID: "DDLCheckCompositeIndexMaxAnnotation", Other: "复合索引会根据索引列数创建对应组合的索引，列数越多，创建的索引越多，每个索引都会增加磁盘空间的开销，同时增加索引维护的开销；具体规则阈值可以根据业务需求调整，默认值：3"}
	DDLCheckCompositeIndexMaxMessage                             = &i18n.Message{ID: "DDLCheckCompositeIndexMaxMessage", Other: "复合索引的列数量不建议超过%v个"}
	DDLCheckCompositeIndexMaxParams1                             = &i18n.Message{ID: "DDLCheckCompositeIndexMaxParams1", Other: "最大索引列数量"}
	DDLCheckIndexNotNullConstraintDesc                           = &i18n.Message{ID: "DDLCheckIndexNotNullConstraintDesc", Other: "索引字段需要有非空约束"}
	DDLCheckIndexNotNullConstraintAnnotation                     = &i18n.Message{ID: "DDLCheckIndexNotNullConstraintAnnotation", Other: "索引字段上如果没有非空约束，则表记录与索引记录不会完全映射。"}
	DDLCheckIndexNotNullConstraintMessage                        = &i18n.Message{ID: "DDLCheckIndexNotNullConstraintMessage", Other: "这些索引字段(%v)需要有非空约束"}
	DDLCheckObjectNameUsingKeywordDesc                           = &i18n.Message{ID: "DDLCheckObjectNameUsingKeywordDesc", Other: "数据库对象命名禁止使用保留字"}
	DDLCheckObjectNameUsingKeywordAnnotation                     = &i18n.Message{ID: "DDLCheckObjectNameUsingKeywordAnnotation", Other: "通过配置该规则可以规范指定业务的数据对象命名规则，避免发生冲突，以及混淆"}
	DDLCheckObjectNameUsingKeywordMessage                        = &i18n.Message{ID: "DDLCheckObjectNameUsingKeywordMessage", Other: "数据库对象命名禁止使用保留字 %s"}
	DDLCheckObjectNameUseCNDesc                                  = &i18n.Message{ID: "DDLCheckObjectNameUseCNDesc", Other: "数据库对象命名只能使用英文、下划线或数字，首字母必须是英文"}
	DDLCheckObjectNameUseCNAnnotation                            = &i18n.Message{ID: "DDLCheckObjectNameUseCNAnnotation", Other: "通过配置该规则可以规范指定业务的数据对象命名规则"}
	DDLCheckObjectNameUseCNMessage                               = &i18n.Message{ID: "DDLCheckObjectNameUseCNMessage", Other: "数据库对象命名只能使用英文、下划线或数字，首字母必须是英文"}
	DDLCheckTableDBEngineDesc                                    = &i18n.Message{ID: "DDLCheckTableDBEngineDesc", Other: "建议使用指定数据库引擎"}
	DDLCheckTableDBEngineAnnotation                              = &i18n.Message{ID: "DDLCheckTableDBEngineAnnotation", Other: "通过配置该规则可以规范指定业务的数据库引擎，具体规则可以自定义设置。默认值是INNODB，INNODB 支持事务，支持行级锁，更好的恢复性，高并发下性能更好"}
	DDLCheckTableDBEngineMessage                                 = &i18n.Message{ID: "DDLCheckTableDBEngineMessage", Other: "建议使用%v数据库引擎"}
	DDLCheckTableDBEngineParams1                                 = &i18n.Message{ID: "DDLCheckTableDBEngineParams1", Other: "数据库引擎"}
	DDLCheckTableCharacterSetDesc                                = &i18n.Message{ID: "DDLCheckTableCharacterSetDesc", Other: "建议使用指定数据库字符集"}
	DDLCheckTableCharacterSetAnnotation                          = &i18n.Message{ID: "DDLCheckTableCharacterSetAnnotation", Other: "通过该规则约束全局的数据库字符集，避免创建非预期的字符集，防止业务侧出现“乱码”等问题。建议项目内库表使用统一的字符集和字符集排序，部分连表查询的情况下字段的字符集或排序规则不一致可能会导致索引失效且不易发现"}
	DDLCheckTableCharacterSetMessage                             = &i18n.Message{ID: "DDLCheckTableCharacterSetMessage", Other: "建议使用%v数据库字符集"}
	DDLCheckTableCharacterSetParams1                             = &i18n.Message{ID: "DDLCheckTableCharacterSetParams1", Other: "数据库字符集"}
	DDLCheckIndexedColumnWithBlobDesc                            = &i18n.Message{ID: "DDLCheckIndexedColumnWithBlobDesc", Other: "禁止将BLOB类型的列加入索引"}
	DDLCheckIndexedColumnWithBlobAnnotation                      = &i18n.Message{ID: "DDLCheckIndexedColumnWithBlobAnnotation", Other: "BLOB类型属于大字段类型，作为索引会占用很大的存储空间"}
	DDLCheckIndexedColumnWithBlobMessage                         = &i18n.Message{ID: "DDLCheckIndexedColumnWithBlobMessage", Other: "禁止将BLOB类型的列加入索引"}
	DMLCheckWhereIsInvalidDesc                                   = &i18n.Message{ID: "DMLCheckWhereIsInvalidDesc", Other: "禁止使用没有WHERE条件或者WHERE条件恒为TRUE的SQL"}
	DMLCheckWhereIsInvalidAnnotation                             = &i18n.Message{ID: "DMLCheckWhereIsInvalidAnnotation", Other: "SQL缺少WHERE条件在执行时会进行全表扫描产生额外开销，建议在大数据量高并发环境下开启，避免影响数据库查询性能"}
	DMLCheckWhereIsInvalidMessage                                = &i18n.Message{ID: "DMLCheckWhereIsInvalidMessage", Other: "禁止使用没有WHERE条件或者WHERE条件恒为TRUE的SQL"}
	DDLCheckAlterTableNeedMergeDesc                              = &i18n.Message{ID: "DDLCheckAlterTableNeedMergeDesc", Other: "存在多条对同一个表的修改语句，建议合并成一个ALTER语句"}
	DDLCheckAlterTableNeedMergeAnnotation                        = &i18n.Message{ID: "DDLCheckAlterTableNeedMergeAnnotation", Other: "避免多次 TABLE REBUILD 带来的消耗、以及对线上业务的影响"}
	DDLCheckAlterTableNeedMergeMessage                           = &i18n.Message{ID: "DDLCheckAlterTableNeedMergeMessage", Other: "已存在对该表的修改语句，建议合并成一个ALTER语句"}
	DMLDisableSelectAllColumnDesc                                = &i18n.Message{ID: "DMLDisableSelectAllColumnDesc", Other: "不建议使用SELECT *"}
	DMLDisableSelectAllColumnAnnotation                          = &i18n.Message{ID: "DMLDisableSelectAllColumnAnnotation", Other: "当表结构变更时，使用*通配符选择所有列将导致查询行为会发生更改，与业务期望不符；同时SELECT * 中的无用字段会带来不必要的磁盘I/O，以及网络开销，且无法覆盖索引进而回表，大幅度降低查询效率"}
	DMLDisableSelectAllColumnMessage                             = &i18n.Message{ID: "DMLDisableSelectAllColumnMessage", Other: "不建议使用SELECT *"}
	DDLDisableDropStatementDesc                                  = &i18n.Message{ID: "DDLDisableDropStatementDesc", Other: "禁止除索引外的DROP操作"}
	DDLDisableDropStatementAnnotation                            = &i18n.Message{ID: "DDLDisableDropStatementAnnotation", Other: "DROP是DDL，数据变更不会写入日志，无法进行回滚；建议开启此规则，避免误删除操作"}
	DDLDisableDropStatementMessage                               = &i18n.Message{ID: "DDLDisableDropStatementMessage", Other: "禁止除索引外的DROP操作"}
	DDLCheckTableWithoutCommentDesc                              = &i18n.Message{ID: "DDLCheckTableWithoutCommentDesc", Other: "表建议添加注释"}
	DDLCheckTableWithoutCommentAnnotation                        = &i18n.Message{ID: "DDLCheckTableWithoutCommentAnnotation", Other: "表添加注释能够使表的意义更明确，方便日后的维护"}
	DDLCheckTableWithoutCommentMessage                           = &i18n.Message{ID: "DDLCheckTableWithoutCommentMessage", Other: "表建议添加注释"}
	DDLCheckColumnWithoutCommentDesc                             = &i18n.Message{ID: "DDLCheckColumnWithoutCommentDesc", Other: "列建议添加注释"}
	DDLCheckColumnWithoutCommentAnnotation                       = &i18n.Message{ID: "DDLCheckColumnWithoutCommentAnnotation", Other: "列添加注释能够使列的意义更明确，方便日后的维护"}
	DDLCheckColumnWithoutCommentMessage                          = &i18n.Message{ID: "DDLCheckColumnWithoutCommentMessage", Other: "列建议添加注释"}
	DDLCheckIndexPrefixDesc                                      = &i18n.Message{ID: "DDLCheckIndexPrefixDesc", Other: "建议普通索引使用固定前缀"}
	DDLCheckIndexPrefixAnnotation                                = &i18n.Message{ID: "DDLCheckIndexPrefixAnnotation", Other: "通过配置该规则可以规范指定业务的索引命名规则，具体命名规范可以自定义设置，默认提示值：idx_"}
	DDLCheckIndexPrefixMessage                                   = &i18n.Message{ID: "DDLCheckIndexPrefixMessage", Other: "建议普通索引要以\"%v\"为前缀"}
	DDLCheckIndexPrefixParams1                                   = &i18n.Message{ID: "DDLCheckIndexPrefixParams1", Other: "索引前缀"}
	DDLCheckUniqueIndexPrefixDesc                                = &i18n.Message{ID: "DDLCheckUniqueIndexPrefixDesc", Other: "建议UNIQUE索引使用固定前缀"}
	DDLCheckUniqueIndexPrefixAnnotation                          = &i18n.Message{ID: "DDLCheckUniqueIndexPrefixAnnotation", Other: "通过配置该规则可以规范指定业务的UNIQUE索引命名规则，具体命名规范可以自定义设置，默认提示值：uniq_"}
	DDLCheckUniqueIndexPrefixMessage                             = &i18n.Message{ID: "DDLCheckUniqueIndexPrefixMessage", Other: "建议UNIQUE索引要以\"%v\"为前缀"}
	DDLCheckUniqueIndexPrefixParams1                             = &i18n.Message{ID: "DDLCheckUniqueIndexPrefixParams1", Other: "索引前缀"}
	DDLCheckUniqueIndexDesc                                      = &i18n.Message{ID: "DDLCheckUniqueIndexDesc", Other: "建议UNIQUE索引名使用 IDX_UK_表名_字段名"}
	DDLCheckUniqueIndexAnnotation                                = &i18n.Message{ID: "DDLCheckUniqueIndexAnnotation", Other: "通过配置该规则可以规范指定业务的UNIQUE索引命名规则"}
	DDLCheckUniqueIndexMessage                                   = &i18n.Message{ID: "DDLCheckUniqueIndexMessage", Other: "建议UNIQUE索引名使用 IDX_UK_表名_字段名"}
	DDLCheckColumnWithoutDefaultDesc                             = &i18n.Message{ID: "DDLCheckColumnWithoutDefaultDesc", Other: "除了自增列及大字段列之外，每个列都必须添加默认值"}
	DDLCheckColumnWithoutDefaultAnnotation                       = &i18n.Message{ID: "DDLCheckColumnWithoutDefaultAnnotation", Other: "列添加默认值，可避免列为NULL值时对查询的影响"}
	DDLCheckColumnWithoutDefaultMessage                          = &i18n.Message{ID: "DDLCheckColumnWithoutDefaultMessage", Other: "除了自增列及大字段列之外，每个列都必须添加默认值"}
	DDLCheckColumnTimestampWithoutDefaultDesc                    = &i18n.Message{ID: "DDLCheckColumnTimestampWithoutDefaultDesc", Other: "TIMESTAMP 类型的列必须添加默认值"}
	DDLCheckColumnTimestampWithoutDefaultAnnotation              = &i18n.Message{ID: "DDLCheckColumnTimestampWithoutDefaultAnnotation", Other: "TIMESTAMP添加默认值，可避免出现全为0的日期格式与业务预期不符"}
	DDLCheckColumnTimestampWithoutDefaultMessage                 = &i18n.Message{ID: "DDLCheckColumnTimestampWithoutDefaultMessage", Other: "TIMESTAMP 类型的列必须添加默认值"}
	DDLCheckColumnBlobWithNotNullDesc                            = &i18n.Message{ID: "DDLCheckColumnBlobWithNotNullDesc", Other: "BLOB 和 TEXT 类型的字段不建议设置为 NOT NULL"}
	DDLCheckColumnBlobWithNotNullAnnotation                      = &i18n.Message{ID: "DDLCheckColumnBlobWithNotNullAnnotation", Other: "BLOB 和 TEXT 类型的字段无法指定默认值，如插入数据不指定字段默认为NULL，如果添加了 NOT NULL 限制，写入数据时又未对该字段指定值会导致写入失败"}
	DDLCheckColumnBlobWithNotNullMessage                         = &i18n.Message{ID: "DDLCheckColumnBlobWithNotNullMessage", Other: "BLOB 和 TEXT 类型的字段不建议设置为 NOT NULL"}
	DDLCheckColumnBlobDefaultIsNotNullDesc                       = &i18n.Message{ID: "DDLCheckColumnBlobDefaultIsNotNullDesc", Other: "BLOB 和 TEXT 类型的字段默认值只能为NULL"}
	DDLCheckColumnBlobDefaultIsNotNullAnnotation                 = &i18n.Message{ID: "DDLCheckColumnBlobDefaultIsNotNullAnnotation", Other: "在SQL_MODE严格模式下BLOB 和 TEXT 类型无法设置默认值，如插入数据不指定值，字段会被设置为NULL"}
	DDLCheckColumnBlobDefaultIsNotNullMessage                    = &i18n.Message{ID: "DDLCheckColumnBlobDefaultIsNotNullMessage", Other: "BLOB 和 TEXT 类型的字段默认值只能为NULL"}
	DDLCheckAutoIncrementFieldNumDesc                            = &i18n.Message{ID: "DDLCheckAutoIncrementFieldNumDesc", Other: "建表时，自增字段只能设置一个"}
	DDLCheckAutoIncrementFieldNumAnnotation                      = &i18n.Message{ID: "DDLCheckAutoIncrementFieldNumAnnotation", Other: "MySQL InnoDB，MyISAM 引擎不允许存在多个自增字段，设置多个自增字段会导致上线失败。"}
	DDLCheckAutoIncrementFieldNumMessage                         = &i18n.Message{ID: "DDLCheckAutoIncrementFieldNumMessage", Other: "建表时，自增字段只能设置一个"}
	DDLCheckAllIndexNotNullConstraintDesc                        = &i18n.Message{ID: "DDLCheckAllIndexNotNullConstraintDesc", Other: "建议为至少一个索引添加非空约束"}
	DDLCheckAllIndexNotNullConstraintAnnotation                  = &i18n.Message{ID: "DDLCheckAllIndexNotNullConstraintAnnotation", Other: "所有索引字段均未做非空约束，请确认下表索引规划的合理性。"}
	DDLCheckAllIndexNotNullConstraintMessage                     = &i18n.Message{ID: "DDLCheckAllIndexNotNullConstraintMessage", Other: "建议为至少一个索引添加非空约束"}
	DMLCheckWithLimitDesc                                        = &i18n.Message{ID: "DMLCheckWithLimitDesc", Other: "DELETE/UPDATE 语句不能有LIMIT条件"}
	DMLCheckWithLimitAnnotation                                  = &i18n.Message{ID: "DMLCheckWithLimitAnnotation", Other: "DELETE/UPDATE 语句使用LIMIT条件将随机选取数据进行删除或者更新，业务无法预期"}
	DMLCheckWithLimitMessage                                     = &i18n.Message{ID: "DMLCheckWithLimitMessage", Other: "DELETE/UPDATE 语句不能有LIMIT条件"}
	DMLCheckSelectLimitDesc                                      = &i18n.Message{ID: "DMLCheckSelectLimitDesc", Other: "SELECT 语句需要带LIMIT"}
	DMLCheckSelectLimitAnnotation                                = &i18n.Message{ID: "DMLCheckSelectLimitAnnotation", Other: "如果查询的扫描行数很大，可能会导致优化器选择错误的索引甚至不走索引；具体规则阈值可以根据业务需求调整，默认值：1000"}
	DMLCheckSelectLimitMessage                                   = &i18n.Message{ID: "DMLCheckSelectLimitMessage", Other: "SELECT 语句需要带LIMIT,且限制数不得超过%v"}
	DMLCheckSelectLimitParams1                                   = &i18n.Message{ID: "DMLCheckSelectLimitParams1", Other: "最大查询行数"}
	DMLCheckWithOrderByDesc                                      = &i18n.Message{ID: "DMLCheckWithOrderByDesc", Other: "DELETE/UPDATE 语句不能有ORDER BY"}
	DMLCheckWithOrderByAnnotation                                = &i18n.Message{ID: "DMLCheckWithOrderByAnnotation", Other: "DELETE/UPDATE 存在ORDER BY会使用排序，带来无谓的开销"}
	DMLCheckWithOrderByMessage                                   = &i18n.Message{ID: "DMLCheckWithOrderByMessage", Other: "DELETE/UPDATE 语句不能有ORDER BY"}
	DMLCheckSelectWithOrderByDesc                                = &i18n.Message{ID: "DMLCheckSelectWithOrderByDesc", Other: "SELECT 语句不能有ORDER BY"}
	DMLCheckSelectWithOrderByAnnotation                          = &i18n.Message{ID: "DMLCheckSelectWithOrderByAnnotation", Other: "ORDER BY 对查询性能影响较大，同时不便于优化维护，建议将排序部分放到业务处理"}
	DMLCheckSelectWithOrderByMessage                             = &i18n.Message{ID: "DMLCheckSelectWithOrderByMessage", Other: "SELECT 语句不能有ORDER BY"}
	DMLCheckInsertColumnsExistDesc                               = &i18n.Message{ID: "DMLCheckInsertColumnsExistDesc", Other: "INSERT 语句需要指定COLUMN"}
	DMLCheckInsertColumnsExistAnnotation                         = &i18n.Message{ID: "DMLCheckInsertColumnsExistAnnotation", Other: "当表结构发生变更，INSERT请求不明确指定列名，会发生插入数据不匹配的情况；建议开启此规则，避免插入结果与业务预期不符"}
	DMLCheckInsertColumnsExistMessage                            = &i18n.Message{ID: "DMLCheckInsertColumnsExistMessage", Other: "INSERT 语句需要指定COLUMN"}
	DMLCheckBatchInsertListsMaxDesc                              = &i18n.Message{ID: "DMLCheckBatchInsertListsMaxDesc", Other: "单条INSERT语句，建议批量插入不超过阈值"}
	DMLCheckBatchInsertListsMaxAnnotation                        = &i18n.Message{ID: "DMLCheckBatchInsertListsMaxAnnotation", Other: "避免大事务，以及降低发生回滚对业务的影响；具体规则阈值可以根据业务需求调整，默认值：100"}
	DMLCheckBatchInsertListsMaxMessage                           = &i18n.Message{ID: "DMLCheckBatchInsertListsMaxMessage", Other: "单条INSERT语句，建议批量插入不超过%v条"}
	DMLCheckBatchInsertListsMaxParams1                           = &i18n.Message{ID: "DMLCheckBatchInsertListsMaxParams1", Other: "最大插入行数"}
	DMLCheckInQueryNumberDesc                                    = &i18n.Message{ID: "DMLCheckInQueryNumberDesc", Other: "WHERE条件内IN语句中的参数个数不能超过阈值"}
	DMLCheckInQueryNumberAnnotation                              = &i18n.Message{ID: "DMLCheckInQueryNumberAnnotation", Other: "当IN值过多时，有可能会导致查询进行全表扫描，使得MySQL性能急剧下降；具体规则阈值可以根据业务需求调整，默认值：50"}
	DMLCheckInQueryNumberMessage                                 = &i18n.Message{ID: "DMLCheckInQueryNumberMessage", Other: "WHERE条件内IN语句中的参数已有%v个，不建议超过阙值%v"}
	DMLCheckInQueryNumberParams1                                 = &i18n.Message{ID: "DMLCheckInQueryNumberParams1", Other: "in语句参数最大个数"}
	DDLCheckPKProhibitAutoIncrementDesc                          = &i18n.Message{ID: "DDLCheckPKProhibitAutoIncrementDesc", Other: "不建议主键使用自增"}
	DDLCheckPKProhibitAutoIncrementAnnotation                    = &i18n.Message{ID: "DDLCheckPKProhibitAutoIncrementAnnotation", Other: "后期维护相对不便，过于依赖数据库自增机制达到全局唯一，不易拆分，容易造成主键冲突"}
	DDLCheckPKProhibitAutoIncrementMessage                       = &i18n.Message{ID: "DDLCheckPKProhibitAutoIncrementMessage", Other: "不建议主键使用自增"}
	DMLCheckWhereExistFuncDesc                                   = &i18n.Message{ID: "DMLCheckWhereExistFuncDesc", Other: "避免对条件字段使用函数操作"}
	DMLCheckWhereExistFuncAnnotation                             = &i18n.Message{ID: "DMLCheckWhereExistFuncAnnotation", Other: "对条件字段做函数操作，可能会破坏索引值的有序性，导致优化器选择放弃走索引，使查询性能大幅度降低"}
	DMLCheckWhereExistFuncMessage                                = &i18n.Message{ID: "DMLCheckWhereExistFuncMessage", Other: "避免对条件字段使用函数操作"}
	DMLCheckWhereExistNotDesc                                    = &i18n.Message{ID: "DMLCheckWhereExistNotDesc", Other: "不建议对条件字段使用负向查询"}
	DMLCheckWhereExistNotAnnotation                              = &i18n.Message{ID: "DMLCheckWhereExistNotAnnotation", Other: "使用负向查询，将导致全表扫描，出现慢SQL"}
	DMLCheckWhereExistNotMessage                                 = &i18n.Message{ID: "DMLCheckWhereExistNotMessage", Other: "不建议对条件字段使用负向查询"}
	DMLWhereExistNullDesc                                        = &i18n.Message{ID: "DMLWhereExistNullDesc", Other: "不建议对条件字段使用 NULL 值判断"}
	DMLWhereExistNullAnnotation                                  = &i18n.Message{ID: "DMLWhereExistNullAnnotation", Other: "使用 IS NULL 或 IS NOT NULL 可能导致查询放弃使用索引而进行全表扫描"}
	DMLWhereExistNullMessage                                     = &i18n.Message{ID: "DMLWhereExistNullMessage", Other: "不建议对条件字段使用 NULL 值判断"}
	DMLCheckWhereExistImplicitConversionDesc                     = &i18n.Message{ID: "DMLCheckWhereExistImplicitConversionDesc", Other: "不建议在WHERE条件中使用与过滤字段不一致的数据类型"}
	DMLCheckWhereExistImplicitConversionAnnotation               = &i18n.Message{ID: "DMLCheckWhereExistImplicitConversionAnnotation", Other: "WHERE条件中使用与过滤字段不一致的数据类型会引发隐式数据类型转换，导致查询有无法命中索引的风险，在高并发、大数据量的情况下，不走索引会使得数据库的查询性能严重下降"}
	DMLCheckWhereExistImplicitConversionMessage                  = &i18n.Message{ID: "DMLCheckWhereExistImplicitConversionMessage", Other: "不建议在WHERE条件中使用与过滤字段不一致的数据类型"}
	DMLCheckLimitMustExistDesc                                   = &i18n.Message{ID: "DMLCheckLimitMustExistDesc", Other: "建议DELETE/UPDATE 语句带有LIMIT条件"}
	DMLCheckLimitMustExistAnnotation                             = &i18n.Message{ID: "DMLCheckLimitMustExistAnnotation", Other: "LIMIT条件可以降低写错 SQL 的代价（删错数据），同时避免长事务影响业务"}
	DMLCheckLimitMustExistMessage                                = &i18n.Message{ID: "DMLCheckLimitMustExistMessage", Other: "建议DELETE/UPDATE 语句带有LIMIT条件"}
	DMLCheckWhereExistScalarSubqueryDesc                         = &i18n.Message{ID: "DMLCheckWhereExistScalarSubqueryDesc", Other: "不建议使用标量子查询"}
	DMLCheckWhereExistScalarSubqueryAnnotation                   = &i18n.Message{ID: "DMLCheckWhereExistScalarSubqueryAnnotation", Other: "标量子查询存在多次访问同一张表的问题，执行开销大效率低，可使用LEFT JOIN 替代标量子查询"}
	DMLCheckWhereExistScalarSubqueryMessage                      = &i18n.Message{ID: "DMLCheckWhereExistScalarSubqueryMessage", Other: "不建议使用标量子查询"}
	DDLCheckIndexesExistBeforeCreateConstraintsDesc              = &i18n.Message{ID: "DDLCheckIndexesExistBeforeCreateConstraintsDesc", Other: "对字段创建约束前，建议先创建索引"}
	DDLCheckIndexesExistBeforeCreateConstraintsAnnotation        = &i18n.Message{ID: "DDLCheckIndexesExistBeforeCreateConstraintsAnnotation", Other: "创建约束前，先行创建索引，约束可作用于二级索引，避免全表扫描，提高性能"}
	DDLCheckIndexesExistBeforeCreateConstraintsMessage           = &i18n.Message{ID: "DDLCheckIndexesExistBeforeCreateConstraintsMessage", Other: "对字段创建约束前，建议先创建索引"}
	DMLCheckSelectForUpdateDesc                                  = &i18n.Message{ID: "DMLCheckSelectForUpdateDesc", Other: "不建议使用SELECT FOR UPDATE"}
	DMLCheckSelectForUpdateAnnotation                            = &i18n.Message{ID: "DMLCheckSelectForUpdateAnnotation", Other: "SELECT FOR UPDATE 会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞，在高并发下，容易造成数据库大量锁等待，影响数据库查询性能"}
	DMLCheckSelectForUpdateMessage                               = &i18n.Message{ID: "DMLCheckSelectForUpdateMessage", Other: "不建议使用SELECT FOR UPDATE"}
	DDLCheckDatabaseCollationDesc                                = &i18n.Message{ID: "DDLCheckDatabaseCollationDesc", Other: "建议使用规定的数据库排序规则"}
	DDLCheckDatabaseCollationAnnotation                          = &i18n.Message{ID: "DDLCheckDatabaseCollationAnnotation", Other: "通过该规则约束全局的数据库排序规则，避免创建非预期的数据库排序规则，防止业务侧出现排序结果非预期等问题。建议项目内库表使用统一的字符集和字符集排序，部分连表查询的情况下字段的字符集或排序规则不一致可能会导致索引失效且不易发现"}
	DDLCheckDatabaseCollationMessage                             = &i18n.Message{ID: "DDLCheckDatabaseCollationMessage", Other: "建议使用规定的数据库排序规则为%s"}
	DDLCheckDatabaseCollationParams1                             = &i18n.Message{ID: "DDLCheckDatabaseCollationParams1", Other: "数据库排序规则"}
	DDLCheckDecimalTypeColumnDesc                                = &i18n.Message{ID: "DDLCheckDecimalTypeColumnDesc", Other: "精确浮点数建议使用DECIMAL"}
	DDLCheckDecimalTypeColumnAnnotation                          = &i18n.Message{ID: "DDLCheckDecimalTypeColumnAnnotation", Other: "对于浮点数运算，DECIMAL精确度较高"}
	DDLCheckDecimalTypeColumnMessage                             = &i18n.Message{ID: "DDLCheckDecimalTypeColumnMessage", Other: "精确浮点数建议使用DECIMAL"}
	DDLCheckBigintInsteadOfDecimalDesc                           = &i18n.Message{ID: "DDLCheckBigintInsteadOfDecimalDesc", Other: "建议用BIGINT类型代替DECIMAL"}
	DDLCheckBigintInsteadOfDecimalAnnotation                     = &i18n.Message{ID: "DDLCheckBigintInsteadOfDecimalAnnotation", Other: "因为CPU不支持对DECIMAL的直接运算，只是MySQL自身实现了DECIMAL的高精度计算，但是计算代价高，并且存储同样范围值的时候，空间占用也更多；使用BIGINT代替DECIMAL，可根据小数的位数乘以相应的倍数，即可达到精确的浮点存储计算，避免DECIMAL计算代价高的问题"}
	DDLCheckBigintInsteadOfDecimalMessage                        = &i18n.Message{ID: "DDLCheckBigintInsteadOfDecimalMessage", Other: "建议列%s用BIGINT类型代替DECIMAL"}
	DMLCheckSubQueryNestNumDesc                                  = &i18n.Message{ID: "DMLCheckSubQueryNestNumDesc", Other: "子查询嵌套层数不建议超过阈值"}
	DMLCheckSubQueryNestNumAnnotation                            = &i18n.Message{ID: "DMLCheckSubQueryNestNumAnnotation", Other: "子查询嵌套层数超过阈值，有些情况下，子查询并不能使用到索引。同时对于返回结果集比较大的子查询，会产生大量的临时表，消耗过多的CPU和IO资源，产生大量的慢查询"}
	DMLCheckSubQueryNestNumMessage                               = &i18n.Message{ID: "DMLCheckSubQueryNestNumMessage", Other: "子查询嵌套层数超过阈值%v"}
	DMLCheckSubQueryNestNumParams1                               = &i18n.Message{ID: "DMLCheckSubQueryNestNumParams1", Other: "子查询嵌套层数不建议超过阈值"}
	DMLCheckNeedlessFuncDesc                                     = &i18n.Message{ID: "DMLCheckNeedlessFuncDesc", Other: "避免使用不必要的内置函数"}
	DMLCheckNeedlessFuncAnnotation                               = &i18n.Message{ID: "DMLCheckNeedlessFuncAnnotation", Other: "通过配置该规则可以指定业务中需要禁止使用的内置函数，使用内置函数可能会导致SQL无法走索引或者产生一些非预期的结果。实际需要禁用的函数可通过规则设置"}
	DMLCheckNeedlessFuncMessage                                  = &i18n.Message{ID: "DMLCheckNeedlessFuncMessage", Other: "避免使用不必要的内置函数%v"}
	DMLCheckNeedlessFuncParams1                                  = &i18n.Message{ID: "DMLCheckNeedlessFuncParams1", Other: "指定的函数集合（逗号分割）"}
	DDLCheckDatabaseSuffixDesc                                   = &i18n.Message{ID: "DDLCheckDatabaseSuffixDesc", Other: "建议数据库名称使用固定后缀结尾"}
	DDLCheckDatabaseSuffixAnnotation                             = &i18n.Message{ID: "DDLCheckDatabaseSuffixAnnotation", Other: "通过配置该规则可以规范指定业务的数据库命名规则，具体命名规范可以自定义设置，默认提示值：_DB"}
	DDLCheckDatabaseSuffixMessage                                = &i18n.Message{ID: "DDLCheckDatabaseSuffixMessage", Other: "建议数据库名称以\"%v\"结尾"}
	DDLCheckDatabaseSuffixParams1                                = &i18n.Message{ID: "DDLCheckDatabaseSuffixParams1", Other: "数据库名称后缀"}
	DDLCheckPKNameDesc                                           = &i18n.Message{ID: "DDLCheckPKNameDesc", Other: "建议主键命名为\"PK_表名\""}
	DDLCheckPKNameAnnotation                                     = &i18n.Message{ID: "DDLCheckPKNameAnnotation", Other: "通过配置该规则可以规范指定业务的主键命名规则"}
	DDLCheckPKNameMessage                                        = &i18n.Message{ID: "DDLCheckPKNameMessage", Other: "建议主键命名为\"PK_表名\""}
	DDLCheckTransactionIsolationLevelDesc                        = &i18n.Message{ID: "DDLCheckTransactionIsolationLevelDesc", Other: "事物隔离级别建议设置成RC"}
	DDLCheckTransactionIsolationLevelAnnotation                  = &i18n.Message{ID: "DDLCheckTransactionIsolationLevelAnnotation", Other: "RC避免了脏读的现象，但没有解决幻读的问题；使用RR，能避免幻读，但是由于引入间隙锁导致加锁的范围可能扩大，从而会影响并发，还容易造成死锁，所以在大多数业务场景下，幻读出现的机率较少，RC基本上能满足业务需求"}
	DDLCheckTransactionIsolationLevelMessage                     = &i18n.Message{ID: "DDLCheckTransactionIsolationLevelMessage", Other: "事物隔离级别建议设置成RC"}
	DMLCheckFuzzySearchDesc                                      = &i18n.Message{ID: "DMLCheckFuzzySearchDesc", Other: "禁止使用全模糊搜索或左模糊搜索"}
	DMLCheckFuzzySearchAnnotation                                = &i18n.Message{ID: "DMLCheckFuzzySearchAnnotation", Other: "使用全模糊搜索或左模糊搜索将导致查询无法使用索引，导致全表扫描"}
	DMLCheckFuzzySearchMessage                                   = &i18n.Message{ID: "DMLCheckFuzzySearchMessage", Other: "禁止使用全模糊搜索或左模糊搜索"}
	DDLCheckTablePartitionDesc                                   = &i18n.Message{ID: "DDLCheckTablePartitionDesc", Other: "不建议使用分区表相关功能"}
	DDLCheckTablePartitionAnnotation                             = &i18n.Message{ID: "DDLCheckTablePartitionAnnotation", Other: "分区表在物理上表现为多个文件，在逻辑上表现为一个表，跨分区查询效率可能更低，建议采用物理分表的方式管理大数据"}
	DDLCheckTablePartitionMessage                                = &i18n.Message{ID: "DDLCheckTablePartitionMessage", Other: "不建议使用分区表相关功能"}
	DMLCheckNumberOfJoinTablesDesc                               = &i18n.Message{ID: "DMLCheckNumberOfJoinTablesDesc", Other: "使用JOIN连接表查询建议不超过阈值"}
	DMLCheckNumberOfJoinTablesAnnotation                         = &i18n.Message{ID: "DMLCheckNumberOfJoinTablesAnnotation", Other: "表关联越多，意味着各种驱动关系组合就越多，比较各种结果集的执行成本的代价也就越高，进而SQL查询性能会大幅度下降；具体规则阈值可以根据业务需求调整，默认值：3"}
	DMLCheckNumberOfJoinTablesMessage                            = &i18n.Message{ID: "DMLCheckNumberOfJoinTablesMessage", Other: "使用JOIN连接表查询建议不超过%v张"}
	DMLCheckNumberOfJoinTablesParams1                            = &i18n.Message{ID: "DMLCheckNumberOfJoinTablesParams1", Other: "最大连接表个数"}
	DMLCheckIfAfterUnionDistinctDesc                             = &i18n.Message{ID: "DMLCheckIfAfterUnionDistinctDesc", Other: "建议使用UNION ALL,替代UNION"}
	DMLCheckIfAfterUnionDistinctAnnotation                       = &i18n.Message{ID: "DMLCheckIfAfterUnionDistinctAnnotation", Other: "UNION会按照字段的顺序进行排序同时去重，UNION ALL只是简单的将两个结果合并后就返回，从效率上看，UNION ALL 要比UNION快很多；如果合并的两个结果集中允许包含重复数据且不需要排序时的话，建议开启此规则，使用UNION ALL替代UNION"}
	DMLCheckIfAfterUnionDistinctMessage                          = &i18n.Message{ID: "DMLCheckIfAfterUnionDistinctMessage", Other: "建议使用UNION ALL,替代UNION"}
	DDLCheckIsExistLimitOffsetDesc                               = &i18n.Message{ID: "DDLCheckIsExistLimitOffsetDesc", Other: "使用分页查询时，避免使用偏移量"}
	DDLCheckIsExistLimitOffsetAnnotation                         = &i18n.Message{ID: "DDLCheckIsExistLimitOffsetAnnotation", Other: "例如：LIMIT N OFFSET M 或 LIMIT M,N。当偏移量m过大的时候，查询效率会很低，因为MySQL是先查出m+n个数据，然后抛弃掉前m个数据；对于有大数据量的MySQL表来说，使用LIMIT分页存在很严重的性能问题"}
	DDLCheckIsExistLimitOffsetMessage                            = &i18n.Message{ID: "DDLCheckIsExistLimitOffsetMessage", Other: "使用分页查询时，避免使用偏移量"}
	DDLCheckIndexOptionDesc                                      = &i18n.Message{ID: "DDLCheckIndexOptionDesc", Other: "建议索引字段对区分度大于阈值"}
	DDLCheckIndexOptionAnnotation                                = &i18n.Message{ID: "DDLCheckIndexOptionAnnotation", Other: "选择区分度高的字段作为索引，可快速定位数据；区分度太低，无法有效利用索引，甚至可能需要扫描大量数据页，拖慢SQL；具体规则阈值可以根据业务需求调整，默认值：70"}
	DDLCheckIndexOptionMessage                                   = &i18n.Message{ID: "DDLCheckIndexOptionMessage", Other: "索引 %v 未超过区分度阈值 百分之%v, 不建议选为索引"}
	DDLCheckIndexOptionParams1                                   = &i18n.Message{ID: "DDLCheckIndexOptionParams1", Other: "可选择性（百分比）"}
	DDLCheckColumnEnumNoticeDesc                                 = &i18n.Message{ID: "DDLCheckColumnEnumNoticeDesc", Other: "不建议使用 ENUM 类型"}
	DDLCheckColumnEnumNoticeAnnotation                           = &i18n.Message{ID: "DDLCheckColumnEnumNoticeAnnotation", Other: "ENUM类型不是SQL标准，移植性较差，后期如修改或增加枚举值需重建整张表，代价较大，且无法通过字面量值进行排序"}
	DDLCheckColumnEnumNoticeMessage                              = &i18n.Message{ID: "DDLCheckColumnEnumNoticeMessage", Other: "不建议使用 ENUM 类型"}
	DDLCheckColumnSetNoticeDesc                                  = &i18n.Message{ID: "DDLCheckColumnSetNoticeDesc", Other: "不建议使用 SET 类型"}
	DDLCheckColumnSetNoticeAnnotation                            = &i18n.Message{ID: "DDLCheckColumnSetNoticeAnnotation", Other: "集合的修改需要重新定义列，后期修改的代价大，建议在业务层实现"}
	DDLCheckColumnSetNoticeMessage                               = &i18n.Message{ID: "DDLCheckColumnSetNoticeMessage", Other: "不建议使用 SET 类型"}
	DDLCheckColumnBlobNoticeDesc                                 = &i18n.Message{ID: "DDLCheckColumnBlobNoticeDesc", Other: "不建议使用 BLOB 或 TEXT 类型"}
	DDLCheckColumnBlobNoticeAnnotation                           = &i18n.Message{ID: "DDLCheckColumnBlobNoticeAnnotation", Other: "BLOB 或 TEXT 类型消耗大量的网络和IO带宽，同时在该表上的DML操作都会变得很慢"}
	DDLCheckColumnBlobNoticeMessage                              = &i18n.Message{ID: "DDLCheckColumnBlobNoticeMessage", Other: "不建议使用 BLOB 或 TEXT 类型"}
	DMLCheckExplainAccessTypeAllDesc                             = &i18n.Message{ID: "DMLCheckExplainAccessTypeAllDesc", Other: "全表扫描时，扫描行数不建议超过指定行数（默认值：10000）"}
	DMLCheckExplainAccessTypeAllAnnotation                       = &i18n.Message{ID: "DMLCheckExplainAccessTypeAllAnnotation", Other: "全表扫描时，扫描行数不建议超过指定行数是为了避免性能问题；具体规则阈值可以根据业务需求调整，默认值：10000；如果设置为0，全表扫描都会触发规则"}
	DMLCheckExplainAccessTypeAllMessage                          = &i18n.Message{ID: "DMLCheckExplainAccessTypeAllMessage", Other: "该查询使用了全表扫描并且扫描行数为%v"}
	DMLCheckExplainAccessTypeAllParams1                          = &i18n.Message{ID: "DMLCheckExplainAccessTypeAllParams1", Other: "最大扫描行数"}
	DMLCheckExplainExtraUsingFilesortDesc                        = &i18n.Message{ID: "DMLCheckExplainExtraUsingFilesortDesc", Other: "不建议使用文件排序"}
	DMLCheckExplainExtraUsingFilesortAnnotation                  = &i18n.Message{ID: "DMLCheckExplainExtraUsingFilesortAnnotation", Other: "大数据量的情况下，文件排序意味着SQL性能较低，会增加OS的开销，影响数据库性能"}
	DMLCheckExplainExtraUsingFilesortMessage                     = &i18n.Message{ID: "DMLCheckExplainExtraUsingFilesortMessage", Other: "不建议使用文件排序"}
	DMLCheckExplainExtraUsingTemporaryDesc                       = &i18n.Message{ID: "DMLCheckExplainExtraUsingTemporaryDesc", Other: "不建议使用临时表"}
	DMLCheckExplainExtraUsingTemporaryAnnotation                 = &i18n.Message{ID: "DMLCheckExplainExtraUsingTemporaryAnnotation", Other: "大数据量的情况下，临时表意味着SQL性能较低，会增加OS的开销，影响数据库性能"}
	DMLCheckExplainExtraUsingTemporaryMessage                    = &i18n.Message{ID: "DMLCheckExplainExtraUsingTemporaryMessage", Other: "不建议使用临时表"}
	DDLCheckCreateViewDesc                                       = &i18n.Message{ID: "DDLCheckCreateViewDesc", Other: "禁止使用视图"}
	DDLCheckCreateViewAnnotation                                 = &i18n.Message{ID: "DDLCheckCreateViewAnnotation", Other: "视图的查询性能较差，同时基表结构变更，需要对视图进行维护，如果视图可读性差且包含复杂的逻辑，都会增加维护的成本"}
	DDLCheckCreateViewMessage                                    = &i18n.Message{ID: "DDLCheckCreateViewMessage", Other: "禁止使用视图"}
	DDLCheckCreateTriggerDesc                                    = &i18n.Message{ID: "DDLCheckCreateTriggerDesc", Other: "禁止使用触发器"}
	DDLCheckCreateTriggerAnnotation                              = &i18n.Message{ID: "DDLCheckCreateTriggerAnnotation", Other: "触发器难以开发和维护，不能高效移植，且在复杂的逻辑以及高并发下，容易出现死锁影响业务"}
	DDLCheckCreateTriggerMessage                                 = &i18n.Message{ID: "DDLCheckCreateTriggerMessage", Other: "禁止使用触发器"}
	DDLCheckCreateFunctionDesc                                   = &i18n.Message{ID: "DDLCheckCreateFunctionDesc", Other: "禁止使用自定义函数"}
	DDLCheckCreateFunctionAnnotation                             = &i18n.Message{ID: "DDLCheckCreateFunctionAnnotation", Other: "自定义函数，维护较差，且依赖性高会导致SQL无法跨库使用"}
	DDLCheckCreateFunctionMessage                                = &i18n.Message{ID: "DDLCheckCreateFunctionMessage", Other: "禁止使用自定义函数"}
	DDLCheckCreateProcedureDesc                                  = &i18n.Message{ID: "DDLCheckCreateProcedureDesc", Other: "禁止使用存储过程"}
	DDLCheckCreateProcedureAnnotation                            = &i18n.Message{ID: "DDLCheckCreateProcedureAnnotation", Other: "存储过程在一定程度上会使程序难以调试和拓展，各种数据库的存储过程语法相差很大，给将来的数据库移植带来很大的困难，且会极大的增加出现BUG的概率"}
	DDLCheckCreateProcedureMessage                               = &i18n.Message{ID: "DDLCheckCreateProcedureMessage", Other: "禁止使用存储过程"}
	DDLDisableTypeTimestampDesc                                  = &i18n.Message{ID: "DDLDisableTypeTimestampDesc", Other: "不建议使用TIMESTAMP字段"}
	DDLDisableTypeTimestampAnnotation                            = &i18n.Message{ID: "DDLDisableTypeTimestampAnnotation", Other: "TIMESTAMP 有最大值限制（'2038-01-19 03:14:07' UTC），且会时区转换的问题"}
	DDLDisableTypeTimestampMessage                               = &i18n.Message{ID: "DDLDisableTypeTimestampMessage", Other: "不建议使用TIMESTAMP字段"}
	DMLCheckAliasDesc                                            = &i18n.Message{ID: "DMLCheckAliasDesc", Other: "别名不建议与表或列的名字相同"}
	DMLCheckAliasAnnotation                                      = &i18n.Message{ID: "DMLCheckAliasAnnotation", Other: "表或列的别名与其真实名称相同, 这样的别名会使得查询更难去分辨"}
	DMLCheckAliasMessage                                         = &i18n.Message{ID: "DMLCheckAliasMessage", Other: "这些别名(%v)与列名或表名相同"}
	DDLHintUpdateTableCharsetWillNotUpdateFieldCharsetDesc       = &i18n.Message{ID: "DDLHintUpdateTableCharsetWillNotUpdateFieldCharsetDesc", Other: "不建议修改表的默认字符集"}
	DDLHintUpdateTableCharsetWillNotUpdateFieldCharsetAnnotation = &i18n.Message{ID: "DDLHintUpdateTableCharsetWillNotUpdateFieldCharsetAnnotation", Other: "修改表的默认字符集，只会影响后续新增的字段，不会修表已有字段的字符集；如需修改整张表所有字段的字符集建议开启此规则"}
	DDLHintUpdateTableCharsetWillNotUpdateFieldCharsetMessage    = &i18n.Message{ID: "DDLHintUpdateTableCharsetWillNotUpdateFieldCharsetMessage", Other: "不建议修改表的默认字符集"}
	DDLHintDropColumnDesc                                        = &i18n.Message{ID: "DDLHintDropColumnDesc", Other: "禁止进行删除列的操作"}
	DDLHintDropColumnAnnotation                                  = &i18n.Message{ID: "DDLHintDropColumnAnnotation", Other: "业务逻辑与删除列依赖未完全消除，列被删除后可能导致程序异常（无法正常读写）的情况；开启该规则，SQLE将提醒删除列为高危操作"}
	DDLHintDropColumnMessage                                     = &i18n.Message{ID: "DDLHintDropColumnMessage", Other: "禁止进行删除列的操作"}
	DDLHintDropPrimaryKeyDesc                                    = &i18n.Message{ID: "DDLHintDropPrimaryKeyDesc", Other: "禁止进行删除主键的操作"}
	DDLHintDropPrimaryKeyAnnotation                              = &i18n.Message{ID: "DDLHintDropPrimaryKeyAnnotation", Other: "删除已有约束会影响已有业务逻辑；开启该规则，SQLE将提醒删除主键为高危操作"}
	DDLHintDropPrimaryKeyMessage                                 = &i18n.Message{ID: "DDLHintDropPrimaryKeyMessage", Other: "禁止进行删除主键的操作"}
	DDLHintDropForeignKeyDesc                                    = &i18n.Message{ID: "DDLHintDropForeignKeyDesc", Other: "禁止进行删除外键的操作"}
	DDLHintDropForeignKeyAnnotation                              = &i18n.Message{ID: "DDLHintDropForeignKeyAnnotation", Other: "删除已有约束会影响已有业务逻辑；开启该规则，SQLE将提醒删除外键为高危操作"}
	DDLHintDropForeignKeyMessage                                 = &i18n.Message{ID: "DDLHintDropForeignKeyMessage", Other: "禁止进行删除外键的操作"}
	DMLNotRecommendNotWildcardLikeDesc                           = &i18n.Message{ID: "DMLNotRecommendNotWildcardLikeDesc", Other: "不建议使用没有通配符的 LIKE 查询"}
	DMLNotRecommendNotWildcardLikeAnnotation                     = &i18n.Message{ID: "DMLNotRecommendNotWildcardLikeAnnotation", Other: "不包含通配符的 LIKE 查询逻辑上与等值查询相同，建议使用等值查询替代"}
	DMLNotRecommendNotWildcardLikeMessage                        = &i18n.Message{ID: "DMLNotRecommendNotWildcardLikeMessage", Other: "不建议使用没有通配符的 LIKE 查询"}
	DMLHintInNullOnlyFalseDesc                                   = &i18n.Message{ID: "DMLHintInNullOnlyFalseDesc", Other: "避免使用 IN (NULL) 或者 NOT IN (NULL)"}
	DMLHintInNullOnlyFalseAnnotation                             = &i18n.Message{ID: "DMLHintInNullOnlyFalseAnnotation", Other: "查询条件永远非真，这将导致查询无匹配到的结果"}
	DMLHintInNullOnlyFalseMessage                                = &i18n.Message{ID: "DMLHintInNullOnlyFalseMessage", Other: "避免使用IN (NULL)/NOT IN (NULL) ，该用法永远非真将导致条件失效"}
	DMLNotRecommendInDesc                                        = &i18n.Message{ID: "DMLNotRecommendInDesc", Other: "不建议使用IN"}
	DMLNotRecommendInAnnotation                                  = &i18n.Message{ID: "DMLNotRecommendInAnnotation", Other: "当IN值过多时，有可能会导致查询进行全表扫描，使得MySQL性能急剧下降"}
	DMLNotRecommendInMessage                                     = &i18n.Message{ID: "DMLNotRecommendInMessage", Other: "不建议使用IN"}
	DMLCheckSpacesAroundTheStringDesc                            = &i18n.Message{ID: "DMLCheckSpacesAroundTheStringDesc", Other: "引号中的字符串开头或结尾不建议包含空格"}
	DMLCheckSpacesAroundTheStringAnnotation                      = &i18n.Message{ID: "DMLCheckSpacesAroundTheStringAnnotation", Other: "字符串前后存在空格将可能导致查询判断逻辑出错，如在MySQL 5.5中'a'和'a '在查询中被认为是相同的值"}
	DMLCheckSpacesAroundTheStringMessage                         = &i18n.Message{ID: "DMLCheckSpacesAroundTheStringMessage", Other: "引号中的字符串开头或结尾不建议包含空格"}
	DDLCheckFullWidthQuotationMarksDesc                          = &i18n.Message{ID: "DDLCheckFullWidthQuotationMarksDesc", Other: "DDL语句中不建议使用中文全角引号"}
	DDLCheckFullWidthQuotationMarksAnnotation                    = &i18n.Message{ID: "DDLCheckFullWidthQuotationMarksAnnotation", Other: "建议开启此规则，可避免MySQL会将中文全角引号识别为命名的一部分，执行结果与业务预期不符"}
	DDLCheckFullWidthQuotationMarksMessage                       = &i18n.Message{ID: "DDLCheckFullWidthQuotationMarksMessage", Other: "DDL语句中不建议使用中文全角引号，这可能是书写错误"}
	DMLNotRecommendOrderByRandDesc                               = &i18n.Message{ID: "DMLNotRecommendOrderByRandDesc", Other: "不建议使用 ORDER BY RAND()"}
	DMLNotRecommendOrderByRandAnnotation                         = &i18n.Message{ID: "DMLNotRecommendOrderByRandAnnotation", Other: "ORDER BY RAND()使用了临时表，同时还要对其进行排序，在数据量很大的情况下会增加服务器负载以及增加查询时间"}
	DMLNotRecommendOrderByRandMessage                            = &i18n.Message{ID: "DMLNotRecommendOrderByRandMessage", Other: "不建议使用 ORDER BY RAND()"}
	DMLNotRecommendGroupByConstantDesc                           = &i18n.Message{ID: "DMLNotRecommendGroupByConstantDesc", Other: "不建议对常量进行 GROUP BY"}
	DMLNotRecommendGroupByConstantAnnotation                     = &i18n.Message{ID: "DMLNotRecommendGroupByConstantAnnotation", Other: "GROUP BY 1 表示按第一列进行GROUP BY；在GROUP BY子句中使用数字，而不是表达式或列名称，当查询列顺序改变时，会导致查询逻辑出现问题"}
	DMLNotRecommendGroupByConstantMessage                        = &i18n.Message{ID: "DMLNotRecommendGroupByConstantMessage", Other: "不建议对常量进行 GROUP BY"}
	DMLCheckSortDirectionDesc                                    = &i18n.Message{ID: "DMLCheckSortDirectionDesc", Other: "不建议在 ORDER BY 语句中对多个不同条件使用不同方向的排序"}
	DMLCheckSortDirectionAnnotation                              = &i18n.Message{ID: "DMLCheckSortDirectionAnnotation", Other: "在 MySQL 8.0 之前当 ORDER BY 多个列指定的排序方向不同时将无法使用已经建立的索引。在MySQL8.0 之后可以建立对应的排序顺序的联合索引来优化"}
	DMLCheckSortDirectionMessage                                 = &i18n.Message{ID: "DMLCheckSortDirectionMessage", Other: "不建议在 ORDER BY 语句中对多个不同条件使用不同方向的排序"}
	DMLHintGroupByRequiresConditionsDesc                         = &i18n.Message{ID: "DMLHintGroupByRequiresConditionsDesc", Other: "建议为GROUP BY语句添加ORDER BY条件"}
	DMLHintGroupByRequiresConditionsAnnotation                   = &i18n.Message{ID: "DMLHintGroupByRequiresConditionsAnnotation", Other: "在5.7中，MySQL默认会对’GROUP BY col1, …’按如下顺序’ORDER BY col1,…’隐式排序，导致产生无谓的排序，带来额外的开销；在8.0中，则不会出现这种情况。如果不需要排序建议显示添加’ORDER BY NULL’"}
	DMLHintGroupByRequiresConditionsMessage                      = &i18n.Message{ID: "DMLHintGroupByRequiresConditionsMessage", Other: "建议为GROUP BY语句添加ORDER BY条件"}
	DMLNotRecommendGroupByExpressionDesc                         = &i18n.Message{ID: "DMLNotRecommendGroupByExpressionDesc", Other: "不建议ORDER BY 的条件为表达式"}
	DMLNotRecommendGroupByExpressionAnnotation                   = &i18n.Message{ID: "DMLNotRecommendGroupByExpressionAnnotation", Other: "当ORDER BY条件为表达式或函数时会使用到临时表，如果在未指定WHERE或WHERE条件返回的结果集较大时性能会很差"}
	DMLNotRecommendGroupByExpressionMessage                      = &i18n.Message{ID: "DMLNotRecommendGroupByExpressionMessage", Other: "不建议ORDER BY 的条件为表达式"}
	DMLCheckSQLLengthDesc                                        = &i18n.Message{ID: "DMLCheckSQLLengthDesc", Other: "建议将过长的SQL分解成几个简单的SQL"}
	DMLCheckSQLLengthAnnotation                                  = &i18n.Message{ID: "DMLCheckSQLLengthAnnotation", Other: "过长的SQL可读性较差，难以维护，且容易引发性能问题；具体规则阈值可以根据业务需求调整，默认值：1024"}
	DMLCheckSQLLengthMessage                                     = &i18n.Message{ID: "DMLCheckSQLLengthMessage", Other: "建议将过长的SQL分解成几个简单的SQL"}
	DMLCheckSQLLengthParams1                                     = &i18n.Message{ID: "DMLCheckSQLLengthParams1", Other: "SQL最大长度"}
	DMLNotRecommendHavingDesc                                    = &i18n.Message{ID: "DMLNotRecommendHavingDesc", Other: "不建议使用 HAVING 子句"}
	DMLNotRecommendHavingAnnotation                              = &i18n.Message{ID: "DMLNotRecommendHavingAnnotation", Other: "对于索引字段，放在HAVING子句中时不会走索引；建议将HAVING子句改写为WHERE中的查询条件，可以在查询处理期间使用索引，提高SQL的执行效率"}
	DMLNotRecommendHavingMessage                                 = &i18n.Message{ID: "DMLNotRecommendHavingMessage", Other: "不建议使用 HAVING 子句"}
	DMLHintUseTruncateInsteadOfDeleteDesc                        = &i18n.Message{ID: "DMLHintUseTruncateInsteadOfDeleteDesc", Other: "删除全表时建议使用 TRUNCATE 替代 DELETE"}
	DMLHintUseTruncateInsteadOfDeleteAnnotation                  = &i18n.Message{ID: "DMLHintUseTruncateInsteadOfDeleteAnnotation", Other: "TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，同时TRUNCATE后表所占用的空间会被释放，而DELETE后需要手工执行OPTIMIZE才能释放表空间"}
	DMLHintUseTruncateInsteadOfDeleteMessage                     = &i18n.Message{ID: "DMLHintUseTruncateInsteadOfDeleteMessage", Other: "删除全表时建议使用 TRUNCATE 替代 DELETE"}
	DMLNotRecommendUpdatePKDesc                                  = &i18n.Message{ID: "DMLNotRecommendUpdatePKDesc", Other: "不建议UPDATE主键"}
	DMLNotRecommendUpdatePKAnnotation                            = &i18n.Message{ID: "DMLNotRecommendUpdatePKAnnotation", Other: "主键索引数据列的顺序就是表记录的物理存储顺序，频繁更新主键将导致整个表记录的顺序的调整，会耗费相当大的资源"}
	DMLNotRecommendUpdatePKMessage                               = &i18n.Message{ID: "DMLNotRecommendUpdatePKMessage", Other: "不建议UPDATE主键"}
	DDLCheckColumnQuantityDesc                                   = &i18n.Message{ID: "DDLCheckColumnQuantityDesc", Other: "表的列数不建议超过阈值"}
	DDLCheckColumnQuantityAnnotation                             = &i18n.Message{ID: "DDLCheckColumnQuantityAnnotation", Other: "避免在OLTP系统上做宽表设计，后期对性能影响很大；具体规则阈值可根据业务需求调整，默认值：40"}
	DDLCheckColumnQuantityMessage                                = &i18n.Message{ID: "DDLCheckColumnQuantityMessage", Other: "表的列数不建议超过阈值"}
	DDLCheckColumnQuantityParams1                                = &i18n.Message{ID: "DDLCheckColumnQuantityParams1", Other: "最大列数"}
	DDLRecommendTableColumnCharsetSameDesc                       = &i18n.Message{ID: "DDLRecommendTableColumnCharsetSameDesc", Other: "建议列与表使用同一个字符集"}
	DDLRecommendTableColumnCharsetSameAnnotation                 = &i18n.Message{ID: "DDLRecommendTableColumnCharsetSameAnnotation", Other: "统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效"}
	DDLRecommendTableColumnCharsetSameMessage                    = &i18n.Message{ID: "DDLRecommendTableColumnCharsetSameMessage", Other: "建议列与表使用同一个字符集"}
	DDLCheckColumnTypeIntegerDesc                                = &i18n.Message{ID: "DDLCheckColumnTypeIntegerDesc", Other: "整型定义建议采用 INT(10) 或 BIGINT(20)"}
	DDLCheckColumnTypeIntegerAnnotation                          = &i18n.Message{ID: "DDLCheckColumnTypeIntegerAnnotation", Other: "INT(M) 或 BIGINT(M)，M 表示最大显示宽度，可存储最大值的宽度分别为10、20，采用 INT(10) 或 BIGINT(20)可避免发生显示截断的可能"}
	DDLCheckColumnTypeIntegerMessage                             = &i18n.Message{ID: "DDLCheckColumnTypeIntegerMessage", Other: "整型定义建议采用 INT(10) 或 BIGINT(20)"}
	DDLCheckVarcharSizeDesc                                      = &i18n.Message{ID: "DDLCheckVarcharSizeDesc", Other: "定义VARCHAR 长度时不建议大于阈值"}
	DDLCheckVarcharSizeAnnotation                                = &i18n.Message{ID: "DDLCheckVarcharSizeAnnotation", Other: "MySQL建立索引时没有限制索引的大小，索引长度会默认采用的该字段的长度，VARCHAR 定义长度越长建立的索引存储大小越大；具体规则阈值可以根据业务需求调整，默认值：1024"}
	DDLCheckVarcharSizeMessage                                   = &i18n.Message{ID: "DDLCheckVarcharSizeMessage", Other: "定义VARCHAR 长度时不建议大于阈值, 阈值为%d"}
	DDLCheckVarcharSizeParams1                                   = &i18n.Message{ID: "DDLCheckVarcharSizeParams1", Other: "VARCHAR最大长度"}
	DMLNotRecommendFuncInWhereDesc                               = &i18n.Message{ID: "DMLNotRecommendFuncInWhereDesc", Other: "应避免在 WHERE 条件中使用函数或其他运算符"}
	DMLNotRecommendFuncInWhereAnnotation                         = &i18n.Message{ID: "DMLNotRecommendFuncInWhereAnnotation", Other: "函数或运算符会导致查询无法利用表中的索引，该查询将会全表扫描，性能较差"}
	DMLNotRecommendFuncInWhereMessage                            = &i18n.Message{ID: "DMLNotRecommendFuncInWhereMessage", Other: "应避免在 WHERE 条件中使用函数或其他运算符"}
	DMLNotRecommendSysdateDesc                                   = &i18n.Message{ID: "DMLNotRecommendSysdateDesc", Other: "不建议使用 SYSDATE() 函数"}
	DMLNotRecommendSysdateAnnotation                             = &i18n.Message{ID: "DMLNotRecommendSysdateAnnotation", Other: "当SYSDATE()函数在基于STATEMENT模式的主从环境下可能造成数据的不一致，因为语句在主库中执行到日志传递到备库，存在时间差，到备库执行的时候就会变成不同的时间值，建议采取ROW模式的复制环境"}
	DMLNotRecommendSysdateMessage                                = &i18n.Message{ID: "DMLNotRecommendSysdateMessage", Other: "不建议使用 SYSDATE() 函数"}
	DMLHintSumFuncTipsDesc                                       = &i18n.Message{ID: "DMLHintSumFuncTipsDesc", Other: "避免使用 SUM(COL)"}
	DMLHintSumFuncTipsAnnotation                                 = &i18n.Message{ID: "DMLHintSumFuncTipsAnnotation", Other: "当某一列的值全是NULL时，COUNT(COL)的返回结果为0，但SUM(COL)的返回结果为NULL，因此使用SUM()时需注意NPE问题（指数据返回NULL）；如业务需避免NPE问题，建议开启此规则"}
	DMLHintSumFuncTipsMessage                                    = &i18n.Message{ID: "DMLHintSumFuncTipsMessage", Other: "避免使用 SUM(COL) ，该用法存在返回NULL值导致程序空指针的风险"}
	DMLHintCountFuncWithColDesc                                  = &i18n.Message{ID: "DMLHintCountFuncWithColDesc", Other: "避免使用 COUNT(COL)"}
	DMLHintCountFuncWithColAnnotation                            = &i18n.Message{ID: "DMLHintCountFuncWithColAnnotation", Other: "建议使用COUNT(*)，因为使用 COUNT(COL) 需要对表进行全表扫描，这可能会导致性能下降。"}
	DMLHintCountFuncWithColMessage                               = &i18n.Message{ID: "DMLHintCountFuncWithColMessage", Other: "避免使用 COUNT(COL)"}
	DDLCheckColumnQuantityInPKDesc                               = &i18n.Message{ID: "DDLCheckColumnQuantityInPKDesc", Other: "主键包含的列数不建议超过阈值"}
	DDLCheckColumnQuantityInPKAnnotation                         = &i18n.Message{ID: "DDLCheckColumnQuantityInPKAnnotation", Other: "主建中的列过多，会导致二级索引占用更多的空间，同时增加索引维护的开销；具体规则阈值可根据业务需求调整，默认值：2"}
	DDLCheckColumnQuantityInPKMessage                            = &i18n.Message{ID: "DDLCheckColumnQuantityInPKMessage", Other: "主键包含的列数不建议超过阈值"}
	DDLCheckColumnQuantityInPKParams1                            = &i18n.Message{ID: "DDLCheckColumnQuantityInPKParams1", Other: "最大列数"}
	DMLHintLimitMustBeCombinedWithOrderByDesc                    = &i18n.Message{ID: "DMLHintLimitMustBeCombinedWithOrderByDesc", Other: "LIMIT 查询建议使用ORDER BY"}
	DMLHintLimitMustBeCombinedWithOrderByAnnotation              = &i18n.Message{ID: "DMLHintLimitMustBeCombinedWithOrderByAnnotation", Other: "没有ORDER BY的LIMIT会导致非确定性的结果可能与业务需求不符，这取决于执行计划"}
	DMLHintLimitMustBeCombinedWithOrderByMessage                 = &i18n.Message{ID: "DMLHintLimitMustBeCombinedWithOrderByMessage", Other: "LIMIT 查询建议使用ORDER BY"}
	DMLHintTruncateTipsDesc                                      = &i18n.Message{ID: "DMLHintTruncateTipsDesc", Other: "不建议使用TRUNCATE操作"}
	DMLHintTruncateTipsAnnotation                                = &i18n.Message{ID: "DMLHintTruncateTipsAnnotation", Other: "TRUNCATE是DLL，数据不能回滚，在没有备份情况下，谨慎使用TRUNCATE"}
	DMLHintTruncateTipsMessage                                   = &i18n.Message{ID: "DMLHintTruncateTipsMessage", Other: "不建议使用TRUNCATE操作"}
	DMLHintDeleteTipsDesc                                        = &i18n.Message{ID: "DMLHintDeleteTipsDesc", Other: "建议在执行DELETE/DROP/TRUNCATE等操作前进行备份"}
	DMLHintDeleteTipsAnnotation                                  = &i18n.Message{ID: "DMLHintDeleteTipsAnnotation", Other: "DROP/TRUNCATE是DDL，操作立即生效，不会写入日志，所以无法回滚，在执行高危操作之前对数据进行备份是很有必要的"}
	DMLHintDeleteTipsMessage                                     = &i18n.Message{ID: "DMLHintDeleteTipsMessage", Other: "建议在执行DELETE/DROP/TRUNCATE等操作前进行备份"}
	DMLCheckSQLInjectionFuncDesc                                 = &i18n.Message{ID: "DMLCheckSQLInjectionFuncDesc", Other: "不建议使用常见 SQL 注入函数"}
	DMLCheckSQLInjectionFuncAnnotation                           = &i18n.Message{ID: "DMLCheckSQLInjectionFuncAnnotation", Other: "攻击者通过SQL注入，可未经授权可访问数据库中的数据，存在盗取用户信息，造成用户数据泄露等安全漏洞问题"}
	DMLCheckSQLInjectionFuncMessage                              = &i18n.Message{ID: "DMLCheckSQLInjectionFuncMessage", Other: "不建议使用常见 SQL 注入函数"}
	DMLCheckNotEqualSymbolDesc                                   = &i18n.Message{ID: "DMLCheckNotEqualSymbolDesc", Other: "建议使用'<>'代替'!='"}
	DMLCheckNotEqualSymbolAnnotation                             = &i18n.Message{ID: "DMLCheckNotEqualSymbolAnnotation", Other: "'!=' 是非标准的运算符，'<>' 才是SQL中标准的不等于运算符"}
	DMLCheckNotEqualSymbolMessage                                = &i18n.Message{ID: "DMLCheckNotEqualSymbolMessage", Other: "建议使用'<>'代替'!='"}
	DMLNotRecommendSubqueryDesc                                  = &i18n.Message{ID: "DMLNotRecommendSubqueryDesc", Other: "不推荐使用子查询"}
	DMLNotRecommendSubqueryAnnotation                            = &i18n.Message{ID: "DMLNotRecommendSubqueryAnnotation", Other: "有些情况下，子查询并不能使用到索引，同时对于返回结果集比较大的子查询，会产生大量的临时表，消耗过多的CPU和IO资源，产生大量的慢查询"}
	DMLNotRecommendSubqueryMessage                               = &i18n.Message{ID: "DMLNotRecommendSubqueryMessage", Other: "不推荐使用子查询"}
	DMLCheckSubqueryLimitDesc                                    = &i18n.Message{ID: "DMLCheckSubqueryLimitDesc", Other: "不建议在子查询中使用LIMIT"}
	DMLCheckSubqueryLimitAnnotation                              = &i18n.Message{ID: "DMLCheckSubqueryLimitAnnotation", Other: "部分MySQL版本不支持在子查询中进行'LIMIT & IN/ALL/ANY/SOME'"}
	DMLCheckSubqueryLimitMessage                                 = &i18n.Message{ID: "DMLCheckSubqueryLimitMessage", Other: "不建议在子查询中使用LIMIT"}
	DDLCheckAutoIncrementDesc                                    = &i18n.Message{ID: "DDLCheckAutoIncrementDesc", Other: "表的初始AUTO_INCREMENT值建议为0"}
	DDLCheckAutoIncrementAnnotation                              = &i18n.Message{ID: "DDLCheckAutoIncrementAnnotation", Other: "创建表时AUTO_INCREMENT设置为0则自增从1开始，可以避免数据空洞。例如在导出表结构DDL时，表结构内AUTO_INCREMENT通常为当前的自增值，如果建表时没有把AUTO_INCREMENT设置为0，那么通过该DDL进行建表操作会导致自增值从一个无意义数字开始。"}
	DDLCheckAutoIncrementMessage                                 = &i18n.Message{ID: "DDLCheckAutoIncrementMessage", Other: "表的初始AUTO_INCREMENT值建议为0"}
	DDLNotAllowRenamingDesc                                      = &i18n.Message{ID: "DDLNotAllowRenamingDesc", Other: "禁止使用RENAME或CHANGE对表名字段名进行修改"}
	DDLNotAllowRenamingAnnotation                                = &i18n.Message{ID: "DDLNotAllowRenamingAnnotation", Other: "RENAME/CHANGE 表名/列名会对线上业务不停机发布造成影响，如需这种操作应当DBA手工干预"}
	DDLNotAllowRenamingMessage                                   = &i18n.Message{ID: "DDLNotAllowRenamingMessage", Other: "禁止使用RENAME或CHANGE对表名字段名进行修改"}
	DMLCheckExplainFullIndexScanDesc                             = &i18n.Message{ID: "DMLCheckExplainFullIndexScanDesc", Other: "不建议对表进行全索引扫描"}
	DMLCheckExplainFullIndexScanAnnotation                       = &i18n.Message{ID: "DMLCheckExplainFullIndexScanAnnotation", Other: "在数据量大的情况下索引全扫描严重影响SQL性能。"}
	DMLCheckExplainFullIndexScanMessage                          = &i18n.Message{ID: "DMLCheckExplainFullIndexScanMessage", Other: "不建议对表进行全索引扫描"}
	DMLCheckLimitOffsetNumDesc                                   = &i18n.Message{ID: "DMLCheckLimitOffsetNumDesc", Other: "不建议LIMIT的偏移OFFSET大于阈值"}
	DMLCheckLimitOffsetNumAnnotation                             = &i18n.Message{ID: "DMLCheckLimitOffsetNumAnnotation", Other: "因为OFFSET指定了结果集的起始位置，如果起始位置过大，那么 MySQL 需要处理更多的数据才能返回结果集，这可能会导致查询性能下降。"}
	DMLCheckLimitOffsetNumMessage                                = &i18n.Message{ID: "DMLCheckLimitOffsetNumMessage", Other: "不建议LIMIT的偏移OFFSET大于阈值，OFFSET=%v（阈值为%v）"}
	DMLCheckLimitOffsetNumParams1                                = &i18n.Message{ID: "DMLCheckLimitOffsetNumParams1", Other: "offset 大小"}
	DMLCheckUpdateOrDeleteHasWhereDesc                           = &i18n.Message{ID: "DMLCheckUpdateOrDeleteHasWhereDesc", Other: "建议UPDATE/DELETE操作使用WHERE条件"}
	DMLCheckUpdateOrDeleteHasWhereAnnotation                     = &i18n.Message{ID: "DMLCheckUpdateOrDeleteHasWhereAnnotation", Other: "因为这些语句的目的是修改数据库中的数据，需要使用 WHERE 条件来过滤需要更新或删除的记录，以确保数据的正确性。另外，使用 WHERE 条件还可以提高查询性能。"}
	DMLCheckUpdateOrDeleteHasWhereMessage                        = &i18n.Message{ID: "DMLCheckUpdateOrDeleteHasWhereMessage", Other: "建议UPDATE/DELETE操作使用WHERE条件"}
	DMLCheckSortColumnLengthDesc                                 = &i18n.Message{ID: "DMLCheckSortColumnLengthDesc", Other: "禁止对长字段排序"}
	DMLCheckSortColumnLengthAnnotation                           = &i18n.Message{ID: "DMLCheckSortColumnLengthAnnotation", Other: "对例如VARCHAR(2000)这样的长字段进行ORDER BY、DISTINCT、GROUP BY、UNION之类的操作，会引发排序，有性能隐患"}
	DMLCheckSortColumnLengthMessage                              = &i18n.Message{ID: "DMLCheckSortColumnLengthMessage", Other: "长度超过阈值的字段不建议用于ORDER BY、DISTINCT、GROUP BY、UNION，这些字段有：%v"}
	DMLCheckSortColumnLengthParams1                              = &i18n.Message{ID: "DMLCheckSortColumnLengthParams1", Other: "可排序字段的最大长度"}
	AllCheckPrepareStatementPlaceholdersDesc                     = &i18n.Message{ID: "AllCheckPrepareStatementPlaceholdersDesc", Other: "绑定的变量个数不建议超过阈值"}
	AllCheckPrepareStatementPlaceholdersAnnotation               = &i18n.Message{ID: "AllCheckPrepareStatementPlaceholdersAnnotation", Other: "因为过度使用绑定变量会增加查询的复杂度，从而降低查询性能。过度使用绑定变量还会增加维护成本。默认阈值:100"}
	AllCheckPrepareStatementPlaceholdersMessage                  = &i18n.Message{ID: "AllCheckPrepareStatementPlaceholdersMessage", Other: "使用绑定变量数量为 %v，不建议超过设定阈值 %v"}
	AllCheckPrepareStatementPlaceholdersParams1                  = &i18n.Message{ID: "AllCheckPrepareStatementPlaceholdersParams1", Other: "最大绑定变量数量"}
	DMLCheckExplainExtraUsingIndexForSkipScanDesc                = &i18n.Message{ID: "DMLCheckExplainExtraUsingIndexForSkipScanDesc", Other: "不建议对表进行索引跳跃扫描"}
	DMLCheckExplainExtraUsingIndexForSkipScanAnnotation          = &i18n.Message{ID: "DMLCheckExplainExtraUsingIndexForSkipScanAnnotation", Other: "索引扫描是跳跃扫描，未遵循最左匹配原则，可能降低索引的使用效率，影响查询性能"}
	DMLCheckExplainExtraUsingIndexForSkipScanMessage             = &i18n.Message{ID: "DMLCheckExplainExtraUsingIndexForSkipScanMessage", Other: "不建议对表进行索引跳跃扫描"}
	DMLCheckAffectedRowsDesc                                     = &i18n.Message{ID: "DMLCheckAffectedRowsDesc", Other: "UPDATE/DELETE操作影响行数不建议超过阈值"}
	DMLCheckAffectedRowsAnnotation                               = &i18n.Message{ID: "DMLCheckAffectedRowsAnnotation", Other: "如果 DML 操作影响行数过多，会导致查询性能下降，因为需要扫描更多的数据。"}
	DMLCheckAffectedRowsMessage                                  = &i18n.Message{ID: "DMLCheckAffectedRowsMessage", Other: "UPDATE/DELETE操作影响行数不建议超过阈值，影响行数为 %v，超过设定阈值 %v"}
	DMLCheckAffectedRowsParams1                                  = &i18n.Message{ID: "DMLCheckAffectedRowsParams1", Other: "最大影响行数"}
	DMLCheckSameTableJoinedMultipleTimesDesc                     = &i18n.Message{ID: "DMLCheckSameTableJoinedMultipleTimesDesc", Other: "不建议对同一张表连接多次"}
	DMLCheckSameTableJoinedMultipleTimesAnnotation               = &i18n.Message{ID: "DMLCheckSameTableJoinedMultipleTimesAnnotation", Other: "如果对单表查询多次，会导致查询性能下降。"}
	DMLCheckSameTableJoinedMultipleTimesMessage                  = &i18n.Message{ID: "DMLCheckSameTableJoinedMultipleTimesMessage", Other: "表%v被连接多次"}
	DMLCheckExplainUsingIndexDesc                                = &i18n.Message{ID: "DMLCheckExplainUsingIndexDesc", Other: "SQL查询条件需要走索引"}
	DMLCheckExplainUsingIndexAnnotation                          = &i18n.Message{ID: "DMLCheckExplainUsingIndexAnnotation", Other: "使用索引可以显著提高SQL查询的性能。"}
	DMLCheckExplainUsingIndexMessage                             = &i18n.Message{ID: "DMLCheckExplainUsingIndexMessage", Other: "建议使用索引以优化 SQL 查询性能"}
	DMLCheckInsertSelectDesc                                     = &i18n.Message{ID: "DMLCheckInsertSelectDesc", Other: "不建议使用INSERT ... SELECT"}
	DMLCheckInsertSelectAnnotation                               = &i18n.Message{ID: "DMLCheckInsertSelectAnnotation", Other: "使用 INSERT ... SELECT 在默认事务隔离级别下，可能会导致对查询的表施加表级锁。"}
	DMLCheckInsertSelectMessage                                  = &i18n.Message{ID: "DMLCheckInsertSelectMessage", Other: "不建议使用INSERT ... SELECT"}
	DMLCheckAggregateDesc                                        = &i18n.Message{ID: "DMLCheckAggregateDesc", Other: "不建议使用聚合函数"}
	DMLCheckAggregateAnnotation                                  = &i18n.Message{ID: "DMLCheckAggregateAnnotation", Other: "不建议使用SQL聚合函数,是为了确保查询的简单性、高性能和数据一致性。"}
	DMLCheckAggregateMessage                                     = &i18n.Message{ID: "DMLCheckAggregateMessage", Other: "不建议使用聚合函数计算"}
	DDLCheckColumnNotNULLDesc                                    = &i18n.Message{ID: "DDLCheckColumnNotNULLDesc", Other: "表字段建议有NOT NULL约束"}
	DDLCheckColumnNotNULLAnnotation                              = &i18n.Message{ID: "DDLCheckColumnNotNULLAnnotation", Other: "表字段建议有 NOT NULL 约束，可确保数据的完整性，防止插入空值，提升查询准确性。"}
	DDLCheckColumnNotNULLMessage                                 = &i18n.Message{ID: "DDLCheckColumnNotNULLMessage", Other: "建议字段%v设置NOT NULL约束"}
	DMLCheckIndexSelectivityDesc                                 = &i18n.Message{ID: "DMLCheckIndexSelectivityDesc", Other: "建议连库查询时，确保SQL执行计划中使用的索引区分度大于阈值"}
	DMLCheckIndexSelectivityAnnotation                           = &i18n.Message{ID: "DMLCheckIndexSelectivityAnnotation", Other: "确保SQL执行计划中使用的高索引区分度，有助于提升查询性能并优化查询效率。"}
	DMLCheckIndexSelectivityMessage                              = &i18n.Message{ID: "DMLCheckIndexSelectivityMessage", Other: "索引：%v，未超过区分度阈值：%v，建议使用超过阈值的索引。"}
	DMLCheckIndexSelectivityParams1                              = &i18n.Message{ID: "DMLCheckIndexSelectivityParams1", Other: "可选择性（百分比）"}
	DDLCheckTableRowsDesc                                        = &i18n.Message{ID: "DDLCheckTableRowsDesc", Other: "表行数超过阈值，建议对表进行拆分"}
	DDLCheckTableRowsAnnotation                                  = &i18n.Message{ID: "DDLCheckTableRowsAnnotation", Other: "当表行数超过阈值时，对表进行拆分有助于提高数据库性能和查询速度。"}
	DDLCheckTableRowsMessage                                     = &i18n.Message{ID: "DDLCheckTableRowsMessage", Other: "表行数超过阈值，建议对表进行拆分"}
	DDLCheckTableRowsParams1                                     = &i18n.Message{ID: "DDLCheckTableRowsParams1", Other: "表行数（万）"}
	DDLCheckCompositeIndexDistinctionDesc                        = &i18n.Message{ID: "DDLCheckCompositeIndexDistinctionDesc", Other: "建议在组合索引中将区分度高的字段靠前放"}
	DDLCheckCompositeIndexDistinctionAnnotation                  = &i18n.Message{ID: "DDLCheckCompositeIndexDistinctionAnnotation", Other: "将区分度高的字段靠前放置在组合索引中有助于提高索引的查询性能，因为它能更快地减小数据范围，提高检索效率。"}
	DDLCheckCompositeIndexDistinctionMessage                     = &i18n.Message{ID: "DDLCheckCompositeIndexDistinctionMessage", Other: "建议在组合索引中将区分度高的字段靠前放，%v"}
	DDLAvoidTextDesc                                             = &i18n.Message{ID: "DDLAvoidTextDesc", Other: "使用TEXT 类型的字段建议和原表进行分拆，与原表主键单独组成另外一个表进行存放"}
	DDLAvoidTextAnnotation                                       = &i18n.Message{ID: "DDLAvoidTextAnnotation", Other: "将TEXT类型的字段与原表主键分拆成另一个表可以提高数据库性能和查询速度，减少不必要的 I/O 操作。"}
	DDLAvoidTextMessage                                          = &i18n.Message{ID: "DDLAvoidTextMessage", Other: "字段：%v为TEXT类型，建议和原表进行分拆，与原表主键单独组成另外一个表进行存放"}
	DMLCheckSelectRowsDesc                                       = &i18n.Message{ID: "DMLCheckSelectRowsDesc", Other: "查询数据量超过阈值，筛选条件必须带上主键或者索引"}
	DMLCheckSelectRowsAnnotation                                 = &i18n.Message{ID: "DMLCheckSelectRowsAnnotation", Other: "筛选条件必须带上主键或索引可提高查询性能和减少全表扫描的成本。"}
	DMLCheckSelectRowsMessage                                    = &i18n.Message{ID: "DMLCheckSelectRowsMessage", Other: "查询数据量超过阈值，筛选条件必须带上主键或者索引"}
	DMLCheckSelectRowsParams1                                    = &i18n.Message{ID: "DMLCheckSelectRowsParams1", Other: "查询数据量（万）"}
	DMLCheckScanRowsDesc                                         = &i18n.Message{ID: "DMLCheckScanRowsDesc", Other: "扫描行数超过阈值，请检查索引配置"}
	DMLCheckScanRowsAnnotation                                   = &i18n.Message{ID: "DMLCheckScanRowsAnnotation", Other: "筛选条件必须带上主键或索引可降低数据库查询的时间复杂度，提高查询效率。"}
	DMLCheckScanRowsMessage                                      = &i18n.Message{ID: "DMLCheckScanRowsMessage", Other: "扫描行数超过阈值，请检查索引配置"}
	DMLCheckScanRowsParams1                                      = &i18n.Message{ID: "DMLCheckScanRowsParams1", Other: "扫描行数量（万）"}
	DMLMustUseLeftMostPrefixDesc                                 = &i18n.Message{ID: "DMLMustUseLeftMostPrefixDesc", Other: "使用联合索引时，必须使用联合索引的首字段"}
	DMLMustUseLeftMostPrefixAnnotation                           = &i18n.Message{ID: "DMLMustUseLeftMostPrefixAnnotation", Other: "使用联合索引时，不包含首字段会导致联合索引失效"}
	DMLMustUseLeftMostPrefixMessage                              = &i18n.Message{ID: "DMLMustUseLeftMostPrefixMessage", Other: "使用联合索引时，必须使用联合索引的首字段"}
	DMLMustMatchLeftMostPrefixDesc                               = &i18n.Message{ID: "DMLMustMatchLeftMostPrefixDesc", Other: "禁止对联合索引左侧字段进行IN 、OR等非等值查询"}
	DMLMustMatchLeftMostPrefixAnnotation                         = &i18n.Message{ID: "DMLMustMatchLeftMostPrefixAnnotation", Other: "对联合索引左侧字段进行IN 、OR等非等值查询会导致联合索引失效"}
	DMLMustMatchLeftMostPrefixMessage                            = &i18n.Message{ID: "DMLMustMatchLeftMostPrefixMessage", Other: "对联合索引左侧字段进行IN 、OR等非等值查询会导致联合索引失效"}
	DMLCheckJoinFieldUseIndexDesc                                = &i18n.Message{ID: "DMLCheckJoinFieldUseIndexDesc", Other: "JOIN字段必须包含索引"}
	DMLCheckJoinFieldUseIndexAnnotation                          = &i18n.Message{ID: "DMLCheckJoinFieldUseIndexAnnotation", Other: "JOIN字段包含索引可提高连接操作的性能和查询速度。"}
	DMLCheckJoinFieldUseIndexMessage                             = &i18n.Message{ID: "DMLCheckJoinFieldUseIndexMessage", Other: "JOIN字段必须包含索引"}
	DMLCheckJoinFieldCharacterSetAndCollationDesc                = &i18n.Message{ID: "DMLCheckJoinFieldCharacterSetAndCollationDesc", Other: "连接表字段的字符集和排序规则必须一致"}
	DMLCheckJoinFieldCharacterSetAndCollationAnnotation          = &i18n.Message{ID: "DMLCheckJoinFieldCharacterSetAndCollationAnnotation", Other: "连接表字段的字符集和排序规则一致可避免数据不一致和查询错误，确保连接操作正确执行。"}
	DMLCheckJoinFieldCharacterSetAndCollationMessage             = &i18n.Message{ID: "DMLCheckJoinFieldCharacterSetAndCollationMessage", Other: "连接表字段的字符集和排序规则必须一致"}
	DMLCheckMathComputationOrFuncOnIndexDesc                     = &i18n.Message{ID: "DMLCheckMathComputationOrFuncOnIndexDesc", Other: "禁止对索引列进行数学运算和使用函数"}
	DMLCheckMathComputationOrFuncOnIndexAnnotation               = &i18n.Message{ID: "DMLCheckMathComputationOrFuncOnIndexAnnotation", Other: "对索引列进行数学运算和使用函数会导致索引失效，从而导致全表扫描，影响查询性能。"}
	DMLCheckMathComputationOrFuncOnIndexMessage                  = &i18n.Message{ID: "DMLCheckMathComputationOrFuncOnIndexMessage", Other: "禁止对索引列进行数学运算和使用函数"}
	DMLSQLExplainLowestLevelDesc                                 = &i18n.Message{ID: "DMLSQLExplainLowestLevelDesc", Other: "SQL执行计划中type字段建议满足规定的级别"}
	DMLSQLExplainLowestLevelAnnotation                           = &i18n.Message{ID: "DMLSQLExplainLowestLevelAnnotation", Other: "验证 SQL 执行计划中的 type 字段，确保满足要求级别，以保证查询性能。"}
	DMLSQLExplainLowestLevelMessage                              = &i18n.Message{ID: "DMLSQLExplainLowestLevelMessage", Other: "建议修改SQL，确保执行计划中type字段可以满足规定中的任一等级：%v"}
	DMLSQLExplainLowestLevelParams1                              = &i18n.Message{ID: "DMLSQLExplainLowestLevelParams1", Other: "查询计划type等级，以英文逗号隔开"}
	DDLAvoidFullTextDesc                                         = &i18n.Message{ID: "DDLAvoidFullTextDesc", Other: "禁止使用全文索引"}
	DDLAvoidFullTextAnnotation                                   = &i18n.Message{ID: "DDLAvoidFullTextAnnotation", Other: "全文索引的使用会增加存储开销，并对写操作性能产生一定影响。"}
	DDLAvoidFullTextMessage                                      = &i18n.Message{ID: "DDLAvoidFullTextMessage", Other: "禁止使用全文索引"}
	DDLAvoidGeometryDesc                                         = &i18n.Message{ID: "DDLAvoidGeometryDesc", Other: "禁止使用空间字段和空间索引"}
	DDLAvoidGeometryAnnotation                                   = &i18n.Message{ID: "DDLAvoidGeometryAnnotation", Other: "使用空间字段和空间索引会增加存储需求，对数据库性能造成一定影响"}
	DDLAvoidGeometryMessage                                      = &i18n.Message{ID: "DDLAvoidGeometryMessage", Other: "禁止使用空间字段和空间索引"}
	DMLAvoidWhereEqualNullDesc                                   = &i18n.Message{ID: "DMLAvoidWhereEqualNullDesc", Other: "WHERE子句中禁止将NULL值与其他字段或值进行比较运算"}
	DMLAvoidWhereEqualNullAnnotation                             = &i18n.Message{ID: "DMLAvoidWhereEqualNullAnnotation", Other: "NULL在SQL中属于特殊值，无法与普通值进行比较。例如：column = NULL恒为false，即使column存在null值也不会查询出来，所以column = NULL应该写为column is NULL"}
	DMLAvoidWhereEqualNullMessage                                = &i18n.Message{ID: "DMLAvoidWhereEqualNullMessage", Other: "WHERE子句中禁止将NULL值与其他字段或值进行比较运算"}
	DDLAvoidEventDesc                                            = &i18n.Message{ID: "DDLAvoidEventDesc", Other: "禁止使用event"}
	DDLAvoidEventAnnotation                                      = &i18n.Message{ID: "DDLAvoidEventAnnotation", Other: "使用event会增加数据库的维护难度和依赖性，并且也会造成安全问题。"}
	DDLAvoidEventMessage                                         = &i18n.Message{ID: "DDLAvoidEventMessage", Other: "禁止使用event"}
	DDLCheckCharLengthDesc                                       = &i18n.Message{ID: "DDLCheckCharLengthDesc", Other: "禁止char, varchar类型字段字符长度总和超过阈值"}
	DDLCheckCharLengthAnnotation                                 = &i18n.Message{ID: "DDLCheckCharLengthAnnotation", Other: "使用过长或者过多的varchar，char字段可能会增加业务逻辑的复杂性；如果字段平均长度过大时，会占用更多的存储空间。"}
	DDLCheckCharLengthMessage                                    = &i18n.Message{ID: "DDLCheckCharLengthMessage", Other: "禁止char, varchar类型字段字符长度总和超过阈值 %v"}
	DDLCheckCharLengthParams1                                    = &i18n.Message{ID: "DDLCheckCharLengthParams1", Other: "字符长度"}
)

// rewrite rules
var (
	OptDMLHintGroupByRequiresConditionsDesc               = &i18n.Message{ID: "OptDMLHintGroupByRequiresConditionsDesc", Other: "为GROUP BY显示添加 ORDER BY 条件(<MYSQL 5.7)"}
	OptDMLHintGroupByRequiresConditionsAnnotation         = &i18n.Message{ID: "OptDMLHintGroupByRequiresConditionsAnnotation", Other: "在早期版本的MySQL中，GROUP BY 默认进行排序，可通过添加 ORDER BY NULL 来取消此排序，提高查询效率。"}
	OptDMLCheckWhereExistScalarSubqueryDesc               = &i18n.Message{ID: "OptDMLCheckWhereExistScalarSubqueryDesc", Other: "COUNT标量子查询重写"}
	OptDMLCheckWhereExistScalarSubqueryAnnotation         = &i18n.Message{ID: "OptDMLCheckWhereExistScalarSubqueryAnnotation", Other: "对于使用COUNT标量子查询来进行判断是否存在，可以重写为EXISTS子查询，从而避免一次聚集运算。"}
	OptDMLHintUseTruncateInsteadOfDeleteDesc              = &i18n.Message{ID: "OptDMLHintUseTruncateInsteadOfDeleteDesc", Other: "无条件的DELETE建议重写为Truncate"}
	OptDMLHintUseTruncateInsteadOfDeleteAnnotation        = &i18n.Message{ID: "OptDMLHintUseTruncateInsteadOfDeleteAnnotation", Other: "TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，同时TRUNCATE后表所占用的空间会被释放，而DELETE后需要手工执行OPTIMIZE才能释放表空间"}
	OptDMLCheckWhereExistImplicitConversionDesc           = &i18n.Message{ID: "OptDMLCheckWhereExistImplicitConversionDesc", Other: "隐式类型转换导致索引失效"}
	OptDMLCheckWhereExistImplicitConversionAnnotation     = &i18n.Message{ID: "OptDMLCheckWhereExistImplicitConversionAnnotation", Other: "WHERE条件中使用与过滤字段不一致的数据类型会引发隐式数据类型转换，导致查询有无法命中索引的风险，在高并发、大数据量的情况下，不走索引会使得数据库的查询性能严重下降"}
	OptDMLCheckMathComputationOrFuncOnIndexDesc           = &i18n.Message{ID: "OptDMLCheckMathComputationOrFuncOnIndexDesc", Other: "索引列上的运算导致索引失效"}
	OptDMLCheckMathComputationOrFuncOnIndexAnnotation     = &i18n.Message{ID: "OptDMLCheckMathComputationOrFuncOnIndexAnnotation", Other: "在索引列上的运算将导致索引失效，容易造成全表扫描，产生严重的性能问题。所以需要尽量将索引列上的运算转换到常量端进行。"}
	OptDMLNotRecommendHavingDesc                          = &i18n.Message{ID: "OptDMLNotRecommendHavingDesc", Other: "HAVING条件下推"}
	OptDMLNotRecommendHavingAnnotation                    = &i18n.Message{ID: "OptDMLNotRecommendHavingAnnotation", Other: "从逻辑上，HAVING条件是在分组之后执行的，而WHERE子句上的条件可以在表访问的时候（索引访问）,或是表访问之后、分组之前执行，这两种条件都比在分组之后执行代价要小。"}
	OptDMLWhereExistNullDesc                              = &i18n.Message{ID: "OptDMLWhereExistNullDesc", Other: "禁止使用=NULL判断空值"}
	OptDMLWhereExistNullAnnotation                        = &i18n.Message{ID: "OptDMLWhereExistNullAnnotation", Other: "= null并不能判断表达式为空,= null总是被判断为假。判断表达式为空应该使用is null。"}
	OptDMLNotRecommendInDesc                              = &i18n.Message{ID: "OptDMLNotRecommendInDesc", Other: "IN子查询优化"}
	OptDMLNotRecommendInAnnotation                        = &i18n.Message{ID: "OptDMLNotRecommendInAnnotation", Other: "IN子查询是指符合下面形式的子查询，IN子查询可以改写成等价的相关EXISTS子查询或是内连接，从而可以产生一个新的过滤条件。"}
	OptDMLHintInNullOnlyFalseDesc                         = &i18n.Message{ID: "OptDMLHintInNullOnlyFalseDesc", Other: "IN可空子查询可能导致结果集不符合预期"}
	OptDMLHintInNullOnlyFalseAnnotation                   = &i18n.Message{ID: "OptDMLHintInNullOnlyFalseAnnotation", Other: "查询条件永远非真，这将导致查询无匹配到的结果"}
	OptDMLNotRecommendNotWildcardLikeDesc                 = &i18n.Message{ID: "OptDMLNotRecommendNotWildcardLikeDesc", Other: "避免使用没有通配符的 LIKE 查询"}
	OptDMLNotRecommendNotWildcardLikeAnnotation           = &i18n.Message{ID: "OptDMLNotRecommendNotWildcardLikeAnnotation", Other: "不包含通配符的LIKE 查询逻辑上与等值查询相同，建议使用等值查询替代。而且不包含通配符的LIKE 查询逻辑通常是由于开发者错误导致的，可能不符合其期望的业务逻辑实现"}
	OptDMLCheckNotEqualSymbolDesc                         = &i18n.Message{ID: "OptDMLCheckNotEqualSymbolDesc", Other: "建议使用'<>'代替'!='"}
	OptDMLCheckNotEqualSymbolAnnotation                   = &i18n.Message{ID: "OptDMLCheckNotEqualSymbolAnnotation", Other: "'!=' 是非标准的运算符，'<>' 才是SQL中标准的不等于运算符"}
	OptDMLCheckLimitOffsetNumDesc                         = &i18n.Message{ID: "OptDMLCheckLimitOffsetNumDesc", Other: "OFFSET的值超过阈值"}
	OptDMLCheckLimitOffsetNumAnnotation                   = &i18n.Message{ID: "OptDMLCheckLimitOffsetNumAnnotation", Other: "使用LIMIT和OFFSET子句可以分别控制查询结果的数量和指定从哪一行开始返回数据。但是，当OFFSET值较大时，查询效率会降低，因为系统必须扫描更多数据才能找到起始行，这在大数据集中尤其会导致性能问题和资源消耗。"}
	OptDMLRuleNPERewriteDesc                              = &i18n.Message{ID: "OptDMLRuleNPERewriteDesc", Other: "NPE重写"}
	OptDMLRuleNPERewriteAnnotation                        = &i18n.Message{ID: "OptDMLRuleNPERewriteAnnotation", Other: "SQL的NPE(Null Pointer Exception)问题是指在SQL查询中,当聚合列全为NULL时,SUM、AVG等聚合函数会返回NULL,这可能会导致后续的程序出现空指针异常。"}
	OptDMLRuleAllSubqueryRewriteDesc                      = &i18n.Message{ID: "OptDMLRuleAllSubqueryRewriteDesc", Other: "ALL修饰的子查询重写"}
	OptDMLRuleAllSubqueryRewriteAnnotation                = &i18n.Message{ID: "OptDMLRuleAllSubqueryRewriteAnnotation", Other: "如果ALL子查询的结果中存在NULL，这个SQL永远返回为空。正确的写法应该是在子查询里加上非空限制，或使用max/min的写法。"}
	OptDMLRuleDiffOrderingSpecTypeWarningDesc             = &i18n.Message{ID: "OptDMLRuleDiffOrderingSpecTypeWarningDesc", Other: "排序字段方向不同导致索引失效"}
	OptDMLRuleDiffOrderingSpecTypeWarningAnnotation       = &i18n.Message{ID: "OptDMLRuleDiffOrderingSpecTypeWarningAnnotation", Other: "ORDER BY 子句中的所有表达式需要按统一的 ASC 或 DESC 方向排序，才能利用索引来避免排序；如果ORDER BY 语句对多个不同条件使用不同方向的排序无法使用索引"}
	OptDMLRuleDistinctEliminationRewriteDesc              = &i18n.Message{ID: "OptDMLRuleDistinctEliminationRewriteDesc", Other: "子查询中的DISTINCT消除"}
	OptDMLRuleDistinctEliminationRewriteAnnotation        = &i18n.Message{ID: "OptDMLRuleDistinctEliminationRewriteAnnotation", Other: "对于仅进行存在性测试的子查询,如果子查询包含DISTINCT通常可以删除,以避免一次去重操作。"}
	OptDMLRuleExists2JoinRewriteDesc                      = &i18n.Message{ID: "OptDMLRuleExists2JoinRewriteDesc", Other: "EXISTS查询转换为表连接"}
	OptDMLRuleExists2JoinRewriteAnnotation                = &i18n.Message{ID: "OptDMLRuleExists2JoinRewriteAnnotation", Other: "EXISTS子查询可以在适当情况下转换为JOIN来优化查询，提高数据库处理效率和性能。"}
	OptDMLRuleFilterPredicatePushDownRewriteDesc          = &i18n.Message{ID: "OptDMLRuleFilterPredicatePushDownRewriteDesc", Other: "过滤谓词下推"}
	OptDMLRuleFilterPredicatePushDownRewriteAnnotation    = &i18n.Message{ID: "OptDMLRuleFilterPredicatePushDownRewriteAnnotation", Other: "滤条件下推（FPPD）是一种通过将过滤条件提前应用于内部查询块，以减少数据处理量并提升SQL执行效率。"}
	OptDMLRuleGroupingFromDiffTablesRewriteDesc           = &i18n.Message{ID: "OptDMLRuleGroupingFromDiffTablesRewriteDesc", Other: "GROUPBY字段来自不同表"}
	OptDMLRuleGroupingFromDiffTablesRewriteAnnotation     = &i18n.Message{ID: "OptDMLRuleGroupingFromDiffTablesRewriteAnnotation", Other: "如果分组字段来自不同的表，数据库优化器将没有办法利用索引的有序性来避免一次排序，如果存在等值条件，可以替换这些字段为来自同一张表的字段，以利用索引优化排序和提高查询效率。"}
	OptDMLRuleJoinEliminationRewriteDesc                  = &i18n.Message{ID: "OptDMLRuleJoinEliminationRewriteDesc", Other: "表连接消除"}
	OptDMLRuleJoinEliminationRewriteAnnotation            = &i18n.Message{ID: "OptDMLRuleJoinEliminationRewriteAnnotation", Other: "在不影响结果的情况下通过删除不必要的表连接来简化查询并提升性能，适用于查询仅涉及到主表主键列的场景。"}
	OptDMLRuleLimitClausePushDownRewriteDesc              = &i18n.Message{ID: "OptDMLRuleLimitClausePushDownRewriteDesc", Other: "LIMIT下推至UNION分支"}
	OptDMLRuleLimitClausePushDownRewriteAnnotation        = &i18n.Message{ID: "OptDMLRuleLimitClausePushDownRewriteAnnotation", Other: "Limit子句下推优化通过尽可能的 “下压” Limit子句，提前过滤掉部分数据, 减少中间结果集的大小，减少后续计算需要处理的数据量, 以提高查询性能。"}
	OptDMLRuleLimitClausePushDownRewriteParams1           = &i18n.Message{ID: "OptDMLRuleLimitClausePushDownRewriteParams1", Other: "OFFSET最大阈值"}
	OptDMLRuleMaxMinAggRewriteDesc                        = &i18n.Message{ID: "OptDMLRuleMaxMinAggRewriteDesc", Other: "MAX/MIN子查询重写"}
	OptDMLRuleMaxMinAggRewriteAnnotation                  = &i18n.Message{ID: "OptDMLRuleMaxMinAggRewriteAnnotation", Other: "对于使用MAX/MIN的子查询，可以通过重写从而利用索引的有序来避免一次聚集运算。"}
	OptDMLRuleMoveOrder2LeadingRewriteDesc                = &i18n.Message{ID: "OptDMLRuleMoveOrder2LeadingRewriteDesc", Other: "ORDER子句重排序优化"}
	OptDMLRuleMoveOrder2LeadingRewriteAnnotation          = &i18n.Message{ID: "OptDMLRuleMoveOrder2LeadingRewriteAnnotation", Other: "如果一个查询中既包含来自同一个表的排序字段也包含分组字段，但字段顺序不同，可以通过调整分组字段顺序，使其和排序字段顺序一致，这样数据库可以避免一次排序操作。"}
	OptDMLRuleOrCond4SelectRewriteDesc                    = &i18n.Message{ID: "OptDMLRuleOrCond4SelectRewriteDesc", Other: "OR条件的SELECT重写"}
	OptDMLRuleOrCond4SelectRewriteAnnotation              = &i18n.Message{ID: "OptDMLRuleOrCond4SelectRewriteAnnotation", Other: "如果使用OR条件的查询语句，数据库优化器有可能无法使用索引来完成查询，可以把查询语句重写为UNION或UNION ALL查询，以便使用索引提升查询性能。"}
	OptDMLRuleOrCond4UpDeleteRewriteDesc                  = &i18n.Message{ID: "OptDMLRuleOrCond4UpDeleteRewriteDesc", Other: "OR条件的UPDELETE重写"}
	OptDMLRuleOrCond4UpDeleteRewriteAnnotation            = &i18n.Message{ID: "OptDMLRuleOrCond4UpDeleteRewriteAnnotation", Other: "如果有使用OR条件的UPDATE或DELETE语句，数据库优化器有可能无法使用索引来完成操作，可以把它重写为多个DELETE语句，利用索引提升查询性能。"}
	OptDMLRuleOrderEliminationInSubqueryRewriteDesc       = &i18n.Message{ID: "OptDMLRuleOrderEliminationInSubqueryRewriteDesc", Other: "IN子查询中没有LIMIT的排序消除"}
	OptDMLRuleOrderEliminationInSubqueryRewriteAnnotation = &i18n.Message{ID: "OptDMLRuleOrderEliminationInSubqueryRewriteAnnotation", Other: "如果子查询没有LIMIT子句，那么子查询的排序操作就没有意义，可以将其删除而不影响最终的结果。"}
	OptDMLRuleOrderingFromDiffTablesRewriteDesc           = &i18n.Message{ID: "OptDMLRuleOrderingFromDiffTablesRewriteDesc", Other: "避免ORDERBY字段来自不同表"}
	OptDMLRuleOrderingFromDiffTablesRewriteAnnotation     = &i18n.Message{ID: "OptDMLRuleOrderingFromDiffTablesRewriteAnnotation", Other: "当排序字段来自不同表时，若存在等值条件，可替换这些字段为来自同一张表的字段，利用索引避免额外排序，提升效率。"}
	OptDMLRuleOuter2InnerConversionRewriteDesc            = &i18n.Message{ID: "OptDMLRuleOuter2InnerConversionRewriteDesc", Other: "外连接优化"}
	OptDMLRuleOuter2InnerConversionRewriteAnnotation      = &i18n.Message{ID: "OptDMLRuleOuter2InnerConversionRewriteAnnotation", Other: "外连接优化指的是满足一定条件（外表具有NULL拒绝条件）的外连接可以转化为内连接，从而可以让数据库优化器可以选择更优的执行计划，提升SQL查询的性能。"}
	OptDMLRuleProjectionPushdownRewriteDesc               = &i18n.Message{ID: "OptDMLRuleProjectionPushdownRewriteDesc", Other: "投影下推(PROJECTION PUSHDOWN)"}
	OptDMLRuleProjectionPushdownRewriteAnnotation         = &i18n.Message{ID: "OptDMLRuleProjectionPushdownRewriteAnnotation", Other: "投影下推指的通过删除DT子查询中无意义的列（在外查询中没有使用），来减少IO和网络的代价，同时提升优化器在进行表访问的规划时，采用无需回表的优化选项的几率。"}
	OptDMLRuleQualifierSubQueryRewriteDesc                = &i18n.Message{ID: "OptDMLRuleQualifierSubQueryRewriteDesc", Other: "修饰子查询重写优化"}
	OptDMLRuleQualifierSubQueryRewriteAnnotation          = &i18n.Message{ID: "OptDMLRuleQualifierSubQueryRewriteAnnotation", Other: "ANY/SOME/ALL修饰的子查询用于比较值关系，但效率低下因为它们逐行处理比较。通过查询重写可以提升这类子查询的执行效率。"}
	OptDMLRuleQueryFoldingRewriteDesc                     = &i18n.Message{ID: "OptDMLRuleQueryFoldingRewriteDesc", Other: "查询折叠(QUERY FOLDING)"}
	OptDMLRuleQueryFoldingRewriteAnnotation               = &i18n.Message{ID: "OptDMLRuleQueryFoldingRewriteAnnotation", Other: "查询折叠指的是把视图、CTE或是DT子查询展开，并与引用它的查询语句合并，来减少序列化中间结果集，或是触发更优的关于表连接规划的优化技术。"}
	OptDMLRuleSATTCRewriteDesc                            = &i18n.Message{ID: "OptDMLRuleSATTCRewriteDesc", Other: "SATTC重写优化"}
	OptDMLRuleSATTCRewriteAnnotation                      = &i18n.Message{ID: "OptDMLRuleSATTCRewriteAnnotation", Other: "SAT-TC重写优化通过分析和处理查询条件的逻辑关系，以发现矛盾、简化条件或推断新条件，从而帮助数据库优化器制定更高效的执行计划，提升SQL性能。"}

	OptOracle500Desc       = &i18n.Message{ID: "OptOracle500Desc", Other: "NPE重写"}
	OptOracle500Annotation = &i18n.Message{ID: "OptOracle500Annotation", Other: "SQL的NPE(Null Pointer Exception)问题是指在SQL查询中,当聚合列全为NULL时,SUM、AVG等聚合函数会返回NULL,这可能会导致后续的程序出现空指针异常。"}
	OptOracle501Desc       = &i18n.Message{ID: "OptOracle501Desc", Other: "ALL修饰的子查询重写"}
	OptOracle501Annotation = &i18n.Message{ID: "OptOracle501Annotation", Other: "如果ALL子查询的结果中存在NULL，这个SQL永远返回为空。正确的写法应该是在子查询里加上非空限制，或使用max/min的写法。"}
	OptOracle502Desc       = &i18n.Message{ID: "OptOracle502Desc", Other: "COUNT标量子查询重写"}
	OptOracle502Annotation = &i18n.Message{ID: "OptOracle502Annotation", Other: "对于使用COUNT标量子查询来进行判断是否存在，可以重写为EXISTS子查询，从而避免一次聚集运算。"}
	OptOracle503Desc       = &i18n.Message{ID: "OptOracle503Desc", Other: "无条件的DELETE建议重写为Truncate"}
	OptOracle503Annotation = &i18n.Message{ID: "OptOracle503Annotation", Other: "TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，同时TRUNCATE后表所占用的空间会被释放，而DELETE后需要手工执行OPTIMIZE才能释放表空间"}
	OptOracle504Desc       = &i18n.Message{ID: "OptOracle504Desc", Other: "隐式类型转换导致索引失效"}
	OptOracle504Annotation = &i18n.Message{ID: "OptOracle504Annotation", Other: "WHERE条件中使用与过滤字段不一致的数据类型会引发隐式数据类型转换，导致查询有无法命中索引的风险，在高并发、大数据量的情况下，不走索引会使得数据库的查询性能严重下降"}
	OptOracle505Desc       = &i18n.Message{ID: "OptOracle505Desc", Other: "排序字段方向不同导致索引失效"}
	OptOracle505Annotation = &i18n.Message{ID: "OptOracle505Annotation", Other: "ORDER BY 子句中的所有表达式需要按统一的 ASC 或 DESC 方向排序，才能利用索引来避免排序；如果ORDER BY 语句对多个不同条件使用不同方向的排序无法使用索引"}
	OptOracle506Desc       = &i18n.Message{ID: "OptOracle506Desc", Other: "索引列上的运算导致索引失效"}
	OptOracle506Annotation = &i18n.Message{ID: "OptOracle506Annotation", Other: "在索引列上的运算将导致索引失效，容易造成全表扫描，产生严重的性能问题。所以需要尽量将索引列上的运算转换到常量端进行。"}
	OptOracle507Desc       = &i18n.Message{ID: "OptOracle507Desc", Other: "HAVING条件下推"}
	OptOracle507Annotation = &i18n.Message{ID: "OptOracle507Annotation", Other: "从逻辑上，HAVING条件是在分组之后执行的，而WHERE子句上的条件可以在表访问的时候（索引访问）,或是表访问之后、分组之前执行，这两种条件都比在分组之后执行代价要小。"}
	OptOracle508Desc       = &i18n.Message{ID: "OptOracle508Desc", Other: "禁止使用=NULL判断空值"}
	OptOracle508Annotation = &i18n.Message{ID: "OptOracle508Annotation", Other: "= null并不能判断表达式为空,= null总是被判断为假。判断表达式为空应该使用is null。"}
	OptOracle509Desc       = &i18n.Message{ID: "OptOracle509Desc", Other: "IN子查询优化"}
	OptOracle509Annotation = &i18n.Message{ID: "OptOracle509Annotation", Other: "IN子查询是指符合下面形式的子查询，IN子查询可以改写成等价的相关EXISTS子查询或是内连接，从而可以产生一个新的过滤条件。"}
	OptOracle510Desc       = &i18n.Message{ID: "OptOracle510Desc", Other: "IN可空子查询可能导致结果集不符合预期"}
	OptOracle510Annotation = &i18n.Message{ID: "OptOracle510Annotation", Other: "查询条件永远非真，这将导致查询无匹配到的结果"}
	OptOracle511Desc       = &i18n.Message{ID: "OptOracle511Desc", Other: "避免使用没有通配符的 LIKE 查询"}
	OptOracle511Annotation = &i18n.Message{ID: "OptOracle511Annotation", Other: "不包含通配符的LIKE 查询逻辑上与等值查询相同，建议使用等值查询替代。而且不包含通配符的LIKE 查询逻辑通常是由于开发者错误导致的，可能不符合其期望的业务逻辑实现"}
	OptOracle512Desc       = &i18n.Message{ID: "OptOracle512Desc", Other: "建议使用'<>'代替'!='"}
	OptOracle512Annotation = &i18n.Message{ID: "OptOracle512Annotation", Other: "'!=' 是非标准的运算符，'<>' 才是SQL中标准的不等于运算符"}
	OptOracle513Desc       = &i18n.Message{ID: "OptOracle513Desc", Other: "子查询中的DISTINCT消除"}
	OptOracle513Annotation = &i18n.Message{ID: "OptOracle513Annotation", Other: "对于仅进行存在性测试的子查询,如果子查询包含DISTINCT通常可以删除,以避免一次去重操作。"}
	OptOracle514Desc       = &i18n.Message{ID: "OptOracle514Desc", Other: "EXISTS查询转换为表连接"}
	OptOracle514Annotation = &i18n.Message{ID: "OptOracle514Annotation", Other: "EXISTS子查询可以在适当情况下转换为JOIN来优化查询，提高数据库处理效率和性能。"}
	OptOracle515Desc       = &i18n.Message{ID: "OptOracle515Desc", Other: "过滤谓词下推"}
	OptOracle515Annotation = &i18n.Message{ID: "OptOracle515Annotation", Other: "滤条件下推（FPPD）是一种通过将过滤条件提前应用于内部查询块，以减少数据处理量并提升SQL执行效率。"}
	OptOracle516Desc       = &i18n.Message{ID: "OptOracle516Desc", Other: "GROUPBY字段来自不同表"}
	OptOracle516Annotation = &i18n.Message{ID: "OptOracle516Annotation", Other: "如果分组字段来自不同的表，数据库优化器将没有办法利用索引的有序性来避免一次排序，如果存在等值条件，可以替换这些字段为来自同一张表的字段，以利用索引优化排序和提高查询效率。"}
	OptOracle517Desc       = &i18n.Message{ID: "OptOracle517Desc", Other: "表连接消除"}
	OptOracle517Annotation = &i18n.Message{ID: "OptOracle517Annotation", Other: "在不影响结果的情况下通过删除不必要的表连接来简化查询并提升性能，适用于查询仅涉及到主表主键列的场景。"}
	OptOracle518Desc       = &i18n.Message{ID: "OptOracle518Desc", Other: "MAX/MIN子查询重写"}
	OptOracle518Annotation = &i18n.Message{ID: "OptOracle518Annotation", Other: "对于使用MAX/MIN的子查询，可以通过重写从而利用索引的有序来避免一次聚集运算。"}
	OptOracle519Desc       = &i18n.Message{ID: "OptOracle519Desc", Other: "ORDER子句重排序优化"}
	OptOracle519Annotation = &i18n.Message{ID: "OptOracle519Annotation", Other: "如果一个查询中既包含来自同一个表的排序字段也包含分组字段，但字段顺序不同，可以通过调整分组字段顺序，使其和排序字段顺序一致，这样数据库可以避免一次排序操作。"}
	OptOracle520Desc       = &i18n.Message{ID: "OptOracle520Desc", Other: "OR条件的SELECT重写"}
	OptOracle520Annotation = &i18n.Message{ID: "OptOracle520Annotation", Other: "如果使用OR条件的查询语句，数据库优化器有可能无法使用索引来完成查询，可以把查询语句重写为UNION或UNION ALL查询，以便使用索引提升查询性能。"}
	OptOracle521Desc       = &i18n.Message{ID: "OptOracle521Desc", Other: "OR条件的UPDELETE重写"}
	OptOracle521Annotation = &i18n.Message{ID: "OptOracle521Annotation", Other: "如果有使用OR条件的UPDATE或DELETE语句，数据库优化器有可能无法使用索引来完成操作，可以把它重写为多个DELETE语句，利用索引提升查询性能。"}
	OptOracle522Desc       = &i18n.Message{ID: "OptOracle522Desc", Other: "避免ORDERBY字段来自不同表"}
	OptOracle522Annotation = &i18n.Message{ID: "OptOracle522Annotation", Other: "当排序字段来自不同表时，若存在等值条件，可替换这些字段为来自同一张表的字段，利用索引避免额外排序，提升效率。"}
	OptOracle523Desc       = &i18n.Message{ID: "OptOracle523Desc", Other: "外连接优化"}
	OptOracle523Annotation = &i18n.Message{ID: "OptOracle523Annotation", Other: "外连接优化指的是满足一定条件（外表具有NULL拒绝条件）的外连接可以转化为内连接，从而可以让数据库优化器可以选择更优的执行计划，提升SQL查询的性能。"}
	OptOracle524Desc       = &i18n.Message{ID: "OptOracle524Desc", Other: "投影下推(PROJECTION PUSHDOWN)"}
	OptOracle524Annotation = &i18n.Message{ID: "OptOracle524Annotation", Other: "投影下推指的通过删除DT子查询中无意义的列（在外查询中没有使用），来减少IO和网络的代价，同时提升优化器在进行表访问的规划时，采用无需回表的优化选项的几率。"}
	OptOracle525Desc       = &i18n.Message{ID: "OptOracle525Desc", Other: "修饰子查询重写优化"}
	OptOracle525Annotation = &i18n.Message{ID: "OptOracle525Annotation", Other: "ANY/SOME/ALL修饰的子查询用于比较值关系，但效率低下因为它们逐行处理比较。通过查询重写可以提升这类子查询的执行效率。"}
	OptOracle526Desc       = &i18n.Message{ID: "OptOracle526Desc", Other: "查询折叠(QUERY FOLDING)"}
	OptOracle526Annotation = &i18n.Message{ID: "OptOracle526Annotation", Other: "查询折叠指的是把视图、CTE或是DT子查询展开，并与引用它的查询语句合并，来减少序列化中间结果集，或是触发更优的关于表连接规划的优化技术。"}
	OptOracle527Desc       = &i18n.Message{ID: "OptOracle527Desc", Other: "SATTC重写优化"}
	OptOracle527Annotation = &i18n.Message{ID: "OptOracle527Annotation", Other: "SAT-TC重写优化通过分析和处理查询条件的逻辑关系，以发现矛盾、简化条件或推断新条件，从而帮助数据库优化器制定更高效的执行计划，提升SQL性能。"}
)

// ai rules
var (
	Rule00001Desc       = &i18n.Message{ID: "Rule00001Desc", Other: "禁止SQL语句不带WHERE条件或者WHERE条件为永真"}
	Rule00001Annotation = &i18n.Message{ID: "Rule00001Annotation", Other: "使用有效的WHERE条件能够避免全表扫描，提高SQL执行效率；而恒为TRUE的WHERE条件，如where 1=1、where true=true等，在执行时会进行全表扫描产生额外开销。"}
	Rule00001Message    = &i18n.Message{ID: "Rule00001Message", Other: "禁止SQL语句不带WHERE条件或者WHERE条件为永真"}
	Rule00002Desc       = &i18n.Message{ID: "Rule00002Desc", Other: "SQL绑定的变量个数不建议超过阈值"}
	Rule00002Annotation = &i18n.Message{ID: "Rule00002Annotation", Other: "过度使用绑定变量会增加查询的复杂度，从而降低查询性能。同时还会增加维护成本。SQLE设置MySQL绑定变量个数最大阈值：100"}
	Rule00002Message    = &i18n.Message{ID: "Rule00002Message", Other: "SQL绑定的变量个数不建议超过阈值"}
	Rule00002Params1    = &i18n.Message{ID: "Rule00002Params1", Other: "绑定变量阈值"}
	Rule00003Desc       = &i18n.Message{ID: "Rule00003Desc", Other: "建议为组成索引的字段添加非空约束，并配置合理的default值"}
	Rule00003Annotation = &i18n.Message{ID: "Rule00003Annotation", Other: "在MySQL中，NULL值表示的含义为missing unknown value，在不同的场景下MySQL存在不同的处理方式；当字段内容存在NULL值时，处理结果可能存在异常"}
	Rule00003Message    = &i18n.Message{ID: "Rule00003Message", Other: "建议为组成索引的字段添加非空约束，并配置合理的default值"}
	Rule00004Desc       = &i18n.Message{ID: "Rule00004Desc", Other: "建议表的自增字段起始值为0"}
	Rule00004Annotation = &i18n.Message{ID: "Rule00004Annotation", Other: "创建表时AUTO_INCREMENT设置为0则自增从1开始，可以避免数据空洞。例如在导出表结构DDL时，表结构内AUTO_INCREMENT通常为当前的自增值，如果建表时没有把AUTO_INCREMENT设置为0，那么通过该DDL进行建表操作会导致自增值从一个无意义数字开始。"}
	Rule00004Message    = &i18n.Message{ID: "Rule00004Message", Other: "建议表的自增字段起始值为0"}
	Rule00005Desc       = &i18n.Message{ID: "Rule00005Desc", Other: "避免复合索引中包含过多字段"}
	Rule00005Annotation = &i18n.Message{ID: "Rule00005Annotation", Other: "在设计复合索引过程中，每增加一个索引字段，都会使索引的大小线性增加，从而占用更多的磁盘空间，且增加索引维护的开销。尤其是在数据频繁变动的环境中，这会显著增加数据库的维护压力。"}
	Rule00005Message    = &i18n.Message{ID: "Rule00005Message", Other: "避免复合索引中包含过多字段"}
	Rule00005Params1    = &i18n.Message{ID: "Rule00005Params1", Other: "复合索引内字段个数"}
	Rule00007Desc       = &i18n.Message{ID: "Rule00007Desc", Other: "建表时，自增字段只能设置一个"}
	Rule00007Annotation = &i18n.Message{ID: "Rule00007Annotation", Other: "多个自增字段会造成表写入性能影响、可读性差、数据库设计不规范等缺点。"}
	Rule00007Message    = &i18n.Message{ID: "Rule00007Message", Other: "建表时，自增字段只能设置一个"}
	Rule00008Desc       = &i18n.Message{ID: "Rule00008Desc", Other: "表里必须存在主键"}
	Rule00008Annotation = &i18n.Message{ID: "Rule00008Annotation", Other: "表必须存在主键。如果表没有明确指定主键，可能会导致一些问题，如数据一致性难以保证、查询性能下降、数据完整性问题、数据管理和维护困难以及数据库优化受限等。"}
	Rule00008Message    = &i18n.Message{ID: "Rule00008Message", Other: "表里必须存在主键"}
	Rule00009Desc       = &i18n.Message{ID: "Rule00009Desc", Other: "避免对条件字段使用函数操作"}
	Rule00009Annotation = &i18n.Message{ID: "Rule00009Annotation", Other: "对条件字段做函数操作，可能会破坏索引值的有序性，导致优化器选择放弃走索引，使查询性能大幅度降低"}
	Rule00009Message    = &i18n.Message{ID: "Rule00009Message", Other: "避免对条件字段使用函数操作"}
	Rule00010Desc       = &i18n.Message{ID: "Rule00010Desc", Other: "禁止进行删除主键的操作"}
	Rule00010Annotation = &i18n.Message{ID: "Rule00010Annotation", Other: "删除主键将影响表数据结构和性能，属于高开销操作。另外，如果业务中使用了主键，删除主键可能导致业务逻辑阻塞、异常等问题。"}
	Rule00010Message    = &i18n.Message{ID: "Rule00010Message", Other: "禁止进行删除主键的操作"}
	Rule00011Desc       = &i18n.Message{ID: "Rule00011Desc", Other: "存在多条对同一个表的修改语句，建议合并成一个ALTER语句"}
	Rule00011Annotation = &i18n.Message{ID: "Rule00011Annotation", Other: "避免对同一个表使用多条单独的ALTER语句，以减少数据库的锁定时间和执行开销，提高SQL语句的可读性和维护性。"}
	Rule00011Message    = &i18n.Message{ID: "Rule00011Message", Other: "存在多条对同一个表的修改语句，建议合并成一个ALTER语句"}
	Rule00012Desc       = &i18n.Message{ID: "Rule00012Desc", Other: "建议使用BIGINT类型表示小数"}
	Rule00012Annotation = &i18n.Message{ID: "Rule00012Annotation", Other: "在MySQL中，对于金额等需要高精度计算的小数，建议使用BIGINT类型表示，以避免浮点数精度问题。例如，可以用分来表示金额，1元在数据库中用整型表示为100。"}
	Rule00012Message    = &i18n.Message{ID: "Rule00012Message", Other: "建议使用BIGINT类型表示小数"}
	Rule00013Desc       = &i18n.Message{ID: "Rule00013Desc", Other: "建议使用 DECIMAL 类型表示精确数值"}
	Rule00013Annotation = &i18n.Message{ID: "Rule00013Annotation", Other: "在数据库中，精确数值的表示对于财务数据、统计数据等需要高精度计算的场景至关重要。使用非精确浮点类型如 FLOAT 或 DOUBLE 可能导致精度丢失、计算误差，从而影响数据的准确性与可靠性。"}
	Rule00013Message    = &i18n.Message{ID: "Rule00013Message", Other: "建议使用 DECIMAL 类型表示精确数值. 不符合规定的字段: %v"}
	Rule00014Desc       = &i18n.Message{ID: "Rule00014Desc", Other: "不建议使用自定义函数"}
	Rule00014Annotation = &i18n.Message{ID: "Rule00014Annotation", Other: "自定义函数和存储过程维护较困难，且依赖性高，可能导致SQL无法跨库使用。此外，它们在使用时存在一些限制，如无法使用事务相关语句、无法直接产生输出的语句，以及无法在函数体内使用USE语句指定数据库。"}
	Rule00014Message    = &i18n.Message{ID: "Rule00014Message", Other: "不建议使用自定义函数"}
	Rule00015Desc       = &i18n.Message{ID: "Rule00015Desc", Other: "避免库内出现多种数据库排序规则"}
	Rule00015Annotation = &i18n.Message{ID: "Rule00015Annotation", Other: "建议库内使用一致的数据库排序规则，以确保查询性能和索引有效性，避免因排序规则不一致导致的全表扫描和数据一致性问题。"}
	Rule00015Message    = &i18n.Message{ID: "Rule00015Message", Other: "避免库内出现多种数据库排序规则"}
	Rule00016Desc       = &i18n.Message{ID: "Rule00016Desc", Other: "存储大数据类型（如长文本、图片等）的字段只能设置为NULL"}
	Rule00016Annotation = &i18n.Message{ID: "Rule00016Annotation", Other: "在MySQL中，存储大数据类型的内容常用BLOB和TEXT、GEOMETRY以及JSON类型，但它们无法指定默认值；写入数据时，如未对该字段指定值会导致写入失败。"}
	Rule00016Message    = &i18n.Message{ID: "Rule00016Message", Other: "存储大数据类型（如长文本、图片等）的字段只能设置为NULL"}
	Rule00017Desc       = &i18n.Message{ID: "Rule00017Desc", Other: "不建议使用BLOB或TEXT类型"}
	Rule00017Annotation = &i18n.Message{ID: "Rule00017Annotation", Other: "BLOB或TEXT类型消耗大量的磁盘空间、网络IO带宽，同时在该表上的DML操作都会变得很慢"}
	Rule00017Message    = &i18n.Message{ID: "Rule00017Message", Other: "不建议使用BLOB或TEXT类型. 不符合规定的字段: %v"}
	Rule00018Desc       = &i18n.Message{ID: "Rule00018Desc", Other: "CHAR长度大于20时，建议使用VARCHAR类型"}
	Rule00018Annotation = &i18n.Message{ID: "Rule00018Annotation", Other: "VARCHAR是变长字段，存储空间小，可节省存储空间，同时相对较小的字段检索效率显然也要高些"}
	Rule00018Message    = &i18n.Message{ID: "Rule00018Message", Other: "CHAR长度大于20时，建议使用VARCHAR类型"}
	Rule00018Params1    = &i18n.Message{ID: "Rule00018Params1", Other: "CHAR最大长度"}
	Rule00019Desc       = &i18n.Message{ID: "Rule00019Desc", Other: "不建议使用复合类型（SET和ENUM类型）数据"}
	Rule00019Annotation = &i18n.Message{ID: "Rule00019Annotation", Other: "SET类型，ENUM类型不是SQL标准，移植性较差；后期如修改或增加枚举值需重建整张表，代价较大；且无法通过字面值进行排序；在插入数据时，必须带上引号，否则将写入枚举值的顺序值，造成不可预期的问题"}
	Rule00019Message    = &i18n.Message{ID: "Rule00019Message", Other: "不建议使用复合类型（SET和ENUM类型）数据"}
	Rule00020Desc       = &i18n.Message{ID: "Rule00020Desc", Other: "避免表中包含有太多的列"}
	Rule00020Annotation = &i18n.Message{ID: "Rule00020Annotation", Other: "数据库表中字段过多会导致数据操作效率降低、数据完整性检查成本增加，以及索引维护与更新效率之间的权衡成本。对于追求事务响应和处理速度的OLTP系统，应尽量避免宽表设计，采用规范化数据模型以提升性能。"}
	Rule00020Message    = &i18n.Message{ID: "Rule00020Message", Other: "避免表中包含有太多的列"}
	Rule00020Params1    = &i18n.Message{ID: "Rule00020Params1", Other: "表内列数上限"}
	Rule00021Desc       = &i18n.Message{ID: "Rule00021Desc", Other: "禁止表字段缺少NOT NULL约束"}
	Rule00021Annotation = &i18n.Message{ID: "Rule00021Annotation", Other: "若数据库表字段缺少NOT NULL约束，则字段存储值可能是NULL，后期判断时，需要加上IS NULL判断，增加SQL编写的复杂度。"}
	Rule00021Message    = &i18n.Message{ID: "Rule00021Message", Other: "禁止表字段缺少NOT NULL约束"}
	Rule00022Desc       = &i18n.Message{ID: "Rule00022Desc", Other: "避免使用数据倾斜度高的索引字段"}
	Rule00022Annotation = &i18n.Message{ID: "Rule00022Annotation", Other: "为了提高查询效率，建议在执行SQL时优先使用倾斜度低的索引字段。倾斜度低的索引可以更快地定位数据，减少不必要的数据扫描，从而加速查询响应时间。规则检查将会计算候选索引字段的倾斜度，如果索引的倾斜度高于设定的阈值，则建议调整索引策略。"}
	Rule00022Message    = &i18n.Message{ID: "Rule00022Message", Other: "索引列 %v 超过倾斜度阈值 %v, 避免使用数据倾斜度高的索引字段"}
	Rule00022Params1    = &i18n.Message{ID: "Rule00022Params1", Other: "倾斜度"}
	Rule00023Desc       = &i18n.Message{ID: "Rule00023Desc", Other: "主键包含的列数不建议超过阈值"}
	Rule00023Annotation = &i18n.Message{ID: "Rule00023Annotation", Other: "主建中的列过多，会导致辅助索引占用更多的空间，同时增加索引维护的开销；具体规则阈值可根据业务需求调整，默认值：2"}
	Rule00023Message    = &i18n.Message{ID: "Rule00023Message", Other: "主键包含的列数不建议超过阈值. 阈值: %v"}
	Rule00023Params1    = &i18n.Message{ID: "Rule00023Params1", Other: "最大列数"}
	Rule00025Desc       = &i18n.Message{ID: "Rule00025Desc", Other: "建议时间类型的列添加默认值"}
	Rule00025Annotation = &i18n.Message{ID: "Rule00025Annotation", Other: "时间类型的字段添加默认值，可避免在数据写入未指定该字段值时，字段内容出现全为0的日期格式或者NULL值，与实际业务预期不符。"}
	Rule00025Message    = &i18n.Message{ID: "Rule00025Message", Other: "建议时间类型的列添加默认值. 不符合规定的字段: %v"}
	Rule00026Desc       = &i18n.Message{ID: "Rule00026Desc", Other: "整数字段建议指定最大显示宽度"}
	Rule00026Annotation = &i18n.Message{ID: "Rule00026Annotation", Other: "在表结构定义中，整数字段定义指定了最大显示宽度，可以体现业务对该字段的数据存储预期；同时保持了字段定义的一致性，减少在数据库之间迁移时需要修改字段长度的工作量。"}
	Rule00026Message    = &i18n.Message{ID: "Rule00026Message", Other: "整数字段建议指定最大显示宽度"}
	Rule00027Desc       = &i18n.Message{ID: "Rule00027Desc", Other: "列建议添加注释"}
	Rule00027Annotation = &i18n.Message{ID: "Rule00027Annotation", Other: "列添加注释能够使列的意义更明确，方便日后的维护"}
	Rule00027Message    = &i18n.Message{ID: "Rule00027Message", Other: "列建议添加注释. 不符合规定的字段: %v"}
	Rule00029Desc       = &i18n.Message{ID: "Rule00029Desc", Other: "禁止使用存储过程"}
	Rule00029Annotation = &i18n.Message{ID: "Rule00029Annotation", Other: "存储过程在一定程度上能使程序难以调试和拓展，各种数据库端的存储过程语法相差很大，给将来的数据移植带来很大的困难，且会极大的出现BUG的几率"}
	Rule00029Message    = &i18n.Message{ID: "Rule00029Message", Other: "禁止使用存储过程"}
	Rule00030Desc       = &i18n.Message{ID: "Rule00030Desc", Other: "禁止使用触发器"}
	Rule00030Annotation = &i18n.Message{ID: "Rule00030Annotation", Other: "触发器难以开发和维护，不能高效移植，且在复杂的逻辑以及高并发下，容易出现死锁影响业务。"}
	Rule00030Message    = &i18n.Message{ID: "Rule00030Message", Other: "禁止使用触发器"}
	Rule00031Desc       = &i18n.Message{ID: "Rule00031Desc", Other: "禁止使用视图"}
	Rule00031Annotation = &i18n.Message{ID: "Rule00031Annotation", Other: "视图的查询性能较差，同时基表结构变更，需要对视图进行维护。如果视图可读性差，且包含复杂的逻辑，会增加维护的成本。"}
	Rule00031Message    = &i18n.Message{ID: "Rule00031Message", Other: "禁止使用视图"}
	Rule00032Desc       = &i18n.Message{ID: "Rule00032Desc", Other: "数据库名称必须使用固定后缀结尾"}
	Rule00032Annotation = &i18n.Message{ID: "Rule00032Annotation", Other: "通过配置该规则可以规范指定业务的数据库命名规则，具体命名规范可以自定义设置。"}
	Rule00032Message    = &i18n.Message{ID: "Rule00032Message", Other: "数据库名称必须使用固定后缀结尾:%s"}
	Rule00032Params1    = &i18n.Message{ID: "Rule00032Params1", Other: "固定后缀"}
	Rule00033Desc       = &i18n.Message{ID: "Rule00033Desc", Other: "建表DDL必须包括更新时间字段，并应设置该字段为自动根据其他字段内容的变更进行更新。"}
	Rule00033Annotation = &i18n.Message{ID: "Rule00033Annotation", Other: "使用更新时间字段，有利于问题查找跟踪和检索数据，同时避免后期对数据生命周期管理不便，可保证时间的准确性"}
	Rule00033Message    = &i18n.Message{ID: "Rule00033Message", Other: "建表DDL必须包括更新时间字段，并应设置该字段为自动根据其他字段内容的变更进行更新。更新时间字段名: %v"}
	Rule00033Params1    = &i18n.Message{ID: "Rule00033Params1", Other: "更新时间字段名"}
	Rule00034Desc       = &i18n.Message{ID: "Rule00034Desc", Other: "字段约束为NOT NULL时必须带默认值"}
	Rule00034Annotation = &i18n.Message{ID: "Rule00034Annotation", Other: "如存在NOT NULL且不带默认值的字段，对字段进行写入时不包含该字段，会导致插入报错"}
	Rule00034Message    = &i18n.Message{ID: "Rule00034Message", Other: "字段约束为NOT NULL时必须带默认值"}
	Rule00035Desc       = &i18n.Message{ID: "Rule00035Desc", Other: "DDL语句中不建议使用中文全角引号"}
	Rule00035Annotation = &i18n.Message{ID: "Rule00035Annotation", Other: "建议开启此规则，可避免MySQL会将中文全角引号识别为命名的一部分，执行结果与业务预期不符"}
	Rule00035Message    = &i18n.Message{ID: "Rule00035Message", Other: "DDL语句中不建议使用中文全角引号"}
	Rule00037Desc       = &i18n.Message{ID: "Rule00037Desc", Other: "避免一张表内二级索引的个数过多"}
	Rule00037Annotation = &i18n.Message{ID: "Rule00037Annotation", Other: "在表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加维护索引处理上的开销（TPS），且太多与不充分、不正确的索引对性能都毫无益处。"}
	Rule00037Message    = &i18n.Message{ID: "Rule00037Message", Other: "避免一张表内二级索引的个数过多"}
	Rule00037Params1    = &i18n.Message{ID: "Rule00037Params1", Other: "二级索引个数"}
	Rule00039Desc       = &i18n.Message{ID: "Rule00039Desc", Other: "建议使用数据区分度高的索引字段"}
	Rule00039Annotation = &i18n.Message{ID: "Rule00039Annotation", Other: "为了提高查询效率，建议在执行SQL时优先使用区分度高的索引字段。区分度高的索引可以更快地定位数据，减少不必要的数据扫描，从而加速查询响应时间。规则检查将会计算候选索引字段的区分度，如果索引的区分度低于设定的阈值，则建议调整索引策略。"}
	Rule00039Message    = &i18n.Message{ID: "Rule00039Message", Other: "索引列 %v 未超过区分度阈值 %v, 建议使用数据区分度高的索引字段"}
	Rule00039Params1    = &i18n.Message{ID: "Rule00039Params1", Other: "区分度"}
	Rule00040Desc       = &i18n.Message{ID: "Rule00040Desc", Other: "普通索引必须使用固定前缀"}
	Rule00040Annotation = &i18n.Message{ID: "Rule00040Annotation", Other: "通过配置该规则可以规范指定业务的普通索引命名规则，具体命名规范可以自定义设置。"}
	Rule00040Message    = &i18n.Message{ID: "Rule00040Message", Other: "普通索引必须使用固定前缀"}
	Rule00040Params1    = &i18n.Message{ID: "Rule00040Params1", Other: "固定前缀"}
	Rule00041Desc       = &i18n.Message{ID: "Rule00041Desc", Other: "唯一索引必须使用固定前缀"}
	Rule00041Annotation = &i18n.Message{ID: "Rule00041Annotation", Other: "通过配置该规则可以规范指定业务的唯一索引命名规则，具体命名规范可以自定义设置。"}
	Rule00041Message    = &i18n.Message{ID: "Rule00041Message", Other: "唯一索引必须使用固定前缀"}
	Rule00041Params1    = &i18n.Message{ID: "Rule00041Params1", Other: "固定前缀"}
	Rule00042Desc       = &i18n.Message{ID: "Rule00042Desc", Other: "临时表必须使用固定前缀"}
	Rule00042Annotation = &i18n.Message{ID: "Rule00042Annotation", Other: "统一命名规范，有利于后期维护以及业务开发"}
	Rule00042Message    = &i18n.Message{ID: "Rule00042Message", Other: "临时表必须使用固定前缀"}
	Rule00042Params1    = &i18n.Message{ID: "Rule00042Params1", Other: "固定前缀"}
	Rule00043Desc       = &i18n.Message{ID: "Rule00043Desc", Other: "避免表内同一字段上存在过多索引"}
	Rule00043Annotation = &i18n.Message{ID: "Rule00043Annotation", Other: "一个表内同一字段上存在过多索引，一般情况下这些索引都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大；具体规则阈值可以根据业务需求调整，默认值：2"}
	Rule00043Message    = &i18n.Message{ID: "Rule00043Message", Other: "避免表内同一字段上存在过多索引. 字段 %v 上的索引数量不建议超过%v个"}
	Rule00043Params1    = &i18n.Message{ID: "Rule00043Params1", Other: "单字段的索引数最大值"}
	Rule00045Desc       = &i18n.Message{ID: "Rule00045Desc", Other: "避免在分页查询中使用过大偏移量"}
	Rule00045Annotation = &i18n.Message{ID: "Rule00045Annotation", Other: "在数据库中，分页查询通常使用 LIMIT 和 OFFSET 语句进行。当数据量较大时，使用大的偏移量（OFFSET）进行分页查询可能会导致性能下降，因为数据库需要跳过大量的行来获得所需的结果集。"}
	Rule00045Message    = &i18n.Message{ID: "Rule00045Message", Other: "避免在分页查询中使用过大偏移量, 最大偏移量:%v"}
	Rule00045Params1    = &i18n.Message{ID: "Rule00045Params1", Other: "最大偏移量"}
	Rule00046Desc       = &i18n.Message{ID: "Rule00046Desc", Other: "数据库对象命名不建议大小写字母混合"}
	Rule00046Annotation = &i18n.Message{ID: "Rule00046Annotation", Other: "数据库对象命名规范，不推荐采用大小写混用的形式建议词语之间使用下划线连接，提高代码可读性"}
	Rule00046Message    = &i18n.Message{ID: "Rule00046Message", Other: "数据库对象命名不建议大小写字母混合"}
	Rule00047Desc       = &i18n.Message{ID: "Rule00047Desc", Other: "数据库对象名称的字符个数不建议超过阈值"}
	Rule00047Annotation = &i18n.Message{ID: "Rule00047Annotation", Other: "通过配置该规则可以规范指定业务的对象命名长度，具体长度可以自定义设置。"}
	Rule00047Message    = &i18n.Message{ID: "Rule00047Message", Other: "数据库对象名称的字符个数不建议超过阈值:%v"}
	Rule00047Params1    = &i18n.Message{ID: "Rule00047Params1", Other: "字符个数"}
	Rule00048Desc       = &i18n.Message{ID: "Rule00048Desc", Other: "数据库对象命名只能使用英文、下划线或数字，首字母必须是英文"}
	Rule00048Annotation = &i18n.Message{ID: "Rule00048Annotation", Other: "遵循良好的命名约定和避免特殊字符的使用，可以提高代码的可读性、可维护性，并减少潜在的兼容性和语法问题。"}
	Rule00048Message    = &i18n.Message{ID: "Rule00048Message", Other: "数据库对象命名只能使用英文、下划线或数字，首字母必须是英文"}
	Rule00049Desc       = &i18n.Message{ID: "Rule00049Desc", Other: "数据库对象命名禁止使用保留字"}
	Rule00049Annotation = &i18n.Message{ID: "Rule00049Annotation", Other: "通过配置该规则可以规范指定业务的数据对象命名规则，避免发生冲突，以及混淆"}
	Rule00049Message    = &i18n.Message{ID: "Rule00049Message", Other: "数据库对象命名禁止使用保留字"}
	Rule00051Desc       = &i18n.Message{ID: "Rule00051Desc", Other: "禁止主键使用自增"}
	Rule00051Annotation = &i18n.Message{ID: "Rule00051Annotation", Other: "后期维护相对不便，过于依赖数据库自增机制达到全局唯一，不易拆分，容易造成主键冲突"}
	Rule00051Message    = &i18n.Message{ID: "Rule00051Message", Other: "禁止主键使用自增"}
	Rule00052Desc       = &i18n.Message{ID: "Rule00052Desc", Other: "建议主键使用自增"}
	Rule00052Annotation = &i18n.Message{ID: "Rule00052Annotation", Other: "自增主键通常为数字类型，其数据写入速度快，占用的存储空间小。自增主键保证了数据的有序性，减少了页分裂的频率，并简化了应用层的数据写入逻辑。"}
	Rule00052Message    = &i18n.Message{ID: "Rule00052Message", Other: "建议主键使用自增"}
	Rule00053Desc       = &i18n.Message{ID: "Rule00053Desc", Other: "不建议使用SELECT *"}
	Rule00053Annotation = &i18n.Message{ID: "Rule00053Annotation", Other: "当表结构变更时，使用*通配符选择所有列将导致查询行为会发生更改，与业务期望不符；同时SELECT * 中的无用字段会带来不必要的磁盘I/O，以及网络开销，且无法覆盖索引进而回表，大幅度降低查询效率。"}
	Rule00053Message    = &i18n.Message{ID: "Rule00053Message", Other: "不建议使用SELECT *"}
	Rule00054Desc       = &i18n.Message{ID: "Rule00054Desc", Other: "建议主键字段使用BIGINT时采用无符号的BIGINT"}
	Rule00054Annotation = &i18n.Message{ID: "Rule00054Annotation", Other: "在设计主键时若选择BIGINT时，使用无符号类型，相对于有符号类型，可以使数据库的索引性能更加优化，因为它减少了负值处理的开销，并能在某些情况下提高查询速度。特别是在系统设计初期可能无法完全预见到未来数据量的情况下，无符号数值类型（BIGINT UNSIGNED）可以有效避免因数据增长导致的溢出问题。"}
	Rule00054Message    = &i18n.Message{ID: "Rule00054Message", Other: "建议主键字段使用BIGINT时采用无符号的BIGINT"}
	Rule00055Desc       = &i18n.Message{ID: "Rule00055Desc", Other: "不建议创建冗余索引"}
	Rule00055Annotation = &i18n.Message{ID: "Rule00055Annotation", Other: "MySQL需要单独维护重复的索引，冗余索引增加维护成本，影响更新性能"}
	Rule00055Message    = &i18n.Message{ID: "Rule00055Message", Other: "在 %v 字段已存在 %v 索引，索引 %v 为冗余索引"}
	Rule00056Desc       = &i18n.Message{ID: "Rule00056Desc", Other: "表建议使用指定的字符集"}
	Rule00056Annotation = &i18n.Message{ID: "Rule00056Annotation", Other: "数据库内使用非标准的字符集，可能导致字符无法编码或者编码不全引起的乱码，最终出现应用写入数据失败或者查询结果显示乱码，影响数据库服务可用性。"}
	Rule00056Message    = &i18n.Message{ID: "Rule00056Message", Other: "表建议使用指定的字符集: %v"}
	Rule00056Params1    = &i18n.Message{ID: "Rule00056Params1", Other: "标准字符集"}
	Rule00057Desc       = &i18n.Message{ID: "Rule00057Desc", Other: "必须使用INNODB数据库引擎"}
	Rule00057Annotation = &i18n.Message{ID: "Rule00057Annotation", Other: "INNODB 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。"}
	Rule00057Message    = &i18n.Message{ID: "Rule00057Message", Other: "必须使用INNODB数据库引擎"}
	Rule00058Desc       = &i18n.Message{ID: "Rule00058Desc", Other: "避免使用分区表相关功能"}
	Rule00058Annotation = &i18n.Message{ID: "Rule00058Annotation", Other: "分区表在使用过程中存在诸多缺点，比如分区裁剪的不确定性、不支持全局分区索引、锁定粒度放大、分区前期规划较为繁杂等问题。如存在分区诉求，通常使用物理分表，即可避免分区表带来的缺点。"}
	Rule00058Message    = &i18n.Message{ID: "Rule00058Message", Other: "避免使用分区表相关功能"}
	Rule00059Desc       = &i18n.Message{ID: "Rule00059Desc", Other: "禁止修改大表的字段类型"}
	Rule00059Annotation = &i18n.Message{ID: "Rule00059Annotation", Other: "对于大型数据表，修改字段类型的DDL操作将导致显著的性能下降和可用性影响。此类操作通常需要复制整个表来更改数据类型，期间表将无法进行写操作，并且可能导致长时间的锁等待，对线上业务造成过长时间的影响。"}
	Rule00059Message    = &i18n.Message{ID: "Rule00059Message", Other: "禁止修改大表的字段类型，表大小阈值: %v GB"}
	Rule00059Params1    = &i18n.Message{ID: "Rule00059Params1", Other: "表大小(GB)"}
	Rule00060Desc       = &i18n.Message{ID: "Rule00060Desc", Other: "表建议添加注释"}
	Rule00060Annotation = &i18n.Message{ID: "Rule00060Annotation", Other: "表添加注释能够使表的意义更明确，方便日后的维护"}
	Rule00060Message    = &i18n.Message{ID: "Rule00060Message", Other: "表建议添加注释"}
	Rule00061Desc       = &i18n.Message{ID: "Rule00061Desc", Other: "建议新建表句子中包含表存在判断操作"}
	Rule00061Annotation = &i18n.Message{ID: "Rule00061Annotation", Other: "新建表如果已经存在，不加 IF NOT EXISTS 会报错。新建表只在表不存在的前提下进行，避免SQL 实际执行报错。"}
	Rule00061Message    = &i18n.Message{ID: "Rule00061Message", Other: "建议新建表句子中包含表存在判断操作"}
	Rule00062Desc       = &i18n.Message{ID: "Rule00062Desc", Other: "建议事务隔离级别设置成RC"}
	Rule00062Annotation = &i18n.Message{ID: "Rule00062Annotation", Other: "RC 虽然没有解决幻读的问题，但是没有间隙锁，从而每次在做更新操作时影响的行数比默认RR要小很多；默认的RR隔离级别虽然解决了幻读问题，但是增加了间隙锁，导致加锁的范围扩大，性能比RC要低，增加死锁的概率；在大多数情况下，出现幻读的几率较小，所以建议使用RC。"}
	Rule00062Message    = &i18n.Message{ID: "Rule00062Message", Other: "建议事务隔离级别设置成RC"}
	Rule00063Desc       = &i18n.Message{ID: "Rule00063Desc", Other: "唯一索引名必须遵循指定格式"}
	Rule00063Annotation = &i18n.Message{ID: "Rule00063Annotation", Other: "通过配置该规则可以规范指定业务的唯一索引命名规则，如索引字段存在多个，则可以拼接字段名，不要超过索引名长度即可。"}
	Rule00063Message    = &i18n.Message{ID: "Rule00063Message", Other: "唯一索引名必须遵循指定格式"}
	Rule00063Params1    = &i18n.Message{ID: "Rule00063Params1", Other: "索引命名格式"}
	Rule00064Desc       = &i18n.Message{ID: "Rule00064Desc", Other: "不建议索引字段是VARCHAR类型时其长度大于阈值"}
	Rule00064Annotation = &i18n.Message{ID: "Rule00064Annotation", Other: "建立索引时没有限制索引的大小，索引长度会根据该字段实际存储的值来计算，VARCHAR 定义的长度越长，导致业务写入的内容越多，则建立的索引其存储大小将会越大。"}
	Rule00064Message    = &i18n.Message{ID: "Rule00064Message", Other: "不建议索引字段是VARCHAR类型时其长度大于阈值. 不符合规则的字段: %v"}
	Rule00064Params1    = &i18n.Message{ID: "Rule00064Params1", Other: "VARCHAR最大长度"}
	Rule00065Desc       = &i18n.Message{ID: "Rule00065Desc", Other: "禁止修改表时指定或调整字段在表结构中的顺序"}
	Rule00065Annotation = &i18n.Message{ID: "Rule00065Annotation", Other: "FIRST 和 AFTER 关键词在 ALTER TABLE 语句中用于调整字段的顺序，这种操作会改变表字段的物理顺序，可能导致依赖默认列顺序的业务SQL出现错误，影响数据的一致性和业务的稳定性。"}
	Rule00065Message    = &i18n.Message{ID: "Rule00065Message", Other: "禁止修改表时指定或调整字段在表结构中的顺序"}
	Rule00066Desc       = &i18n.Message{ID: "Rule00066Desc", Other: "禁止除索引外的DROP 操作"}
	Rule00066Annotation = &i18n.Message{ID: "Rule00066Annotation", Other: "DROP 操作是数据定义语言（DDL）的一部分，一旦执行，将导致无法恢复的数据或结构丢失。在不恰当的情况下执行DROP操作可能导致数据丢失、系统功能缺失甚至业务中断。"}
	Rule00066Message    = &i18n.Message{ID: "Rule00066Message", Other: "禁止除索引外的DROP 操作"}
	Rule00067Desc       = &i18n.Message{ID: "Rule00067Desc", Other: "表不建议使用外键"}
	Rule00067Annotation = &i18n.Message{ID: "Rule00067Annotation", Other: "外键在大量写入场景下性能较差，强烈禁止使用"}
	Rule00067Message    = &i18n.Message{ID: "Rule00067Message", Other: "表不建议使用外键"}
	Rule00068Desc       = &i18n.Message{ID: "Rule00068Desc", Other: "禁止使用TIMESTAMP字段"}
	Rule00068Annotation = &i18n.Message{ID: "Rule00068Annotation", Other: "TIMESTAMP类型字段受制于2038年问题，其时间范围仅限于1970-01-01 00:00:01 UTC至2038-01-19 03:14:07 UTC。超过这个时间范围，TIMESTAMP将无法存储更晚的时间点，导致应用报错。此外，TIMESTAMP字段在存储时会根据数据库服务器的时区进行转换，这可能导致跨时区应用中的时间不一致问题。"}
	Rule00068Message    = &i18n.Message{ID: "Rule00068Message", Other: "禁止使用TIMESTAMP字段"}
	Rule00071Desc       = &i18n.Message{ID: "Rule00071Desc", Other: "禁止进行删除列的操作"}
	Rule00071Annotation = &i18n.Message{ID: "Rule00071Annotation", Other: "在业务系统中，表的列往往与多个业务流程紧密关联。删除表中的列可能导致与该列相关的数据访问、数据处理和数据表示逻辑出现故障，因为相关的SQL语句、应用程序代码或报告工具可能还在尝试访问已删除的列。"}
	Rule00071Message    = &i18n.Message{ID: "Rule00071Message", Other: "禁止进行删除列的操作"}
	Rule00072Desc       = &i18n.Message{ID: "Rule00072Desc", Other: "禁止删除外键"}
	Rule00072Annotation = &i18n.Message{ID: "Rule00072Annotation", Other: "外键的存在是为了维持数据之间的引用完整性，确保数据的一致性。删除外键，可能导致依赖于这些外键约束的业务逻辑出现故障或数据完整性问题。"}
	Rule00072Message    = &i18n.Message{ID: "Rule00072Message", Other: "禁止删除外键"}
	Rule00073Desc       = &i18n.Message{ID: "Rule00073Desc", Other: "不建议修改表的默认字符集"}
	Rule00073Annotation = &i18n.Message{ID: "Rule00073Annotation", Other: "修改表的默认字符集，只会影响后续新增的字段，不会修改表已有字段的字符集，最终可能会出现表与字段的字符集不一致，引发数据查询出现乱码以及索引失效情况。"}
	Rule00073Message    = &i18n.Message{ID: "Rule00073Message", Other: "不建议修改表的默认字符集"}
	Rule00074Desc       = &i18n.Message{ID: "Rule00074Desc", Other: "禁止对表名字或段名进行重命名"}
	Rule00074Annotation = &i18n.Message{ID: "Rule00074Annotation", Other: "对表名或列名进行重命名操作会直接影响线上业务的稳定性和连续性。这种操作可能引起与表或列相关的SQL语句执行失败，导致业务中断。"}
	Rule00074Message    = &i18n.Message{ID: "Rule00074Message", Other: "禁止对表名字或段名进行重命名"}
	Rule00075Desc       = &i18n.Message{ID: "Rule00075Desc", Other: "建议列与表使用同一个字符集"}
	Rule00075Annotation = &i18n.Message{ID: "Rule00075Annotation", Other: "统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效"}
	Rule00075Message    = &i18n.Message{ID: "Rule00075Message", Other: "建议列与表使用同一个字符集. 不符合规则的字段: %v"}
	Rule00076Desc       = &i18n.Message{ID: "Rule00076Desc", Other: "UPDATE/DELETE操作影响行数不建议超过阈值"}
	Rule00076Annotation = &i18n.Message{ID: "Rule00076Annotation", Other: "在数据库中，进行修改或删除等数据变更操作时，一次性操作的数据量过大，会消耗大量的系统资源，产生长事务，会导致查询性能下降，影响其他事务或查询的执行。"}
	Rule00076Message    = &i18n.Message{ID: "Rule00076Message", Other: "UPDATE/DELETE操作影响行数不建议超过阈值"}
	Rule00076Params1    = &i18n.Message{ID: "Rule00076Params1", Other: "影响行数上限"}
	Rule00078Desc       = &i18n.Message{ID: "Rule00078Desc", Other: "禁止使用聚合函数"}
	Rule00078Annotation = &i18n.Message{ID: "Rule00078Annotation", Other: "禁止使用SQL聚合函数是为了确保查询的简单性、高性能和数据一致性。"}
	Rule00078Message    = &i18n.Message{ID: "Rule00078Message", Other: "禁止使用聚合函数"}
	Rule00079Desc       = &i18n.Message{ID: "Rule00079Desc", Other: "别名不建议与表或列的名字相同"}
	Rule00079Annotation = &i18n.Message{ID: "Rule00079Annotation", Other: "表或列的别名与其真实名称相同, 这样的别名会使得查询更难去分辨"}
	Rule00079Message    = &i18n.Message{ID: "Rule00079Message", Other: "别名不建议与表或列的名字相同"}
	Rule00080Desc       = &i18n.Message{ID: "Rule00080Desc", Other: "建议单条SQL写入数据的行数不超过阈值"}
	Rule00080Annotation = &i18n.Message{ID: "Rule00080Annotation", Other: "为了避免单个SQL语句在批量写入时对数据库性能造成过大压力，限制每条SQL语句一次性插入的数据行数不得超过指定行。这有助于提高事务的可管理性，减少锁冲突，优化日志处理，以及提升错误恢复速度。"}
	Rule00080Message    = &i18n.Message{ID: "Rule00080Message", Other: "建议单条SQL写入数据的行数不超过阈值"}
	Rule00080Params1    = &i18n.Message{ID: "Rule00080Params1", Other: "单条SQL写入行数上限"}
	Rule00082Desc       = &i18n.Message{ID: "Rule00082Desc", Other: "禁止使用文件排序"}
	Rule00082Annotation = &i18n.Message{ID: "Rule00082Annotation", Other: "大数据量的情况下，文件排序意味着SQL性能较低，会增加OS的开销，影响数据库性能。"}
	Rule00082Message    = &i18n.Message{ID: "Rule00082Message", Other: "禁止使用文件排序"}
	Rule00083Desc       = &i18n.Message{ID: "Rule00083Desc", Other: "不建议对表进行索引跳跃扫描"}
	Rule00083Annotation = &i18n.Message{ID: "Rule00083Annotation", Other: "索引扫描是跳跃扫描，未遵循最左匹配原则，可能降低索引的使用效率，影响查询性能，尽量避免使用。"}
	Rule00083Message    = &i18n.Message{ID: "Rule00083Message", Other: "不建议对表进行索引跳跃扫描"}
	Rule00084Desc       = &i18n.Message{ID: "Rule00084Desc", Other: "不建议使用临时表"}
	Rule00084Annotation = &i18n.Message{ID: "Rule00084Annotation", Other: "大数据量的情况下，临时表意味着SQL性能较低，会增加OS的开销，影响数据库性能"}
	Rule00084Message    = &i18n.Message{ID: "Rule00084Message", Other: "不建议使用临时表"}
	Rule00085Desc       = &i18n.Message{ID: "Rule00085Desc", Other: "不建议对表进行全索引扫描"}
	Rule00085Annotation = &i18n.Message{ID: "Rule00085Annotation", Other: "在数据量大的情况下索引全扫描严重影响SQL性能；一次性大数据量获取的场景较少，业务层需要考虑当前SQL的合理性，是否缺少过滤条件以及限制条数。"}
	Rule00085Message    = &i18n.Message{ID: "Rule00085Message", Other: "不建议对表进行全索引扫描"}
	Rule00086Desc       = &i18n.Message{ID: "Rule00086Desc", Other: "禁止使用子字符串匹配或后缀匹配搜索"}
	Rule00086Annotation = &i18n.Message{ID: "Rule00086Annotation", Other: "使用子字符串匹配搜索或后缀匹配搜索将导致查询无法使用索引，导致全表扫描"}
	Rule00086Message    = &i18n.Message{ID: "Rule00086Message", Other: "禁止使用子字符串匹配或后缀匹配搜索"}
	Rule00087Desc       = &i18n.Message{ID: "Rule00087Desc", Other: "避免WHERE条件内IN语句中的参数值个数过多"}
	Rule00087Annotation = &i18n.Message{ID: "Rule00087Annotation", Other: "当IN值过多时，有可能会出现无法使用索引，导致查询走全表扫描、性能变差、资源消耗过多等问题。"}
	Rule00087Message    = &i18n.Message{ID: "Rule00087Message", Other: "避免WHERE条件内IN语句中的参数值个数过多"}
	Rule00087Params1    = &i18n.Message{ID: "Rule00087Params1", Other: "IN的参数值个数"}
	Rule00088Desc       = &i18n.Message{ID: "Rule00088Desc", Other: "INSERT 语句必须指定COLUMN"}
	Rule00088Annotation = &i18n.Message{ID: "Rule00088Annotation", Other: "当表结构发生变更，INSERT请求不明确指定列名，会发生插入数据不匹配的情况；建议开启此规则，避免插入结果与业务预期不符"}
	Rule00088Message    = &i18n.Message{ID: "Rule00088Message", Other: "INSERT 语句必须指定COLUMN"}
	Rule00089Desc       = &i18n.Message{ID: "Rule00089Desc", Other: "禁止INSERT ... SELECT"}
	Rule00089Annotation = &i18n.Message{ID: "Rule00089Annotation", Other: "使用 INSERT ... SELECT 在默认事务隔离级别下，可能会导致对查询的表施加表级锁"}
	Rule00089Message    = &i18n.Message{ID: "Rule00089Message", Other: "禁止INSERT ... SELECT"}
	Rule00090Desc       = &i18n.Message{ID: "Rule00090Desc", Other: "建议使用UNION ALL替代UNION"}
	Rule00090Annotation = &i18n.Message{ID: "Rule00090Annotation", Other: "union会对结果集进行去重，union all只是简单的将两个结果合并后就返回，从效率上看，union all 要比union快很多；如果合并的两个结果集中允许包含重复数据的话，建议开启此规则，使用union all替代union"}
	Rule00090Message    = &i18n.Message{ID: "Rule00090Message", Other: "建议使用UNION ALL替代UNION"}
	Rule00091Desc       = &i18n.Message{ID: "Rule00091Desc", Other: "建议表连接时有连接条件"}
	Rule00091Annotation = &i18n.Message{ID: "Rule00091Annotation", Other: "为了确保连接操作的正确性和可靠性，应该始终指定连接条件，定义正确的关联关系。缺少连接条件，可能导致连接操作失败，最终数据库会使用笛卡尔积的方式进行处理，产生不正确的连接结果，并导致性能问题，消耗大量的CPU和内存资源。"}
	Rule00091Message    = &i18n.Message{ID: "Rule00091Message", Other: "建议表连接时有连接条件"}
	Rule00092Desc       = &i18n.Message{ID: "Rule00092Desc", Other: "建议DELETE/UPDATE语句使用LIMIT子句控制影响行数"}
	Rule00092Annotation = &i18n.Message{ID: "Rule00092Annotation", Other: "在进行DELETE和UPDATE操作时，通过添加LIMIT子句可以明确限制操作影响的数据行数。这样做有助于减少由于执行错误而导致的数据损失风险，并可以有效地控制长事务的执行时间，降低对数据库性能的影响。"}
	Rule00092Message    = &i18n.Message{ID: "Rule00092Message", Other: "建议DELETE/UPDATE语句使用LIMIT子句控制影响行数"}
	Rule00094Desc       = &i18n.Message{ID: "Rule00094Desc", Other: "避免使用不必要的内置函数"}
	Rule00094Annotation = &i18n.Message{ID: "Rule00094Annotation", Other: "通过配置该规则可以指定业务中需要禁止使用的内置函数，使用内置函数可能会导致SQL无法走索引或者产生一些非预期的结果。实际需要禁用的函数可通过规则设置。"}
	Rule00094Message    = &i18n.Message{ID: "Rule00094Message", Other: "避免使用不必要的内置函数：%v"}
	Rule00094Params1    = &i18n.Message{ID: "Rule00094Params1", Other: "函数名"}
	Rule00095Desc       = &i18n.Message{ID: "Rule00095Desc", Other: "建议使用'<>'代替'!='"}
	Rule00095Annotation = &i18n.Message{ID: "Rule00095Annotation", Other: "'<>' 是ANSI SQL标准中定义的不等于运算符。如果使用了!=运算符，数据库优化器会自动转换为SQL标准不等于运算符，增加了优化器的转换开销；另外，目前并非所有的SQL数据库系统都支持 !=，使用标准的运算符可以确保SQL在各数据库之间具有更高的兼容性。"}
	Rule00095Message    = &i18n.Message{ID: "Rule00095Message", Other: "建议使用'<>'代替'!='"}
	Rule00096Desc       = &i18n.Message{ID: "Rule00096Desc", Other: "不建议参与连接操作的表数量过多"}
	Rule00096Annotation = &i18n.Message{ID: "Rule00096Annotation", Other: "表关联越多，意味着各种驱动关系组合就越多，比较各种结果集的执行成本的代价也就越高，进而SQL查询性能会大幅度下降。"}
	Rule00096Message    = &i18n.Message{ID: "Rule00096Message", Other: "不建议参与连接操作的表数量过多"}
	Rule00096Params1    = &i18n.Message{ID: "Rule00096Params1", Other: "参与表连接的表个数"}
	Rule00097Desc       = &i18n.Message{ID: "Rule00097Desc", Other: "禁止对长字段排序"}
	Rule00097Annotation = &i18n.Message{ID: "Rule00097Annotation", Other: "在MySQL数据库中，对长字段（如VARCHAR(2000)、TEXT、BLOB等）进行排序操作（包括但不限于ORDER BY、DISTINCT、GROUP BY、UNION等）是不推荐的实践。这类操作会导致排序缓冲区（sort_buffer_size）溢出，引发性能下降和资源浪费。此外，由于长字段排序可能导致临时表（使用Temptable引擎）溢出到磁盘，这不仅会严重影响查询性能，还可能导致系统稳定性和响应能力的降低。"}
	Rule00097Message    = &i18n.Message{ID: "Rule00097Message", Other: "禁止对长字段排序"}
	Rule00097Params1    = &i18n.Message{ID: "Rule00097Params1", Other: "排序字段的最大长度"}
	Rule00098Desc       = &i18n.Message{ID: "Rule00098Desc", Other: "避免对同一张表进行多次连接或查询。"}
	Rule00098Annotation = &i18n.Message{ID: "Rule00098Annotation", Other: "在设计SQL语句时，应避免对同一张表进行多次连接或查询。这种做法可能导致查询性能显著下降，因为它会增加数据库的I/O操作，CPU处理以及内存使用，从而影响整体查询效率。"}
	Rule00098Message    = &i18n.Message{ID: "Rule00098Message", Other: "避免对同一张表进行多次连接或查询。违反规则的表名: %s"}
	Rule00098Params1    = &i18n.Message{ID: "Rule00098Params1", Other: "max_table_join_count"}
	Rule00099Desc       = &i18n.Message{ID: "Rule00099Desc", Other: "不建议在SELECT语句中存在FOR UPDATE操作"}
	Rule00099Annotation = &i18n.Message{ID: "Rule00099Annotation", Other: "SELECT FOR UPDATE 会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞，在高并发下，容易造成数据库大量锁等待，影响数据库查询性能"}
	Rule00099Message    = &i18n.Message{ID: "Rule00099Message", Other: "不建议在SELECT语句中存在FOR UPDATE操作"}
	Rule00100Desc       = &i18n.Message{ID: "Rule00100Desc", Other: "避免SELECT语句一次性返回的结果过多"}
	Rule00100Annotation = &i18n.Message{ID: "Rule00100Annotation", Other: "如果查询的扫描行数很大，会导致IO、网络资源消耗过大，并且可能会导致优化器选择错误的执行计划而不走索引。"}
	Rule00100Message    = &i18n.Message{ID: "Rule00100Message", Other: "避免SELECT语句一次性返回的结果过多"}
	Rule00100Params1    = &i18n.Message{ID: "Rule00100Params1", Other: "结果集返回行数"}
	Rule00101Desc       = &i18n.Message{ID: "Rule00101Desc", Other: "不建议针对大表执行SELECT 语句时存在ORDER BY操作"}
	Rule00101Annotation = &i18n.Message{ID: "Rule00101Annotation", Other: "在大表的情况下，数据查询中的ORDER BY 操作对查询性能影响较大，建议将排序部分放到业务处理或者限定查询数据的范围。"}
	Rule00101Message    = &i18n.Message{ID: "Rule00101Message", Other: "不建议针对大表执行SELECT 语句时存在ORDER BY操作"}
	Rule00102Desc       = &i18n.Message{ID: "Rule00102Desc", Other: "禁止UPDATE/DELETE语句使用ORDER BY操作 "}
	Rule00102Annotation = &i18n.Message{ID: "Rule00102Annotation", Other: "使用ORDER BY子句的UPDATE或DELETE语句会导致不必要的性能开销，影响数据库响应时间，并可能导致锁竞争，从而影响到系统的整体性能和稳定性。"}
	Rule00102Message    = &i18n.Message{ID: "Rule00102Message", Other: "禁止UPDATE/DELETE语句使用ORDER BY操作 "}
	Rule00107Desc       = &i18n.Message{ID: "Rule00107Desc", Other: "建议将过长的SQL分解成几个简单的SQL"}
	Rule00107Annotation = &i18n.Message{ID: "Rule00107Annotation", Other: "过长的SQL可读性较差，难以维护，且容易引发性能问题。"}
	Rule00107Message    = &i18n.Message{ID: "Rule00107Message", Other: "建议将过长的SQL分解成几个简单的SQL"}
	Rule00107Params1    = &i18n.Message{ID: "Rule00107Params1", Other: "句子长度限制"}
	Rule00108Desc       = &i18n.Message{ID: "Rule00108Desc", Other: "避免子查询嵌套层数过多"}
	Rule00108Annotation = &i18n.Message{ID: "Rule00108Annotation", Other: "子查询嵌套层数超过阈值，有些情况下，子查询并不能使用到索引。同时对于返回结果集比较大的子查询，会产生大量的临时表，消耗过多的CPU和IO资源，产生大量的慢查询"}
	Rule00108Message    = &i18n.Message{ID: "Rule00108Message", Other: "避免子查询嵌套层数过多"}
	Rule00108Params1    = &i18n.Message{ID: "Rule00108Params1", Other: "子查询嵌套层数"}
	Rule00109Desc       = &i18n.Message{ID: "Rule00109Desc", Other: "禁止在子查询中使用LIMIT"}
	Rule00109Annotation = &i18n.Message{ID: "Rule00109Annotation", Other: "不支持在子查询中进行'LIMIT & IN/ALL/ANY/SOME'，数据库会执行报错。"}
	Rule00109Message    = &i18n.Message{ID: "Rule00109Message", Other: "禁止在子查询中使用LIMIT"}
	Rule00110Desc       = &i18n.Message{ID: "Rule00110Desc", Other: "建议为SQL查询条件建立索引"}
	Rule00110Annotation = &i18n.Message{ID: "Rule00110Annotation", Other: "为SQL查询条件建立索引可以显著提高查询性能，减少I/O操作，并提高查询效率。特别是在处理大数据量的表时，索引可以大幅度缩短查询时间，优化数据库性能。"}
	Rule00110Message    = &i18n.Message{ID: "Rule00110Message", Other: "建议为SQL查询条件建立索引. 不符合条件的字段有: %v"}
	Rule00111Desc       = &i18n.Message{ID: "Rule00111Desc", Other: "避免对条件字段使用表达式操作"}
	Rule00111Annotation = &i18n.Message{ID: "Rule00111Annotation", Other: "对条件字段做表达式操作，可能会破坏索引值的有序性，导致优化器选择放弃走索引，使查询性能大幅度降低"}
	Rule00111Message    = &i18n.Message{ID: "Rule00111Message", Other: "避免对条件字段使用表达式操作"}
	Rule00112Desc       = &i18n.Message{ID: "Rule00112Desc", Other: "禁止WHERE子句中条件字段与值的数据类型不一致"}
	Rule00112Annotation = &i18n.Message{ID: "Rule00112Annotation", Other: "WHERE子句中条件字段与值数据类型不一致会引发隐式数据类型转换，导致优化器选择错误的执行计划，在高并发、大数据量的情况下，不走索引会使得数据库的查询性能严重下降"}
	Rule00112Message    = &i18n.Message{ID: "Rule00112Message", Other: "禁止WHERE子句中条件字段与值的数据类型不一致"}
	Rule00113Desc       = &i18n.Message{ID: "Rule00113Desc", Other: "不建议对条件字段使用负向查询"}
	Rule00113Annotation = &i18n.Message{ID: "Rule00113Annotation", Other: "SQL查询条件中存在NOT、NOT IN、NOT LIKE、NOT EXISTS、不等于等负向查询条件，将导致优化器选择错误的执行计划，导致出现慢SQL。"}
	Rule00113Message    = &i18n.Message{ID: "Rule00113Message", Other: "不建议对条件字段使用负向查询"}
	Rule00115Desc       = &i18n.Message{ID: "Rule00115Desc", Other: "避免使用标量子查询"}
	Rule00115Annotation = &i18n.Message{ID: "Rule00115Annotation", Other: "标量子查询存在多次访问同一张表的问题，执行开销大效率低，可使用JOIN操作或者关联子查询结果集的方式替代标量子查询。"}
	Rule00115Message    = &i18n.Message{ID: "Rule00115Message", Other: "避免使用标量子查询"}
	Rule00118Desc       = &i18n.Message{ID: "Rule00118Desc", Other: "建议在执行DROP/TRUNCATE等操作前进行备份"}
	Rule00118Annotation = &i18n.Message{ID: "Rule00118Annotation", Other: "DROP/TRUNCATE是DDL，操作立即生效，不会写入日志，所以无法回滚，在执行高危操作之前对数据进行备份是很有必要的"}
	Rule00118Message    = &i18n.Message{ID: "Rule00118Message", Other: "建议在执行DROP/TRUNCATE等操作前进行备份"}
	Rule00119Desc       = &i18n.Message{ID: "Rule00119Desc", Other: "建议为GROUP BY语句添加ORDER BY条件"}
	Rule00119Annotation = &i18n.Message{ID: "Rule00119Annotation", Other: "GROUP BY 语句不加ORDER BY，结果将无序或者非预期的排序。建议加上ORDER BY 条件，按照一定的顺序来展示查询结果。"}
	Rule00119Message    = &i18n.Message{ID: "Rule00119Message", Other: "建议为GROUP BY语句添加ORDER BY条件"}
	Rule00120Desc       = &i18n.Message{ID: "Rule00120Desc", Other: "避免使用 IN (NULL) 或者 NOT IN (NULL)"}
	Rule00120Annotation = &i18n.Message{ID: "Rule00120Annotation", Other: "使用 `IN(NULL)` 或 `NOT IN(NULL)` 会导致查询条件永远为假，从而使得查询无法返回任何结果。这不仅影响查询逻辑和结果的准确性，还可能导致性能问题和不必要的资源消耗。"}
	Rule00120Message    = &i18n.Message{ID: "Rule00120Message", Other: "避免使用 IN (NULL) 或者 NOT IN (NULL)"}
	Rule00121Desc       = &i18n.Message{ID: "Rule00121Desc", Other: "建议在限定记录数的查询语句中使用ORDER BY"}
	Rule00121Annotation = &i18n.Message{ID: "Rule00121Annotation", Other: "在限定记录的查询语句中，如果没有ORDER BY子句，每次查询的结果可能会受数据更新影响而出现非确定性的结，最终与业务需求不符。"}
	Rule00121Message    = &i18n.Message{ID: "Rule00121Message", Other: "建议在限定记录数的查询语句中使用ORDER BY"}
	Rule00122Desc       = &i18n.Message{ID: "Rule00122Desc", Other: "避免对值全为NULL的列直接使用 SUM或COUNT函数"}
	Rule00122Annotation = &i18n.Message{ID: "Rule00122Annotation", Other: "当某一列的值全是NULL时，COUNT(COL)的返回结果为0，但SUM(COL)的返回结果为NULL，因此使用SUM()时需注意NPE问题（指数据返回NULL）；如业务需避免NPE问题，建议开启此规则"}
	Rule00122Message    = &i18n.Message{ID: "Rule00122Message", Other: "避免对值全为NULL的列直接使用 SUM或COUNT函数. 违反规则的列名: %s"}
	Rule00123Desc       = &i18n.Message{ID: "Rule00123Desc", Other: "禁止使用TRUNCATE操作"}
	Rule00123Annotation = &i18n.Message{ID: "Rule00123Annotation", Other: "TRUNCATE是DDL，可以快速清理全表数据，回收磁盘空间，执行后数据默认隐式提交，无法回滚，在没有备份的场景下，谨慎使用TRUNCATE"}
	Rule00123Message    = &i18n.Message{ID: "Rule00123Message", Other: "禁止使用TRUNCATE操作"}
	Rule00124Desc       = &i18n.Message{ID: "Rule00124Desc", Other: "删除全表时建议使用 TRUNCATE 替代 DELETE"}
	Rule00124Annotation = &i18n.Message{ID: "Rule00124Annotation", Other: "TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，同时TRUNCATE后表所占用的空间会被释放，而DELETE后需要手工执行OPTIMIZE才能释放表空间"}
	Rule00124Message    = &i18n.Message{ID: "Rule00124Message", Other: "删除全表时建议使用 TRUNCATE 替代 DELETE"}
	Rule00126Desc       = &i18n.Message{ID: "Rule00126Desc", Other: "不建议对字段编号进行 GROUP BY"}
	Rule00126Annotation = &i18n.Message{ID: "Rule00126Annotation", Other: "GROUP BY 1 表示按第一列进行GROUP BY；在GROUP BY子句中使用字段编号，而不是表达式或列名称，当查询列顺序改变时，会导致查询逻辑出现问题"}
	Rule00126Message    = &i18n.Message{ID: "Rule00126Message", Other: "不建议对字段编号进行 GROUP BY"}
	Rule00127Desc       = &i18n.Message{ID: "Rule00127Desc", Other: "不建议在ORDER BY中使用表达式或函数"}
	Rule00127Annotation = &i18n.Message{ID: "Rule00127Annotation", Other: "在ORDER BY子句中使用表达式或函数会导致无法有效利用索引，从而可能涉及到全表扫描和使用临时表进行数据排序。这样的操作在处理大数据量时会显著降低查询性能。"}
	Rule00127Message    = &i18n.Message{ID: "Rule00127Message", Other: "不建议在ORDER BY中使用表达式或函数"}
	Rule00128Desc       = &i18n.Message{ID: "Rule00128Desc", Other: "不建议使用 HAVING 子句"}
	Rule00128Annotation = &i18n.Message{ID: "Rule00128Annotation", Other: "对于索引字段，放在HAVING子句中时不会走索引；建议将HAVING子句改写为WHERE中的查询条件，可以在查询处理期间使用索引，提高SQL的执行效率"}
	Rule00128Message    = &i18n.Message{ID: "Rule00128Message", Other: "不建议使用 HAVING 子句"}
	Rule00131Desc       = &i18n.Message{ID: "Rule00131Desc", Other: "避免使用 ORDER BY RAND() 进行随机排序"}
	Rule00131Annotation = &i18n.Message{ID: "Rule00131Annotation", Other: "使用 ORDER BY RAND() 会导致数据库生成临时表并进行完整的表扫描和排序，这在处理大数据量时会显著增加查询时间和服务器负载。建议采用更高效的随机数据检索方法，如利用主键或其他索引实现快速随机访问。"}
	Rule00131Message    = &i18n.Message{ID: "Rule00131Message", Other: "避免使用 ORDER BY RAND() 进行随机排序"}
	Rule00132Desc       = &i18n.Message{ID: "Rule00132Desc", Other: "不推荐使用子查询"}
	Rule00132Annotation = &i18n.Message{ID: "Rule00132Annotation", Other: "有些情况下，子查询并不能使用到索引，同时对于返回结果集比较大的子查询，会产生大量的临时表，消耗过多的CPU和IO资源，产生大量的慢查询"}
	Rule00132Message    = &i18n.Message{ID: "Rule00132Message", Other: "不推荐使用子查询"}
	Rule00134Desc       = &i18n.Message{ID: "Rule00134Desc", Other: "避免对主键值进行修改"}
	Rule00134Annotation = &i18n.Message{ID: "Rule00134Annotation", Other: "主键在大多数数据库系统中用于定义数据的唯一性，并且常常与数据的物理存储结构密切相关。更新主键会导致底层存储结构（如聚簇索引）的重大重新组织，引发性能下降。此外，主键的更改可能影响数据一致性，尤其在涉及复杂事务处理和高并发操作的场景中。"}
	Rule00134Message    = &i18n.Message{ID: "Rule00134Message", Other: "避免对主键值进行修改"}
	Rule00139Desc       = &i18n.Message{ID: "Rule00139Desc", Other: "不建议使用全表扫描"}
	Rule00139Annotation = &i18n.Message{ID: "Rule00139Annotation", Other: "全表扫描是数据库执行查询时读取表中每一行来查找匹配记录的过程。对于大型表来说，出现全表扫描的SQL会导致显著的性能下降和资源消耗，影响业务稳定运行。"}
	Rule00139Message    = &i18n.Message{ID: "Rule00139Message", Other: "不建议使用全表扫描. 表大小阈值: %v GB"}
	Rule00139Params1    = &i18n.Message{ID: "Rule00139Params1", Other: "表大小(GB)"}
	Rule00140Desc       = &i18n.Message{ID: "Rule00140Desc", Other: "建议对表、视图等对象进行操作时指定库名"}
	Rule00140Annotation = &i18n.Message{ID: "Rule00140Annotation", Other: "对表、视图等对象进行创建、修改、查询、更新、删除等DDL、DML操作时，如未指定schema或者库名，会导致在不确定的数据库下执行，与实际业务预期不符合，而且会导致SQL语句执行错误。"}
	Rule00140Message    = &i18n.Message{ID: "Rule00140Message", Other: "建议对表、视图等对象进行操作时指定库名"}
	Rule00141Desc       = &i18n.Message{ID: "Rule00141Desc", Other: "表关联嵌套循环的层次过多"}
	Rule00141Annotation = &i18n.Message{ID: "Rule00141Annotation", Other: "嵌套越深，需要扫描的行数、生成的结果集就越大，SQL的执行效率越低。"}
	Rule00141Message    = &i18n.Message{ID: "Rule00141Message", Other: "表关联嵌套循环的层次过多"}
	Rule00141Params1    = &i18n.Message{ID: "Rule00141Params1", Other: "表关联嵌套循环层数"}
	Rule00143Desc       = &i18n.Message{ID: "Rule00143Desc", Other: "多表关联时，不建议在WHERE条件中对不同表的字段使用OR条件"}
	Rule00143Annotation = &i18n.Message{ID: "Rule00143Annotation", Other: "多表关联时，在WHERE条件中对不同表的字段使用OR条件可能会导致SQL无法使用正确的索引"}
	Rule00143Message    = &i18n.Message{ID: "Rule00143Message", Other: "多表关联时，不建议在WHERE条件中对不同表的字段使用OR条件"}
	Rule00151Desc       = &i18n.Message{ID: "Rule00151Desc", Other: "避免CREATE TABLE/ALTER TABLE 使用禁止的表空间"}
	Rule00151Annotation = &i18n.Message{ID: "Rule00151Annotation", Other: "不允许在系统表空间上创建用户对象，避免不必要的安全风险，方便维护"}
	Rule00151Message    = &i18n.Message{ID: "Rule00151Message", Other: "避免CREATE TABLE/ALTER TABLE 使用禁止的表空间"}
	Rule00153Desc       = &i18n.Message{ID: "Rule00153Desc", Other: "创建表建议添加索引"}
	Rule00153Annotation = &i18n.Message{ID: "Rule00153Annotation", Other: "规划和设计表时，索引应根据业务需求和数据分布合理创建，无索引通常是不合理的情况"}
	Rule00153Message    = &i18n.Message{ID: "Rule00153Message", Other: "创建表建议添加索引"}
	Rule00161Desc       = &i18n.Message{ID: "Rule00161Desc", Other: "建议序列或自增字段的步长为1"}
	Rule00161Annotation = &i18n.Message{ID: "Rule00161Annotation", Other: "序列或自增字段的步长为1时，有助于保证主键和其他自增字段的连续性，避免不必要的数据间隔和数字资源的浪费。不仅简化了数据库的管理和维护，而且也提高了系统的可预测性和稳定性。特别是在处理大量数据插入或高并发场景时，连续的主键值还能减少潜在的冲突和错误。"}
	Rule00161Message    = &i18n.Message{ID: "Rule00161Message", Other: "建议序列或自增字段的步长为1"}
	Rule00170Desc       = &i18n.Message{ID: "Rule00170Desc", Other: "避免缩短字段长度"}
	Rule00170Annotation = &i18n.Message{ID: "Rule00170Annotation", Other: "修改字段长度值低于现有字段长度值，如果该字段现有数据超出设定后的长度，会造成语句执行报错"}
	Rule00170Message    = &i18n.Message{ID: "Rule00170Message", Other: "避免缩短字段长度. 字段 %s 的新长度 %d 小于当前最大长度 %d"}
	Rule00174Desc       = &i18n.Message{ID: "Rule00174Desc", Other: "禁止GRANT 授予过高权限"}
	Rule00174Annotation = &i18n.Message{ID: "Rule00174Annotation", Other: "授予过高权限，可能会带来严重的安全风险。"}
	Rule00174Message    = &i18n.Message{ID: "Rule00174Message", Other: "禁止GRANT 授予过高权限"}
	Rule00174Params1    = &i18n.Message{ID: "Rule00174Params1", Other: "高权限范围"}
	Rule00175Desc       = &i18n.Message{ID: "Rule00175Desc", Other: "避免不必要的索引扫描合并"}
	Rule00175Annotation = &i18n.Message{ID: "Rule00175Annotation", Other: "索引合并说明一个查询同时使用了多个索引，增加了更多IO操作，特别是在数据量大的情况下执行效率比复合索引明显更多。此外，索引合并操作可能消耗更多CPU和内存资源，以及较长的查询响应时间。"}
	Rule00175Message    = &i18n.Message{ID: "Rule00175Message", Other: "避免不必要的索引扫描合并"}
	Rule00176Desc       = &i18n.Message{ID: "Rule00176Desc", Other: "不建议SQL中包含hint指令"}
	Rule00176Annotation = &i18n.Message{ID: "Rule00176Annotation", Other: "使用hint可能会导致数据库走错误的执行计划，从而影响执行效率，消耗系统资源。"}
	Rule00176Message    = &i18n.Message{ID: "Rule00176Message", Other: "不建议SQL中包含hint指令"}
	Rule00177Desc       = &i18n.Message{ID: "Rule00177Desc", Other: "建议Order By字段个数不超过指定阈值"}
	Rule00177Annotation = &i18n.Message{ID: "Rule00177Annotation", Other: "使用过多的Order By字段会增加排序操作的复杂性，并可能导致性能下降。排序时，MySQL需要对结果集中的每一行进行多字段比较，这可能会耗费更多的CPU和内存资源。如果排序数据集大小超过了可用内存，则可能会导致创建临时表并在磁盘上进行排序，从而增加I/O开销。"}
	Rule00177Message    = &i18n.Message{ID: "Rule00177Message", Other: "建议Order By字段个数不超过指定阈值. 阈值: %v"}
	Rule00177Params1    = &i18n.Message{ID: "Rule00177Params1", Other: "order by字段个数最大值"}
	Rule00178Desc       = &i18n.Message{ID: "Rule00178Desc", Other: "SQL语句存在全表排序操作"}
	Rule00178Annotation = &i18n.Message{ID: "Rule00178Annotation", Other: "SQL语句存在全表排序操作，无过滤条件，也就是WHERE 必须显式指定过滤条件"}
	Rule00178Message    = &i18n.Message{ID: "Rule00178Message", Other: "SQL语句存在全表排序操作"}
	Rule00179Desc       = &i18n.Message{ID: "Rule00179Desc", Other: "避免隐式数据类型转换的SQL查询"}
	Rule00179Annotation = &i18n.Message{ID: "Rule00179Annotation", Other: "确保WHERE子句中用于索引列的条件字段与索引列的数据类型一致。不一致的数据类型会导致执行计划存在隐式类型转换操作。这种转换不仅增加CPU负担，还可能使得原本高效的索引无法使用，导致查询性能显著下降。"}
	Rule00179Message    = &i18n.Message{ID: "Rule00179Message", Other: "避免隐式数据类型转换的SQL查询"}
	Rule00180Desc       = &i18n.Message{ID: "Rule00180Desc", Other: "避免执行计划中 filter 次数过多"}
	Rule00180Annotation = &i18n.Message{ID: "Rule00180Annotation", Other: "执行计划中的filter 步骤表示查询在检索数据之后需要进行额外的行过滤。过滤通常发生在已经通过索引或其他方法获取的行集上。如果这个步骤处理的行数很多，那么它可能会成为查询性能的瓶颈。"}
	Rule00180Message    = &i18n.Message{ID: "Rule00180Message", Other: "避免执行计划中 filter 次数过多"}
	Rule00180Params1    = &i18n.Message{ID: "Rule00180Params1", Other: "filter 个数阈值"}
	Rule00218Desc       = &i18n.Message{ID: "Rule00218Desc", Other: "联合索引最左侧的字段必须出现在查询条件内"}
	Rule00218Annotation = &i18n.Message{ID: "Rule00218Annotation", Other: "当查询条件包含联合索引的最左侧字段时，查询语句才能更好的利用索引的特性：有序性、过滤性等"}
	Rule00218Message    = &i18n.Message{ID: "Rule00218Message", Other: "联合索引最左侧的字段必须出现在查询条件内. 不符合规范的字段: %v"}
	Rule00219Desc       = &i18n.Message{ID: "Rule00219Desc", Other: "建表DDL必须包括创建时间字段，并应确保该字段能记录表记录的创建时间。"}
	Rule00219Annotation = &i18n.Message{ID: "Rule00219Annotation", Other: "使用创建时间字段，有利于问题查找跟踪和检索数据，同时避免后期对数据生命周期管理不便 ，可保证时间的准确性"}
	Rule00219Message    = &i18n.Message{ID: "Rule00219Message", Other: "建表DDL必须包括创建时间字段，并应确保该字段能记录表记录的创建时间。"}
	Rule00219Params1    = &i18n.Message{ID: "Rule00219Params1", Other: "创建时间字段名"}
	Rule00220Desc       = &i18n.Message{ID: "Rule00220Desc", Other: "避免不带where条件的count(*)或者count(1)"}
	Rule00220Annotation = &i18n.Message{ID: "Rule00220Annotation", Other: "不带 where 条件的 count(*) 或者 count(1) 都是对表进行暴力扫描，极其耗费系统资源"}
	Rule00220Message    = &i18n.Message{ID: "Rule00220Message", Other: "避免不带where条件的count(*)或者count(1)"}
)
