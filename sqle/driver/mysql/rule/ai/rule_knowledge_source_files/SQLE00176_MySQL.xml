<?xml version='1.0' encoding='UTF-8'?>
<Rule>
<规则编号>SQLE00176</规则编号>
<级别>warn</级别>
<数据库类型>MySQL</数据库类型>
<规则种类>执行计划</规则种类>
<规则简述>不建议SQL中包含hint指令</规则简述>
<规则描述>使用hint可能会导致数据库走错误的执行计划，从而影响执行效率，消耗系统资源。</规则描述>
<规则场景>
  <场景 名称="使用HINT来改变查询计划" 数据库版本="MySQL 版本大于 5.7" 检查方式="不连库审核" 适用句型="SELECT、INSERT、UPDATE、DELETE、REPLACE">
    <示例>
        示例表结构:
```sql
        create database db_mysql;
        use db_mysql;

        -- 主表
        CREATE TABLE customers(
          id INT(11) NOT NULL, -- 序号
          name VARCHAR(32) DEFAULT '',-- 姓名
          sex TINYINT NOT NULL, -- 性别
          city VARCHAR(32) NOT NULL, -- 所在城市
          age SMALLINT(4) NOT NULL, -- 值类型
          PRIMARY KEY (id) -- 主键
        );

        create index idx_age_customers on customers(age);
        create index idx_sex_customers on customers(sex);

        CREATE TABLE customers_small(
          id INT(11) NOT NULL, -- 序号
          name VARCHAR(32) DEFAULT '',-- 姓名
          sex TINYINT NOT NULL, -- 性别
          city VARCHAR(32) NOT NULL, -- 所在城市
          age SMALLINT(4) NOT NULL, -- 值类型
          PRIMARY KEY (id) -- 主键
        );

        -- 插入模拟数据 100W 条。
        set @@cte_max_recursion_depth=20000000;
        insert into customers  
        with recursive tmp (a,b,c,d,e) as (
          select 1,'小王22222333',floor(rand()*2),'上海',ceil(rand()*30)+20 
          union all 
          select a+1,concat('小王',a),floor(rand()*2),'上海',ceil(rand()*20)+20 from tmp where a &lt; 1000000) 
          select * from tmp;


        insert into customers_small select * from customers limit 1000;


```
        原理说明：
        1. MySQL 的优化器会根据表的物理设计、表的数据分布、查询的业务形态、表以及索引的统计信息等数据来生成最优的执行计划。
        2. 如果表的增删改比较频繁而导致表、索引的统计信息更新不够及时，优化器则会生成不够优化的执行计划。此时就需要使用HINT来告诉优化器走合适的索引、合适的表连接顺序、合适的表连接算法等优化策略。
        3. MySQL的 HINT 主要分为以下几类：
          1. 索引相关的HINT： FORCE INDEX、IGNORE INDEX、ICP、INDEX
          2. 表连接顺序的HINT：JOIN_ORDER、JOIN_PREFIX、JOIN_FIXED_ORDER、STRAIGHT_JOIN
          3. 表连接算法的HINT：HASH_JOIN、BKA、BNL
          4. 子查询拆分类：MERGE、SEMIJOIN
          5. SESSION 变量指定类： SET_VAR
        4. 使用方法如下：
          1. 通用写法：
```sql
            SELECT /*+ ... */ ...
            INSERT /*+ ... */ ...
            REPLACE /*+ ... */ ...
            UPDATE /*+ ... */ ...
            DELETE /*+ ... */ ...
```
          2. 兼容老版本写法：
```sql
            FROM ... USE/FORCE/IGNORE [INDEX/KEY] FOR [JOIN/ORDER BY/GROUP BY]
            
```
        5. 一般，HINT属于临时性指定SQL 的优化方式，不可标准化使用；标准化使用HINT会导致如下问题：
          1. SQL 的优化方式受限。优化器可能会强制按照HINT的方式来执行而放弃最优的执行计划。
          2. SQL 的写法不够标准化。 每种数据库的HINT写法不一样，名字也不一样，后期数据库迁移会导致迁移工作量非标准化，增加工作量。



        反例：
        SQL1：
```sql
        select /*+ index (customers idx_sex_customers) */ * from customers where age = 20;
```
        或者
```sql
        select age from customers force index for group by(idx_sex_customers) group by age;
```
        或者
```sql
        select age from customers force index for order by(idx_sex_customers) order by  age;
```
        或者
```sql
        select count(*) from customers a join customers_small b ignore index for join(primary) where a.id = b.id;

```
        SQL2：
```sql
        select /*+ join_order(a,b) */ count(*) from customers a join customers_small b where a.id = b.id;
```
        或者
```sql
        select straight_join count(*) from customers a join customers_small b where a.id = b.id;

```
        SQL3：
```sql
        select /*+ set_var(max_execution_time=1) */ * from customers order by name desc limit 1;

```
        SQL4：
```sql
        update customers force index (idx_sex_customers) set sex = 1 where age = 20;


```
        SQL5：
```sql
        delete /*+ index(customers idx_sex_customers) */ from customers where age = 20;

```
        SQL6：
```sql
        insert /*+ index(customers idx_sex_customers) */ into customers values (9999999,'xiaozhangxiaowangxiaofeng',0,'shanghai',90);
        replace /*+ index(customers idx_sex_customers) */ into customers values(9999999,'xiaozhangxiaowangxiaofeng',0,'shanghai',90);




```
        反例说明：
        1. 示例中的SQL 全部使用HINT来给影响优化器生成最优的执行计划，不可取。
        2. 其中SQL1 提示用错误的索引:其中包括GROUP BY、ORDER BY、关联条件、单表过滤；SQL2 提示使用错误的连接顺序；SQL3 提示使用错误的连接耗时。
        3. SQL4、SQL5、SQL6 则是对更新类SQL 使用HINT。

        反例验证： 
        1. 验证三个典型的SQL1、SQL2、SQL3，一个是控制访问路径的，也就是索引的访问；第二个是控制表连接顺序的；第三个是控制执行时长的；
          第一个：
          1. 带INDEX的HINT，导致优化器生成错误的执行计划
```sql
          (mysql:8.4.0:db_mysql)explain select /*+ index (customers idx_sex_customers) */ * from customers where age = 20;
          +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
          | id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
          +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
          |  1 | SIMPLE      | customers | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 997088 |     5.26 | Using where |
          +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
          1 row in set, 1 warning (0.00 sec)

```
          2. 执行时间： 1.22 秒。
```sql
          (mysql:8.4.0:db_mysql)select /*+ index (customers idx_sex_customers) */ * from customers where age = 20;
          Empty set (1.22 sec)

```
          第二个：
          1. 执行计划：改变了两表连接顺序
```sql
          (mysql:8.4.0:db_mysql)explain select /*+ join_order(a,b) */ count(*) from customers a join customers_small b where a.id = b.id;
          +----+-------------+-------+------------+--------+---------------+-------------------+---------+---------------+--------+----------+-------------+
          | id | select_type | table | partitions | type   | possible_keys | key               | key_len | ref           | rows   | filtered | Extra       |
          +----+-------------+-------+------------+--------+---------------+-------------------+---------+---------------+--------+----------+-------------+
          |  1 | SIMPLE      | a     | NULL       | index  | PRIMARY       | idx_sex_customers | 1       | NULL          | 997088 |   100.00 | Using index |
          |  1 | SIMPLE      | b     | NULL       | eq_ref | PRIMARY       | PRIMARY           | 4       | db_mysql.a.id |      1 |   100.00 | Using index |
          +----+-------------+-------+------------+--------+---------------+-------------------+---------+---------------+--------+----------+-------------+
          2 rows in set, 1 warning (0.00 sec)
          
```
          2. 执行时间：耗时6秒。
```sql
          (mysql:8.4.0:db_mysql)select /*+ join_order(a,b) */ count(*) from customers a join customers_small b where a.id = b.id;
          +----------+
          | count(*) |
          +----------+
          |     1000 |
          +----------+
          1 row in set (6.02 sec)


```
          第三个： 
          1. 使用set_var来控制执行时长，超过1毫秒提前终止执行。
```sql
          (mysql:8.4.0:db_mysql)select /*+ set_var(max_execution_time=1) */ * from customers order by name desc limit 1;
          ERROR 3024 (HY000): Query execution was interrupted, maximum statement execution time exceeded

        
```
        正例：
        SQL1：
```sql
        select * from customers where age = 20;
```
        或者
```sql
        select age from customers  group by age;
```
        或者
```sql
        select age from customers  order by  age;

```
        SQL2：
```sql
        select  count(*) from customers a join customers_small b where a.id = b.id;

```
        SQL3：
```sql
        select  * from customers order by name desc limit 1;

```
        SQL4：
```sql
        update customers  set sex = 1 where age = 20;

```
        SQL5：
```sql
        delete from customers where age = 20;

```
        SQL6：
```sql
        insert  into customers values (9999999,'xiaozhangxiaowangxiaofeng',0,'shanghai',90);
```
        或者
```sql
        replace  into customers values(9999999,'xiaozhangxiaowangxiaofeng',0,'shanghai',90);



```
        正例说明：
        1. 正常SQL，不带HINT；让优化器自己选择最优的执行计划执行。

        正例验证：同样验证SQL1、SQL2、SQL3。
        1. SQL1：
          1. 执行对应SQL：执行时间只有10毫秒
```sql
          (mysql:8.4.0:db_mysql)select * from customers where age = 20;
          Empty set (0.01 sec)

```
          2. 不带HINT 的SQL 走索引idx_age_customers，走最优的执行计划。
```sql
          (mysql:8.4.0:db_mysql)explain select * from customers where age = 20;
          +----+-------------+-----------+------------+------+-------------------+-------------------+---------+-------+------+----------+-------+
          | id | select_type | table     | partitions | type | possible_keys     | key               | key_len | ref   | rows | filtered | Extra |
          +----+-------------+-----------+------------+------+-------------------+-------------------+---------+-------+------+----------+-------+
          |  1 | SIMPLE      | customers | NULL       | ref  | idx_age_customers | idx_age_customers | 2       | const |    1 |   100.00 | NULL  |
          +----+-------------+-----------+------------+------+-------------------+-------------------+---------+-------+------+----------+-------+
          1 row in set, 1 warning (0.01 sec)

```
        2. SQL2: 执行时间只有10毫秒，执行计划也走了最正确的表连接顺序。
```sql
        (mysql:8.4.0:db_mysql)select  count(*) from customers a join customers_small b where a.id = b.id;
        +----------+
        | count(*) |
        +----------+
        |     1000 |
        +----------+
        1 row in set (0.01 sec)
        
        (mysql:8.4.0:db_mysql)explain select  count(*) from customers a join customers_small b where a.id = b.id;
        +----+-------------+-------+------------+--------+---------------+---------+---------+---------------+------+----------+-------------+
        | id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref           | rows | filtered | Extra       |
        +----+-------------+-------+------------+--------+---------------+---------+---------+---------------+------+----------+-------------+
        |  1 | SIMPLE      | b     | NULL       | index  | PRIMARY       | PRIMARY | 4       | NULL          | 1000 |   100.00 | Using index |
        |  1 | SIMPLE      | a     | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | db_mysql.b.id |    1 |   100.00 | Using index |
        +----+-------------+-------+------------+--------+---------------+---------+---------+---------------+------+----------+-------------+
        2 rows in set, 1 warning (0.00 sec)
        
```
        3. SQL3： SQL 正常执行，不会提前终止。
```sql
        (mysql:8.4.0:db_mysql)select  * from customers order by name desc limit 1;
        +---------+--------------+-----+--------+-----+
        | id      | name         | sex | city   | age |
        +---------+--------------+-----+--------+-----+
        | 1000000 | 小王999999   |   0 | 上海   |  40 |
        +---------+--------------+-----+--------+-----+
        1 row in set (1.67 sec)

```
        结论：
        1. 不建议SQL 语句添加 HINT，有可能会导致错误的执行计划，增加SQL 的查询耗时，消耗更多的资源；并且由于加HINT 是非标操作，后期数据库移植复杂度增加，项目时间不可控。
    </示例>
    <检查流程描述>
      1. 检查所有DML、DQL 语句，如果下面任意一项为真，则报告违反规则：
        1. 存在/*+ ... */ 这样的注释块
        2. 表名后存在 FORCE INDEX 或者 FORCE KEY 关键词
        3. 表名后存在 USE INDEX 或者 USE KEY 关键词  
        4. 表名后存在 IGNORE INDEX 或者 IGNORE KEY 关键词
        5. 语句中存在 STRAIGHT_JOIN 关键词
    </检查流程描述>
    <知识文档>
      1. HINT 官方文档：https://dev.mysql.com/doc/refman/8.4/en/optimizer-hints.html
    </知识文档>
  </场景>
</规则场景>
<标签><分类 名称="操作对象"><分类值>业务数据</分类值></分类><分类 名称="SQL分类"><分类值>DML</分类值></分类><分类 名称="审核目的"><分类值>增强可维护性</分类值></分类><分类 名称="审核精确度"><分类值>不连库审核</分类值></分类></标签><完成情况>完成</完成情况></Rule>