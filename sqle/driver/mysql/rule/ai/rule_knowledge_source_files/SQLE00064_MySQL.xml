<?xml version='1.0' encoding='UTF-8'?>
<Rule>
    <规则编号>SQLE00064</规则编号>
    <级别>warn</级别>
    <数据库类型>MySQL</数据库类型>
    <规则种类>字段数据类型规范</规则种类>
    <规则简述>不建议索引字段是VARCHAR类型时其长度大于阈值</规则简述>
    <规则变量>
        <变量 name="VARCHAR类型的索引最大长度">767</变量>
    </规则变量>
    <规则描述>建立索引时没有限制索引的大小，索引长度会根据该字段实际存储的值来计算，VARCHAR 定义的长度越长，导致业务写入的内容越多，则建立的索引其存储大小将会越大。</规则描述>
    <规则场景>
        <场景 名称="初始化表结构定义" 数据库版本="大于等于 MySQL 5.7 " 检查方式="不连库审核" 适用句型="CREATE TABLE">
            <示例>
                前置：
```sql
                create database db_mysql;
                use db_mysql;

```
                原理说明：
                1. 表定义字段为varchar时，如果明确该字段会作为索引存在，则需要严格限制字符个数，不能超过 767。 原因如下：
                   1. MySQL的字段最大支持的索引字节数是3072。
                   2. MySQL默认字符集是 utf8mb4，utf8mb4最大一个字符是4个字节。
                   3. 所以最大支持的字符数是 3072/4=768.
                2. 针对varchar字段建立索引时，是按照字符定义长度来计算理论存储空间的；但是如果存储的值一样的话，给 字段 varchar(100)和 varchar(200) 来建立索引，真实的存储空间是一样的。

                示例：
```sql
                -- 表结构1，mark1 字段 200个字符
                CREATE TABLE customers1(
                  id INT NOT NULL, -- 序号
                  name VARCHAR(32) DEFAULT 'lucy',-- 姓名
                  sex int NOT NULL default 0, -- 性别
                  city VARCHAR(32) NOT NULL default 'beijing', -- 所在城市
                  age INT NOT NULL default 0, -- 值类型
                  mark1 varchar(200) not null default '', -- 备注1
                  INDEX idx_mark1_customer1 (mark1),
                  PRIMARY KEY (id) -- 主键
                );

                -- 示例表结构2，mark1 字段768个字符
                CREATE TABLE customers2(
                  id INT NOT NULL, -- 序号
                  name VARCHAR(32) DEFAULT 'lucy',-- 姓名
                  sex int NOT NULL default 0, -- 性别
                  city VARCHAR(32) NOT NULL default 'beijing', -- 所在城市
                  age INT NOT NULL default 0, -- 值类型
                  mark1 varchar(768) not null default '', -- 备注1
                  INDEX idx_mark1_customer2 (mark1),
                  PRIMARY KEY (id) -- 主键
                );
                       

```
                示例验证：
```sql
                -- 对比不同varchar长度，相同数据的索引长度

                -- 表customers1 生成初始样例数据.
                insert into customers1 (id,name,sex,city,age,mark1) values(1,concat('lily',mod(1,100)),floor(rand()*2),'shanghai',ceil(rand()*20)+30,rpad('actionsky',100,'test'));

                -- 表 customers2 生成样例数据： 表 customers2 的字段 mark1 和表 customers1 的字段 mark1 有同样的值
                insert into customers2 select * from customers1;

                -- 两个索引大小一样，都是以实际值来分布的。 
                (mysql:8.0.31-cluster)select table_name,index_length from information_schema.tables where table_name in ('customers1','customers2');
                +------------+--------------+
                | TABLE_NAME | INDEX_LENGTH |
                +------------+--------------+
                | customers1 |        16384 |
                | customers2 |        16384 |
                +------------+--------------+
                2 rows in set (0.00 sec)


```
                结论：
                1. VARCHAR字段的定义大小和索引的大小不对应，索引字段是以VARCHAR 字段的实际存储来分布的。 
                2. 在MySQL 5.7 和MySQL8.0 下均测试完成，索引已经按照实际存储的值来定义，并非按照定义的字符个数存储;
                3. 不过值得注意的是：可以通过规定VARCHAR的字符长度来限定实际存储的值不超过索引字符的最大限制：768个字符。
      
            </示例>
            <检查流程描述>
              1. 对于"CREATE TABLE..."语句，如果存在定义索引操作（如key或者index），则进行下述检查：
                1. 定义一个集合
                2. 将字段类型是varchar的索引列放到集合中。
                3. 进行检查，如果集合中存在某个列的varchar大小大于等于阈值，则报告违反规则。
            </检查流程描述>
            <知识文档>
              1. Create table：https://dev.mysql.com/doc/refman/8.0/en/create-table.html
            </知识文档>
        </场景>
        <场景 名称="添加索引" 数据库版本="大于等于 MySQL 5.7 " 检查方式="连库审核" 适用句型="ALTER TABLE、CREATE INDEX">
            <示例>
                前置：
```sql
                create database db_mysql;
                use db_mysql;

                CREATE TABLE customers(
                  id INT NOT NULL, -- 序号
                  name VARCHAR(32) DEFAULT 'lucy',-- 姓名
                  sex int NOT NULL default 0, -- 性别
                  city VARCHAR(32) NOT NULL default 'beijing', -- 所在城市
                  age INT NOT NULL default 0, -- 值类型
                  mark1 varchar(200) not null default '', -- 备注1
                  PRIMARY KEY (id) -- 主键
                );

```
                原理说明：与【初始化表结构定义】场景一致

                示例SQL：
```sql
                alter table customers add index idx_name_customers(name);
                create index idx_name_customers on customers(name);
                

```
                示例验证：与【初始化表结构定义】场景一致


                结论：与【初始化表结构定义】场景一致
      
            </示例>
            <检查流程描述>
              1. 对于"CREATE INDEX..."语句，
                1. 获取索引字段的数据类型及类型长度，这里的获取需要在线操作。
                2. 字段类型是varchar时，如果其varchar大小大于等于阈值，则报告违反规则。
              2. 对于"ALTER TABLE...ADD INDEX..."语句，进行与上述相同的检查。
            </检查流程描述>
            <知识文档>
              1. CREATE INDEX：https://dev.mysql.com/doc/refman/5.7/en/create-index.html
              2. ALTER TABLE：https://dev.mysql.com/doc/refman/5.7/en/alter-table.html
            </知识文档>
        </场景>
    </规则场景>
    <规则缺陷 />
    <标签><分类 名称="操作对象"><分类值>索引</分类值><分类值>字段</分类值></分类><分类 名称="SQL分类"><分类值>DDL</分类值></分类><分类 名称="审核目的"><分类值>发现性能问题</分类值><分类值>增强可维护性</分类值></分类><分类 名称="审核精确度"><分类值>不连库审核</分类值><分类值>连库审核</分类值></分类></标签><完成情况>完成</完成情况></Rule>