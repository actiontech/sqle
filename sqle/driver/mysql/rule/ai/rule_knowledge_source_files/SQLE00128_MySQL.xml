<?xml version='1.0' encoding='UTF-8'?>
<Rule>
<规则编号>SQLE00128</规则编号>
<级别>warn</级别>
<数据库类型>MySQL</数据库类型>
<规则种类>DML规范</规则种类>
<规则简述>不建议使用 HAVING 子句</规则简述>
<规则描述>对于索引字段，放在HAVING子句中时不会走索引；建议将HAVING子句改写为WHERE中的查询条件，可以在查询处理期间使用索引，提高SQL的执行效率</规则描述>
<规则场景>
  <场景 名称="限制分组查询的返回结果" 数据库版本="MySQL 5.7、MySQL 8.0" 检查方式="不连库审核" 适用关键词="HAVING">
    <示例>
      前置：
      CREATE TABLE t3 (
          id bigint,
          name VARCHAR(32),
          grade NUMERIC
      );
      create index idx_t3_name on t3(name);
      INSERT INTO t3 VALUES(1,'t1',100);
      INSERT INTO t3 SELECT ID + (SELECT count(1) from t3),'t2',120 from t3;
      INSERT INTO t3 SELECT ID + (SELECT count(1) from t3),'t3',130 from t3;
      INSERT INTO t3 SELECT ID + (SELECT count(1) from t3),name,120 from t3;###执行多次，造出十几万数据。

      反例：
      SELECT name,avg(grade) FROM t3 GROUP BY name HAVING name ='t3';

      反例说明：
      数据库系统中，在一条查询语句中使用HAVING子句的目的是限制分组查询的结果返回记录数，通常搭配GROUP BY一起使用。只有在使用了聚合函数且无需分组的查询中，可以单独使用。从执行计划的结果得出一个结论，HAVING子句是对GROUP 结果的数据进行过滤来达到限制分组查询的返回结果，这会增加该SQL的执行成本。

      示例验证：
      1、查看执行计划。
      mysql&gt; explain SELECT name,avg(grade) FROM t3 GROUP BY name HAVING name ='t3';
      +----+-------------+-------+------------+-------+---------------+-------------+---------+------+--------+----------+-------+
      | id | select_type | table | partitions | type  | possible_keys | key         | key_len | ref  | rows   | filtered | Extra |
      +----+-------------+-------+------------+-------+---------------+-------------+---------+------+--------+----------+-------+
      |  1 | SIMPLE      | t3    | NULL       | index | idx_t3_name   | idx_t3_name | 131     | NULL | 523045 |   100.00 | NULL  |
      +----+-------------+-------+------------+-------+---------------+-------------+---------+------+--------+----------+-------+
      1 row in set, 1 warning (0.00 sec)

      正例：
      SELECT name,avg(grade) FROM t3 WHERE name ='t3' GROUP BY name;

      正例说明：
      结合反例说明，为了达到限制分组结果的返回记录数，可以采用WHERE条件在分组操作之前先进行数据过滤。在数据库系统中，WHERE条件可以有效使用索引优化，尽量避免全表扫描，提高SQL的执行效率、降低SQL的资源开销。
      
      示例验证：
      1、查看执行计划。
      mysql&gt; explain SELECT name,avg(grade) FROM t3 WHERE name ='t3' GROUP BY name;
      +----+-------------+-------+------------+------+---------------+-------------+---------+-------+--------+----------+-------+
      | id | select_type | table | partitions | type | possible_keys | key         | key_len | ref   | rows   | filtered | Extra |
      +----+-------------+-------+------------+------+---------------+-------------+---------+-------+--------+----------+-------+
      |  1 | SIMPLE      | t3    | NULL       | ref  | idx_t3_name   | idx_t3_name | 131     | const | 261522 |   100.00 | NULL  |
      +----+-------------+-------+------------+------+---------------+-------------+---------+-------+--------+----------+-------+
      1 row in set, 1 warning (0.01 sec)
      
    </示例>
    <检查流程描述>
      1、对于"SELECT..."语句，检查句子中是否HAVING子句，如果存在，则报告违反规则。
      2、对于"INSERT..."语句，对INSERT语句中的SELECT子句进行与上述相同的检查.
      3、对于"DELETE..."语句，对DELETE语句中的SELECT子句进行与上述相同的检查.
      4、对于"UPDATE..."语句，对UPDATE语句中的SELECT子句进行与上述相同的检查.
    </检查流程描述>
    <知识文档>
      1、SELECT语法：https://dev.mysql.com/doc/refman/5.7/en/select.html
    </知识文档>
  </场景>
</规则场景>
<规则缺陷 />
  <标签>
    <分类 名称="操作对象">
      <分类值>业务数据</分类值>
    </分类>
    <分类 名称="SQL分类">
      <分类值>DML</分类值>
    </分类>
    <分类 名称="审核目的">
      <分类值>发现性能问题</分类值>
    </分类>
  <分类 名称="审核精确度"><分类值>不连库审核</分类值></分类></标签>
<完成情况>完成</完成情况>
</Rule>