<?xml version='1.0' encoding='UTF-8'?>
<Rule>
    <规则编号>SQLE00104</规则编号>
    <级别>warn</级别>
    <数据库类型>MySQL</数据库类型>
    <规则种类>排序和分组效率</规则种类>
    <规则简述>避免在 ORDER BY 语句中对多个不同条件使用不同方向的排序</规则简述>
    <规则描述>在 MySQL 8.0 之前当 ORDER BY 多个列指定的排序方向不同时将无法使用已经建立的索引。在MySQL8.0 之后可以建立对应的排序顺序的联合索引来优化</规则描述>
    <规则场景>
        <场景 名称="对多个列指定不同的排序方向" 数据库版本="MySQL 8.0" 检查方式="连库审核" 适用句型="SELECT、INSERT">
            <示例>
            示例表结构:
```sql
            create database db_mysql;
            use db_mysql;

            CREATE TABLE customers(
            id INT(11) NOT NULL, -- 序号
            name VARCHAR(32) DEFAULT '',-- 姓名
            sex TINYINT NOT NULL, -- 性别
            city VARCHAR(32) NOT NULL, -- 所在城市
            age SMALLINT(4) NOT NULL, -- 值类型
            PRIMARY KEY (id) -- 主键
            );

```
            示例索引：
```sql
            create index idx_name_age_customers on customers(name,age);
            create index idx_age_customers on customers(age);

            -- 插入模拟数据 500W 条。
            set @@cte_max_recursion_depth=20000000;
            insert into customers  
            with recursive tmp (a,b,c,d,e) as (
            select 1,'小王22222333',floor(rand()*2),'上海',ceil(rand()*30)+20 
            union all 
            select a+1,concat('小王',a),floor(rand()*2),'上海',ceil(rand()*20)+20 from tmp where a &lt; 5000000) 
            select * from tmp;

```
          反例：
```sql
          select * from customers order by name,age desc  limit 1;
          select * from customers order by name desc,age asc  limit 1;
          select * from customers order by name,age desc;

```
          反例说明：
          1. 对多个字段进行排序时，如果排序方向不统一，将无法使用到已有的索引，导致性能变差。
          2. 示例中 使用order by name,age desc 或者使用 order by name desc,age asc 等都使用不了原有的索引idx_name_age_customers，因为原有索引本身是一种顺序建立的。

          反例验证： 执行时间有3秒多，太长了。
```sql
          (mysql:8.0.31-cluster)select * from customers order by name,age desc limit 1;
          +----+---------+-----+--------+-----+
          | id | name    | sex | city   | age |
          +----+---------+-----+--------+-----+
          |  2 | 小王1   |   0 | 上海   |  26 |
          +----+---------+-----+--------+-----+
          1 row in set (3.18 sec)
          
         
```
          执行计划：全表扫，没有使用到索引idx_name_age_customers.
```sql
          (mysql:8.0.31-cluster)explain select * from customers order by name,age desc limit 1;
          +----+-------------+-----------+------------+------+---------------+------+---------+------+---------+----------+----------------+
          | id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra          |
          +----+-------------+-----------+------------+------+---------------+------+---------+------+---------+----------+----------------+
          |  1 | SIMPLE      | customers | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 4988304 |   100.00 | Using filesort |
          +----+-------------+-----------+------------+------+---------------+------+---------+------+---------+----------+----------------+
          1 row in set, 1 warning (0.00 sec)
          


```
          正例： MySQL 8.0 以上版本可以建立新索引

          对于 order by name, age desc 建立索引：
```sql
          create index idx_name_age_customers_2 on customers(name,age desc);

```
          或者针对 order by name desc,age asc 建立索引：
```sql
          create index idx_name_age_customers_2 on customers(name desc,age asc);


```
          或者MySQL 8.0 以下版本只能修改SQL 语句，避免对不同字段排序不一致，优化效果一致。
```sql
          select * from customers order by name,age  limit 1;
          select * from customers order by name desc,age desc  limit 1;
          select * from customers order by name,age ;


```
          正例说明：
          1. 新建索引或者修改SQL，可以修正原来SQL 语句命中不了索引的问题。

          正例验证：新建多字段乱序索引
```sql
          (mysql:8.0.31-cluster)create index idx_name_age_customers_2 on customers(name,age desc);
          Query OK, 0 rows affected (33.41 sec)
          Records: 0  Duplicates: 0  Warnings: 0

```
          建立新索引后，再次执行SQL语句，结果秒出
```sql
          (mysql:8.0.31-cluster)select * from customers order by name,age desc limit 1;
            +----+---------+-----+--------+-----+
            | id | name    | sex | city   | age |
            +----+---------+-----+--------+-----+
            |  2 | 小王1   |   0 | 上海   |  26 |
            +----+---------+-----+--------+-----+
            1 row in set (0.00 sec)

          
          
```
          执行计划： 走新建的索引 idx_name_age_customers_2
```sql
          (mysql:8.0.31-cluster)explain select * from customers order by name,age desc limit 1;
          +----+-------------+-----------+------------+-------+---------------+--------------------------+---------+------+------+----------+-------+
          | id | select_type | table     | partitions | type  | possible_keys | key                      | key_len | ref  | rows | filtered | Extra |
          +----+-------------+-----------+------------+-------+---------------+--------------------------+---------+------+------+----------+-------+
          |  1 | SIMPLE      | customers | NULL       | index | NULL          | idx_name_age_customers_2 | 133     | NULL |    1 |   100.00 | NULL  |
          +----+-------------+-----------+------------+-------+---------------+--------------------------+---------+------+------+----------+-------+
          1 row in set, 1 warning (0.00 sec)
          


```
          结论：
          1. 使用多字段乱序排序，性能很差，执行时间长。
          2. 可以针对多字段乱序排序建立新索引或者修改SQL 语句改成多字段一致排序的方式，性能大幅提升。
  
            </示例>
            <检查流程描述>
            1. 对于"SELECT..."语句，
                1. 解析SQL语句，提取出 ORDER BY 子句中的所有列及其排序方向。
                2. 检查这些列是否有相应的索引，以及索引的排序方向。
                3. 如果 ORDER BY 子句中的列排序方向与已有索引不一致，则报告违反规则。
            2. 对于"INSERT...SELECT...FROM..."语句，执行与上面类似的检查。
            </检查流程描述>
            <知识文档>
            1. SQL 优化官方文档： https://dev.mysql.com/doc/refman/8.0/en/statement-optimization.html
            </知识文档>
        </场景>
    </规则场景>
    <关联规则>SQLE00101、SQLE00102、SQLE00119、SQLE00121</关联规则>
<标签><分类 名称="操作对象"><分类值>业务数据</分类值></分类><分类 名称="SQL分类"><分类值>DML</分类值></分类><分类 名称="审核目的"><分类值>发现性能问题</分类值></分类><分类 名称="审核精确度"><分类值>连库审核</分类值></分类></标签><完成情况>完成</完成情况></Rule>