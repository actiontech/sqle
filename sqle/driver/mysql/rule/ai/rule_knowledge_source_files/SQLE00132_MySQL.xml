<?xml version='1.0' encoding='UTF-8'?>
<Rule>
<规则编号>SQLE00132</规则编号>
<级别>notice</级别>
<数据库类型>MySQL</数据库类型>
<规则种类>DML规范</规则种类>
<规则简述>不推荐使用子查询</规则简述>
<规则描述>有些情况下，子查询并不能使用到索引，同时对于返回结果集比较大的子查询，会产生大量的临时表，消耗过多的CPU和IO资源，产生大量的慢查询</规则描述>
<规则场景>
  <场景 名称="子查询场景" 数据库版本="MySQL 所有版本" 检查方式="不连库审核" 适用句型="SELECT、UPDATE、INSERT、INSERT ... SELECT、UNION ALL">
    <示例>
        前置：
          create database if not exists db_mysql;
          use db_mysql;

          -- 表1：学生表
          CREATE TABLE student (
            id INT,
            name VARCHAR(20),
            age INT,
            sex VARCHAR(20),
            update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
          );
          create index idx_student_id on student(id);

          -- 插入模拟数据
          INSERT INTO student (id, name, age, sex)
          SELECT 1000, '小王', CEIL(RAND() * 5) + 18, IF(FLOOR(RAND() * 2) = 1, '男', '女')
          UNION ALL
          SELECT a, CONCAT('小王', a), CEIL(RAND() * 5) + 18, IF(FLOOR(RAND() * 2) = 1, '男', '女')
          FROM (SELECT 1001 + t*1000 + (r % 1000) a FROM (SELECT 0 t UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) A, (SELECT 0 r UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) B) TMP;

          -- 表2：课程表
          CREATE TABLE course (
            id INT,
            name VARCHAR(255),
            teacher_id INT
          );
          create index idx_course_id on course(id);

          -- 插入模拟数据
          INSERT INTO course (id, name, teacher_id)
          SELECT 1, '课程1', 8000
          UNION ALL
          SELECT a, CONCAT('课程', a), a + 7999
          FROM (SELECT 2 + t*100 + (r % 100) a FROM (SELECT 0 t UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) A, (SELECT 0 r UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) B) TMP;

          -- 表3：选课表
          CREATE TABLE sc (
            student_id INT,
            course_id INT,
            score INT
          );
          create index idx_sc_mix_id on sc(student_id,course_id);

          -- 插入模拟数据
          INSERT INTO sc (student_id, course_id, score)
          SELECT a, CEIL(RAND() * 1000), CEIL(RAND() * 70) + 30
          FROM (SELECT 1000 + t*1000 + (r % 1000) a FROM (SELECT 0 t UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) A, (SELECT 0 r UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) B) TMP;


          原理说明：
          1. 可读性差： 复杂的子查询可能会使 SQL 语句变得难以理解和维护，尤其是多层嵌套的子查询。
          2. 性能角度：
            1. 不恰当的子查询设计会导致执行计划不够优化，影响查询性能。比如一些相关子查询可能会在每次外层行处理时都重复执行子查询，效率可能较低。
            2. 子查询处理的数据量不可控，极易产生大量的磁盘临时表，浪费IO和CPU 资源。


          反例：
          SQL1：
          -- 查询所有选了课程名为 '课程500' 的，并且最终分数大于80分的学生名字
          SELECT a.name FROM student a WHERE a.id IN (
              SELECT student_id FROM sc, course c WHERE sc.course_id = c.id
                AND sc.score &gt; 80 AND c.name = '课程500');

          SQL2:
          -- 查询所有课程成绩大于80分的学生数量
          SELECT COUNT(*) FROM student a WHERE EXISTS (
              SELECT 1 FROM sc WHERE sc.student_id = a.id AND sc.score &gt; 80);

          SQL3： 
          -- 更新所有学生的分数为90
          UPDATE sc SET score = 90 WHERE student_id IN (
              SELECT id FROM student);

          SQL4:
          -- 删除所有不存在学生的错误选课记录
          DELETE FROM sc WHERE student_id not IN (
              SELECT id FROM student);

          反例说明：
          示例中使用子查询对于数据量大的情况下，容易使用临时表（Start temporary），占用更多IO资源，影响SQL响应效率。

          反例验证： 
          -- 通过执行计划可以看到，子查询的方式使用了临时表。临时表的数据量随着业务模型的改变而不可控，随时有可能因为临时表BUFFER 不足而写到磁盘上，应该避免。
          (mysql:8.4.0:db_mysql)explain SELECT a.name FROM student a WHERE a.id IN (               SELECT student_id FROM sc, course c WHERE sc.course_id = c.id                 AND sc.score &gt; 80 AND c.name = '课程500');
          +----+-------------+-------+------------+------+----------------+----------------+---------+--------------------+------+----------+------------------------------+
          | id | select_type | table | partitions | type | possible_keys  | key            | key_len | ref                | rows | filtered | Extra                        |
          +----+-------------+-------+------------+------+----------------+----------------+---------+--------------------+------+----------+------------------------------+
          |  1 | SIMPLE      | sc    | NULL       | ALL  | idx_sc_mix_id  | NULL           | NULL    | NULL               |  100 |    33.33 | Using where; Start temporary |
          |  1 | SIMPLE      | a     | NULL       | ref  | idx_student_id | idx_student_id | 5       | test.sc.student_id |    1 |   100.00 | NULL                         |
          |  1 | SIMPLE      | c     | NULL       | ref  | idx_course_id  | idx_course_id  | 5       | test.sc.course_id  |    1 |    10.00 | Using where; End temporary   |
          +----+-------------+-------+------------+------+----------------+----------------+---------+--------------------+------+----------+------------------------------+
          3 rows in set, 1 warning (0.00 sec)


          正例：
          SQL1：
          -- 查询所有选了课程名为 '课程500' 的，并且最终分数大于80分的学生名字
          SELECT a.name FROM student a JOIN sc ON a.id = sc.student_id JOIN course c ON sc.course_id = c.id WHERE sc.score &gt; 80 AND c.name = '课程500';

          SQL2:
          -- 查询所有课程成绩大于80分的学生数量
          SELECT COUNT(DISTINCT a.id) FROM student a JOIN sc ON a.id = sc.student_id WHERE sc.score &gt; 80;

          SQL3： 
          -- 更新所有学生的分数为90
          UPDATE sc JOIN student ON sc.student_id = student.id SET sc.score = 90;

          SQL4:
          -- 删除所有不存在学生的错误选课记录
          DELETE sc FROM sc LEFT JOIN student ON sc.student_id = student.id WHERE student.id IS NULL;

          正例说明：
          JOIN操作通常比子查询更直观，逻辑清晰，便于理解和维护。优化器对JOIN的优化通常更好，未来如果表的索引优化，性能会有显著提升。JOIN语句在添加更多条件或表时更容易扩展。

          正例验证：
          -- 通过执行计划观测：临时表消失，充分利用表索引，效率可以保证。
          (mysql:8.4.0:db_mysql)explain SELECT a.name FROM student a JOIN sc ON a.id = sc.student_id JOIN course c ON sc.course_id = c.id WHERE sc.score &gt; 80 AND c.name = '课程500';
          +----+-------------+-------+------------+------+----------------+----------------+---------+--------------------+------+----------+-------------+
          | id | select_type | table | partitions | type | possible_keys  | key            | key_len | ref                | rows | filtered | Extra       |
          +----+-------------+-------+------------+------+----------------+----------------+---------+--------------------+------+----------+-------------+
          |  1 | SIMPLE      | sc    | NULL       | ALL  | idx_sc_mix_id  | NULL           | NULL    | NULL               |  100 |    33.33 | Using where |
          |  1 | SIMPLE      | a     | NULL       | ref  | idx_student_id | idx_student_id | 5       | test.sc.student_id |    1 |   100.00 | NULL        |
          |  1 | SIMPLE      | c     | NULL       | ref  | idx_course_id  | idx_course_id  | 5       | test.sc.course_id  |    1 |    10.00 | Using where |
          +----+-------------+-------+------------+------+----------------+----------------+---------+--------------------+------+----------+-------------+
          3 rows in set, 1 warning (0.00 sec)

          总结：
          1. 子查询会产生临时表，临时表大小不可控，极易迁移到磁盘，极大的降低查询性能。
          2. 子查询应该修改为多表关联的方式。数据库有多重表关联算法可以对查询进行最优的处理。
                 
    </示例>
    <检查流程描述>
      1. 对于“SELECT ...” 语句，如果以下任意一项为真，则报告违反规则
        1. 语句中的WHERE 条件中有子查询
      2. 对于“INSERT ... SELECT” 语句，执行与上述同样检查。
      3. 对于“UPDATE ...” 语句，执行与上述同样检查。
      4. 对于“DELETE ...” 语句，执行与上述同样检查。
      5. 对于“UNION ALL ...” 语句，执行与上述同样检查。
    </检查流程描述>
    <知识文档>
      1、子查询：https://dev.mysql.com/doc/refman/8.0/en/subqueries.html
      2、子查询应用：https://www.mysqltutorial.org/mysql-basics/mysql-subquery/
    </知识文档>
  </场景>
</规则场景>
<标签><分类 名称="操作对象"><分类值>业务数据</分类值></分类><分类 名称="SQL分类"><分类值>DML</分类值><分类值>嵌套查询和连接</分类值></分类><分类 名称="审核目的"><分类值>发现性能问题</分类值></分类><分类 名称="审核精确度"><分类值>不连库审核</分类值></分类></标签><完成情况>完成</完成情况></Rule>