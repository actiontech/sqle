<?xml version='1.0' encoding='UTF-8'?>
<Rule>
    <规则编号>SQLE00022</规则编号>
    <级别>notice</级别>
    <数据库类型>MySQL</数据库类型>
    <规则种类>索引优化</规则种类>
    <规则简述>避免使用数据倾斜度高的索引字段</规则简述>
    <规则变量>
      <变量 name="数据倾斜度" type="">0.7</变量>
    </规则变量>     
    <规则描述> 为了提高查询效率，建议在执行SQL时优先使用倾斜度低的索引字段。倾斜度低的索引可以更快地定位数据，减少不必要的数据扫描，从而加速查询响应时间。规则检查将会计算候选索引字段的倾斜度，如果索引的倾斜度高于设定的阈值，则建议调整索引策略。</规则描述>
    <规则场景>
        <场景 名称="表结构初始定义" 数据库版本="MySQL 所有版本" 检查方式="连库审核" 适用句型="CREATE INDEX">
        <示例>
          前置：
  
```sql
          -- 主表
          CREATE TABLE customers(
            id INT NOT NULL, -- 序号
            name VARCHAR(32) DEFAULT '',-- 姓名
            sex TINYINT NOT NULL, -- 性别
            city VARCHAR(32) NOT NULL, -- 所在城市
            age SMALLINT NOT NULL, -- 值类型
            PRIMARY KEY (id) -- 主键
          );

          -- 对name、age 列建立索引。
          create index idx_name_customers on customers(name);
          create index idx_age_customers on customers(age);      
      
      
```
          原理说明：
          1. 倾斜度低的索引能够高效筛选出符合条件的数据；相反，倾斜度高的索引筛选符合条件的数据效率则比较低效。
          2. 倾斜度计算公式： ((select COUNT(*)::float  FROM t2 GROUP BY name ORDER BY record_count DESC LIMIT 1)/count(ALL))
              1. 这个公式发生在业务发生变更导致原先字段保存的值有数据倾斜的数据出现。
              2. 比如原先表有100条记录，字段c1的值分布为： 1,2,3,4,5,6,7,8,9,10，每个值都分布很平均，都为0.1，也就是10%； 
              3. 业务在某一刻有所变更，字段c1的某一个值比如8，数据分布从原来的0.1变为0.7，这样会导致这个字段的倾斜度变低，不适合用来继续做索引，需要选择其他的字段来建立新的索引。
              4. 这个公式具体表现在生产应该为：比如需要计算表t1的字段id的倾斜度，
```sql
              select (
                  select count(*)::float as record_count from (select id from t1 limit 50000) group by id order by record_count desc limit 1
              )/ (select count(1)ttl from (select * from t1 limit 50000));
```
          3. 当索引字段倾斜度越低，检索速度越快，索引倾斜度高，则说明重复的数据比较多，检索的时候需要访问更多的记录才能够找到所有目标数据。
          4. 当索引字段倾斜度高到无限趋近于1的时候，基本等同于全表扫描了，此时检索效率肯定是慢的；
          5. 同理，当索引倾斜度小到无限接近0的时候，基本等同于常量扫描，此时检索效率最高。比如主键或者唯一索引。
          6. 创建联合索引时也是一样，按照倾斜度高低来建立，最左列是倾斜度最低的字段。
          7. 一般来讲，数据库都会通过抽样来计算索引倾斜度，比如表数据页有100个，选取20个来计算平均值。
              所以对于优化器来讲，统计信息的更新及时与否影响着执行计划的正确性选择。

        示例：对age 列建立索引。
```sql
        alter table customers add index idx_age_customers(age);
        alter table customers add key idx_age_customers(age);
```
        或者
```sql
        create index idx_age_customers on customers(age);

```
        示例验证：
```sql
        -- 模拟数据倾斜度高的示例验证，为了演示方便，直接加hint来验证
        -- 批量造数据语句，插入500W行数据，基于MySQL 8.0 版本。
        set @@cte_max_recursion_depth=10000000;
        insert into customers  
        with recursive tmp (a,b,c,d,e) as (
          select 1,'小王22222333',floor(rand()*2),'上海',ceil(rand()*30)+20 
          union all 
          select a+1,concat('小王',a),floor(rand()*2),'上海',ceil(rand()*20)+20 from tmp where a &lt; 5000000) 
          select * from tmp;     
 
        -- 确认现有数据分布
        (mysql:8.0.31-cluster)select age,count(1) as cn from customers group by age;
        +-----+--------+
        | age | cn     |
        +-----+--------+
        |  21 | 250323 |
        |  22 | 250238 |
        |  23 | 250114 |
        |  24 | 250195 |
        |  25 | 250608 |
        |  26 | 249794 |
        |  27 | 249815 |
        |  28 | 250220 |
        |  29 | 249410 |
        |  30 | 249460 |
        |  31 | 249234 |
        |  32 | 249526 |
        |  33 | 250461 |
        |  34 | 249661 |
        |  35 | 250199 |
        |  36 | 249994 |
        |  37 | 249373 |
        |  38 | 250736 |
        |  39 | 250127 |
        |  40 | 250512 |
        +-----+--------+
        20 rows in set (0.69 sec)

        -- 模拟数据发生变更，80%年龄都是22。
        (mysql:8.0.31-cluster)update customers set age=22 where age &lt; 37;
        Query OK, 2998382 rows affected (42.32 sec)
        Rows matched: 3999252  Changed: 2998382  Warnings: 0

        -- 在100W取样数据中采用年龄重复率最多的指标来计算数据倾斜度，结果显示，倾斜度非常高。
        (mysql:8.0.31-cluster)select ((select count(1) as cn from (select * from customers order by rand()  limit 1000000) sa group by age order by cn desc limit 1)/1000000) selectivity;
        +-------------+
        | selectivity |
        +-------------+
        |      0.8001 |
        +-------------+
        1 row in set (6.77 sec)   

        -- 对一条SQL 语句使用不同的索引来验证执行时间： 默认优化器选择的是name 列的索引。所以不加HINT和加HINT使用name 列效果一致，秒出结果。        
        (mysql:8.0.31-cluster)select * from customers where  name = '小王22222333' and age &lt; 50;
        +----+----------------+-----+--------+-----+
        | id | name           | sex | city   | age |
        +----+----------------+-----+--------+-----+
        |  1 | 小王22222333   |   0 | 上海   |  22 |
        +----+----------------+-----+--------+-----+
        1 row in set (0.00 sec)

        -- 使用name 列的索引：和不加HINT效果一致。
        (mysql:8.0.31-cluster)select /*+ index(customers idx_name_customers) */ * from customers where  name = '小王22222333' and age &lt; 50;
        +----+----------------+-----+--------+-----+
        | id | name           | sex | city   | age |
        +----+----------------+-----+--------+-----+
        |  1 | 小王22222333   |   0 | 上海   |  22 |
        +----+----------------+-----+--------+-----+
        1 row in set (0.00 sec)

        -- 使用age 列的索引： 选择了区分度非常差的索引字段age，同样的SQL，执行性能大幅降低，执行时间为1分30秒。
        (mysql:8.0.31-cluster)select /*+ index(customers idx_age_customers) */ * from customers where  name = '小王22222333' and age &lt; 50;
        +----+----------------+-----+--------+-----+
        | id | name           | sex | city   | age |
        +----+----------------+-----+--------+-----+
        |  1 | 小王22222333   |   0 | 上海   |  22 |
        +----+----------------+-----+--------+-----+
        1 row in set (1 min 30.13 sec)


```
        结论：
        1. 当索引字段的数据分布集中在某个值时，即使数据种类比较多，当业务SQL在集中度高的数据范围中搜索数据时，SQL的执行效率仍然比较低下。
        2. 在对字段建立索引的时候，需要预先检查索引的倾斜度；建议对于倾斜度较低的字段建立索引；倾斜度高的字段放弃建立索引；
        3. 或者说对于倾斜度比较高的字段，和默认值0.7相差不大，比如0.6，也是可以建立索引的。 这时候可以考虑降低索引倾斜度的阈值。

    </示例>

    <检查流程描述>
    1. 对于CREATE INDEX...语句，
        1. 定义一个集合A
        2. 将本次新增索引涉及的字段放到集合A中
        3. 计算集合A中的每个字段的倾斜度，如果倾斜度大于规则变量值，则报告违反规则。
            倾斜度计算需要在线进行，公式： select  (
```sql
            Select count(*)::float as record_count from (select column_name from table_name limit 50000) group by column_name order by record_count desc limit 1
            )/ (select count(1) ttl from (select * from table_name limit 50000));
```
    2. 对于ALTER TABLE ... ADD KEY/INDEX ... 语句，执行与上述同样检查。
    </检查流程描述>
    <知识文档>
        1. 创建索引官方文档：https://dev.mysql.com/doc/refman/8.0/en/create-index.html
        2. 修改表官方文档：https://dev.mysql.com/doc/refman/8.0/en/alter-table.html
    </知识文档>
</场景>
<场景 名称="根据查询语句反向建立索引" 数据库版本="MySQL 所有版本" 检查方式="连库审核" 适用句型="SELECT、INSERT">
    <示例>
        前置：与【表结构初始定义】场景一致
        
        原理说明：与【表结构初始定义】场景一致

        示例：以下有两条SQL，条件都是根据name、age 字段检索，需要决定对哪个字段建立索引。
        SQL1: `select * from customers where  name = '小王22222333' and age &lt; 50;`

        SQL2: 
```sql
        select * from customers where name = '小王22222333' and age &lt; 50
        union all 
        select * from customers where name = '小王1' and age &lt; 50;

```
        示例说明：
        1. 针对示例SQL，一般会想到如下几个索引：
        1. 根据name 列建立索引；
        2. 根据age 列建立索引；
        3. 根据name,age 建立联合索引；
        4. 根据age,name 建立联合索引。
        2. 以上几个索引创建的依据就是每个字段的倾斜度，对倾斜度低的字段单独建立索引；或者把倾斜度低的字段放在联合索引的左侧。
        3. 索引字段的数据倾斜度的计算，见【表结构初始定义】场景的【原理说明】。

        结论：
        1. 根据SELECT 语句来反推索引的过程中，需要计算那个字段的倾斜度最佳，才能针对性建立索引。
        2. 不能盲目的每个字段都建立索引，否则倾斜度高的字段建立索引对查询提升不大，还会降低表更新的性能。
                
    </示例>

    <检查流程描述>
    1.  对于所有DML语句中的SELECT子句，如果where 条件不是恒为真，
        1. 定义一个集合A
        2. 将WHERE子句中用到的条件字段放到集合A中
        3. 连接数据库，根据集合A的字段，将存在索引的字段放到集合B中
        3. 计算集合B中的每个字段的倾斜度，如果倾斜度大于则变量值，则报告违反规则。
            倾斜度计算需要在线进行，公式： select  (
```sql
                Select count(*) as record_count from (select column_name from table_name limit 50000) group by column_name order by record_count desc limit 1
                )/ (select count(1)ttl from (select * from table_name limit 50000));
```
    </检查流程描述>
    <知识文档>
        1. 创建索引官方文档：https://dev.mysql.com/doc/refman/8.0/en/create-index.html
        2. 修改表官方文档：https://dev.mysql.com/doc/refman/8.0/en/alter-table.html
    </知识文档>
    </场景>
    </规则场景>
    <标签><分类 名称="操作对象"><分类值>索引</分类值></分类><分类 名称="SQL分类"><分类值>DDL</分类值></分类><分类 名称="审核目的"><分类值>发现性能问题</分类值></分类><分类 名称="审核精确度"><分类值>连库审核</分类值></分类></标签><完成情况>完成</完成情况>
</Rule>