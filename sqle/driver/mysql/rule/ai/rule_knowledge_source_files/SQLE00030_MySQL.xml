<?xml version='1.0' encoding='UTF-8'?>
<Rule>
  <规则编号>SQLE00030</规则编号>
  <级别>error</级别>
  <数据库类型>MySQL</数据库类型>
  <规则种类>使用建议</规则种类>
  <规则简述>禁止使用触发器</规则简述>
  <规则描述>触发器难以开发和维护，不能高效移植，且在复杂的逻辑以及高并发下，容易出现死锁影响业务。</规则描述>
  <规则场景>
    <场景 名称="使用触发器" 数据库版本="MySQL 所有版本 " 检查方式="不连库审核" 适用句型="CREATE TRIGGER">
      <示例>
          前置：
          create database db_mysql;
          use db_mysql;
          -- 表结构：
          create table customers(
              id int not null primary key, -- 主键
              name varchar(32) default '' not null, -- 序号
              sex int default 0, -- 性别
              age int default 0, -- 年龄
              mark1 varchar(200) -- 备注1
          );

          原理说明：
          1. 触发器本身是对表进行DML时的每行级联更改；而且触发器里可以包含很复杂的逻辑，这样会导致数据库端处理其不擅长的计算业务，降低整体的TPS。
          2. 触发器里面封装了一定逻辑，所以从原理上来讲，可以把触发器看成一个特殊的存储过程，其缺点可以参考规则SQLE00029。
          3. 触发器里的逻辑如果没有处理好，就会导致原来的DML操作性能下降，进而影响其他事务的执行效率。比如执行时间过长、等锁时间过程、容易出现死锁等。

          反例SQL：
          delimiter ||
          CREATE TRIGGER ins_check BEFORE INSERT ON customers
          FOR EACH ROW
          BEGIN
              IF NEW.age &lt; 18 THEN
                  SET NEW.mark1 = '未满18岁';
              ELSEIF NEW.age &gt;= 18 THEN
                  SET NEW.mark1 = '满18岁，已经成年了';
              END IF;
          END;
          ||
          delimiter ;

          反例说明：
          1. 此示例给表 customers 上创建一个前置insert 触发器，对字段age 进行判断，临界值为18岁，把对应的信息写入到字段mark1中。


          反例验证： 
          插入10W条记录，耗时25秒。
          (mysql:8.4.0-debug:db_mysql)set cte_max_recursion_depth=1000000000;
          Query OK, 0 rows affected (0.00 sec)

          (mysql:8.4.0-debug:db_mysql)insert into customers(id,name,sex,age) with recursive tmp (a,b,c,d) as (select 1,'小季10000000000000',0,20 union all select a+1,concat('小季',a),floor(rand()*2),floor(rand()*30)+10 from tmp where a &lt; 100000) select * from tmp;
          Query OK, 100000 rows affected (25.23 sec)
          Records: 100000  Duplicates: 0  Warnings: 0
          
          
          正例：
          drop trigger ins_check;

          正例说明：
          1. 删掉触发器，把触发器的逻辑从数据库中移除，应用端来实现。

          正例验证： 插入耗时18秒，比有触发器的插入时间短。
          (mysql:8.4.0-debug:db_mysql)drop trigger ins_check;
          Query OK, 0 rows affected (0.02 sec)

          (mysql:8.4.0-debug:db_mysql)truncate table customers;
          Query OK, 0 rows affected (0.06 sec)

          (mysql:8.4.0-debug:db_mysql)insert into customers(id,name,sex,age) with recursive tmp (a,b,c,d) as (select 1,'小季10000000000000',0,20 union all select a+1,concat('小季',a),floor(rand()*2),floor(rand()*30)+10 from tmp where a &lt; 100000) select * from tmp;
          Query OK, 100000 rows affected (18.88 sec)
          Records: 100000  Duplicates: 0  Warnings: 0

          总结：
          1. 触发器会增加DML的耗时，特别是触发器里面逻辑很复杂的场景，进而影响整体的TPS。
          2. 触发器的语法每个数据库不一样，如果后期涉及到数据库迁移，改写工总量巨大。

          解决方案：
          1. 删掉表的触发器，触发器里的处理逻辑全部上推成应用程序来做，减少数据库端的压力。
         
      </示例>
      <检查流程描述>
        1. 对于 "CREATE  ..."语句，如果存在以下任何一项，则报告违反规则：
          1. 句子中包含关键词：TRIGGER
      </检查流程描述>
      <知识文档>
        1. CREATE TRIGGER 官方文档：https://dev.mysql.com/doc/refman/8.4/en/create-trigger.html
      </知识文档>
    </场景>
  </规则场景>
<标签><分类 名称="操作对象"><分类值>触发器</分类值></分类><分类 名称="SQL分类"><分类值>DDL</分类值><分类值>触发器</分类值></分类><分类 名称="审核目的"><分类值>增强可维护性</分类值><分类值>发现性能问题</分类值></分类><分类 名称="审核精确度"><分类值>不连库审核</分类值></分类></标签><完成情况>完成</完成情况></Rule>