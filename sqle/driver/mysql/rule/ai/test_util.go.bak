package ai

import (
	"context"
	"testing"

	"github.com/actiontech/sqle/sqle/driver/mysql"
	rulepkg "github.com/actiontech/sqle/sqle/driver/mysql/rule"
	"github.com/actiontech/sqle/sqle/driver/mysql/session"
	"github.com/actiontech/sqle/sqle/driver/mysql/util"
	driverV2 "github.com/actiontech/sqle/sqle/driver/v2"
	"github.com/actiontech/sqle/sqle/log"
	"github.com/sirupsen/logrus"
)

type testResult struct {
	Results *driverV2.AuditResults
	rules   map[string]rulepkg.RuleHandler
}

func newTestResult() *testResult {
	return &testResult{
		Results: driverV2.NewAuditResults(),
		rules:   rulepkg.RuleHandlerMap,
	}
}

func (t *testResult) add(level driverV2.RuleLevel, ruleName, message string, args ...interface{}) *testResult {
	t.Results.Add(level, ruleName, message, args...)
	return t
}

func (t *testResult) addResult(ruleName string, args ...interface{}) *testResult {
	handler, ok := rulepkg.RuleHandlerMap[ruleName]
	if !ok {
		panic("should not enter here, it means that the uint test result is not expect")
	}
	level := handler.Rule.Level
	message := handler.Message

	return t.add(level, ruleName, message, args...)
}

func (t *testResult) level() driverV2.RuleLevel {
	return t.Results.Level()
}

func (t *testResult) message() string {
	return t.Results.Message()
}

func runSingleRuleInspectCase(rule driverV2.Rule, t *testing.T, desc string, i *mysql.MysqlDriverImpl, sql string, results ...*testResult) {
	i.SetRules([]*driverV2.Rule{&rule})
	inspectCase(t, desc, i, sql, results...)
}

func inspectCase(t *testing.T, desc string, i *mysql.MysqlDriverImpl, sql string, results ...*testResult) {
	stmts, err := util.ParseSql(sql)
	if err != nil {
		t.Errorf("%s test failed, error: %v\n", desc, err)
		return
	}

	if len(stmts) != len(results) {
		t.Errorf("%s test failed, error: result is unknow\n", desc)
		return
	}
	sqls := make([]string, 0, len(stmts))
	for _, stmt := range stmts {
		sqls = append(sqls, stmt.Text())
	}
	actualResults, err := i.Audit(context.TODO(), sqls)
	if err != nil {
		t.Error()
		return
	}
	if len(stmts) != len(actualResults) {
		t.Errorf("%s test failed, error: actual result is unknow\n", desc)
		return
	}

	for idx, stmt := range stmts {
		// result, err := i.Audit(context.TODO(), stmt.Text())
		// if err != nil {
		// 	t.Error(err)
		// 	return
		// }
		if actualResults[idx].Level() != results[idx].level() || actualResults[idx].Message() != results[idx].message() {
			t.Errorf("%s test failed, \n\nsql:\n %s\n\nexpect level: %s\nexpect result:\n%s\n\nactual level: %s\nactual result:\n%s\n",
				desc, stmt.Text(), results[idx].level(), results[idx].message(), actualResults[idx].Level(), actualResults[idx].Message())
		} else {
			t.Logf("\n\ncase:%s\nactual level: %s\nactual result:\n%s\n\n", desc, actualResults[idx].Level(), actualResults[idx].Message())
		}
	}
}

func DefaultMysqlInspect() *mysql.MysqlDriverImpl {
	log.Logger().SetLevel(logrus.ErrorLevel)
	return &mysql.MysqlDriverImpl{
		log: log.NewEntry(),
		inst: &driverV2.DSN{
			Host:         "127.0.0.1",
			Port:         "3306",
			User:         "root",
			Password:     "123456",
			DatabaseName: "mysql",
		},
		Ctx: session.NewMockContext(nil),
		cnf: &Config{
			DDLOSCMinSize:      16,
			DDLGhostMinSize:    -1,
			DMLRollbackMaxRows: 1000,
		},
	}
}
